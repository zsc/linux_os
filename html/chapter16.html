<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第16章：引导过程与初始化</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Linux 内核源代码深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：Linux 内核概述与发展史</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：进程管理与任务调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：内存管理架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：进程间通信机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：虚拟文件系统（VFS）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：具体文件系统实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：块设备层与I/O调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：设备驱动模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：网络协议栈</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：内核同步机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：并发编程模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：容器与命名空间</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：安全子系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：实时Linux</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：性能分析与调试</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：引导过程与初始化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="16">第16章：引导过程与初始化</h1>
<h2 id="_1">本章导读</h2>
<p>系统启动是 Linux 内核最神秘也最关键的阶段。从按下电源按钮到用户登录界面出现，期间经历了复杂的硬件初始化、内核加载、子系统启动等过程。本章将深入剖析从 BIOS/UEFI 固件到 systemd 用户空间的完整启动链路，重点解析内核如何从一个压缩的二进制文件变成运行中的操作系统核心。通过学习本章，您将掌握内核启动的每个关键节点、理解 initcall 机制的设计哲学，并能够优化系统启动性能。</p>
<h2 id="161-biosuefi">16.1 BIOS/UEFI 引导阶段</h2>
<h3 id="1611-bios">16.1.1 传统 BIOS 引导流程</h3>
<p>当 x86 系统上电时，CPU 被硬件强制设置为实模式，并从物理地址 0xFFFFFFF0（Reset Vector）开始执行。这个地址映射到 BIOS ROM，包含一条跳转指令，跳转到 BIOS 初始化代码。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">启动顺序</span><span class="err">：</span>

<span class="mi">1</span><span class="p">.</span><span class="w"> </span><span class="nx">Power</span><span class="w"> </span><span class="nx">On</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nx">CPU</span><span class="w"> </span><span class="nx">Reset</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nx">CS</span><span class="p">:</span><span class="nx">IP</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mh">0xF000</span><span class="p">:</span><span class="mh">0xFFF0</span>
<span class="mi">2</span><span class="p">.</span><span class="w"> </span><span class="nx">BIOS</span><span class="w"> </span><span class="nx">POST</span><span class="w"> </span><span class="p">(</span><span class="nx">Power</span><span class="o">-</span><span class="nx">On</span><span class="w"> </span><span class="k">Self</span><span class="o">-</span><span class="nx">Test</span><span class="p">)</span>
<span class="mi">3</span><span class="p">.</span><span class="w"> </span><span class="nx">内存检测与初始化</span>
<span class="mi">4</span><span class="p">.</span><span class="w"> </span><span class="nx">搜索启动设备</span><span class="err">（</span><span class="nx">按</span><span class="w"> </span><span class="nx">Boot</span><span class="w"> </span><span class="nx">Order</span><span class="err">）</span>
<span class="mi">5</span><span class="p">.</span><span class="w"> </span><span class="nx">加载</span><span class="w"> </span><span class="nx">MBR</span><span class="w"> </span><span class="p">(</span><span class="nx">Master</span><span class="w"> </span><span class="nx">Boot</span><span class="w"> </span><span class="nx">Record</span><span class="p">)</span><span class="w"> </span><span class="nx">到</span><span class="w"> </span><span class="mh">0x7C00</span>
<span class="mi">6</span><span class="p">.</span><span class="w"> </span><span class="nx">跳转到</span><span class="w"> </span><span class="mh">0x7C00</span><span class="w"> </span><span class="nx">执行引导代码</span>
</code></pre></div>

<p>MBR 结构（512 字节）：</p>
<div class="codehilite"><pre><span></span><code><span class="err">偏移</span><span class="w">    </span><span class="err">大小</span><span class="w">     </span><span class="err">描述</span>
<span class="mh">0x000</span><span class="w">   </span><span class="mi">446</span><span class="n">B</span><span class="w">    </span><span class="err">引导代码（</span><span class="n">bootloader</span><span class="w"> </span><span class="n">stage</span><span class="w"> </span><span class="mi">1</span><span class="err">）</span>
<span class="mh">0x1BE</span><span class="w">   </span><span class="mi">64</span><span class="n">B</span><span class="w">     </span><span class="err">分区表（</span><span class="mi">4</span><span class="err">个</span><span class="mi">16</span><span class="err">字节分区项）</span>
<span class="mh">0x1FE</span><span class="w">   </span><span class="mi">2</span><span class="n">B</span><span class="w">      </span><span class="err">魔数</span><span class="w"> </span><span class="mh">0xAA55</span><span class="err">（小端序）</span>
</code></pre></div>

<h3 id="1612-uefi">16.1.2 UEFI 现代引导</h3>
<p>UEFI（Unified Extensible Firmware Interface）提供了更强大的引导机制：</p>
<div class="codehilite"><pre><span></span><code>UEFI 启动流程：
SEC (Security) → PEI (Pre-EFI) → DXE (Driver Execution) → BDS (Boot Device Select) → OS Loader
     ↓              ↓               ↓                        ↓                      ↓
  验证固件      初始化内存      加载驱动和协议           选择启动项            加载内核
</code></pre></div>

<p>UEFI 的关键优势：</p>
<ul>
<li><strong>GPT 分区支持</strong>：突破 MBR 的 2TB 限制</li>
<li><strong>安全启动</strong>：通过签名验证防止 rootkit</li>
<li><strong>网络启动</strong>：原生支持 PXE 和 HTTP 启动</li>
<li><strong>运行时服务</strong>：为 OS 提供持续的固件服务</li>
</ul>
<p>ESP（EFI System Partition）文件布局：</p>
<div class="codehilite"><pre><span></span><code>/EFI/
├── BOOT/
│   └── BOOTX64.EFI    # 默认引导器
├── ubuntu/
│   ├── grubx64.efi     # GRUB UEFI 引导器
│   ├── shimx64.efi     # Secure Boot shim
│   └── grub.cfg        # GRUB 配置
└── Microsoft/
    └── Boot/           # Windows 引导器
</code></pre></div>

<h3 id="1613-bootloader">16.1.3 Bootloader 架构</h3>
<p>现代 Linux 系统主要使用 GRUB2（GRand Unified Bootloader）：</p>
<p>GRUB2 多阶段加载：</p>
<div class="codehilite"><pre><span></span><code>Stage 1 (boot.img):

  - 大小：512 字节（刚好一个扇区）
  - 位置：MBR 或 GPT 的 BIOS Boot Partition
  - 功能：加载 Stage 1.5

Stage 1.5 (core.img):

  - 大小：约 32KB
  - 位置：MBR 后的空闲扇区或专用分区
  - 功能：包含文件系统驱动，能够读取 /boot

Stage 2 (grub modules):

  - 位置：/boot/grub/
  - 功能：提供完整的引导环境
</code></pre></div>

<p>GRUB2 传递给内核的关键参数：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">boot_params</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">screen_info</span><span class="w"> </span><span class="n">screen_info</span><span class="p">;</span><span class="w">    </span><span class="c1">// 显示模式信息</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">apm_bios_info</span><span class="w"> </span><span class="n">apm_bios_info</span><span class="p">;</span><span class="w"> </span><span class="c1">// APM BIOS 信息</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">cmd_line_ptr</span><span class="p">;</span><span class="w">                </span><span class="c1">// 内核命令行指针</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">initrd_addr_max</span><span class="p">;</span><span class="w">             </span><span class="c1">// initrd 最大地址</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">kernel_alignment</span><span class="p">;</span><span class="w">            </span><span class="c1">// 内核对齐要求</span>
<span class="w">    </span><span class="c1">// ... E820 内存映射表</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">e820_entry</span><span class="w"> </span><span class="n">e820_table</span><span class="p">[</span><span class="n">E820_MAX_ENTRIES</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="162">16.2 内核加载与解压</h2>
<h3 id="1621-bzimage">16.2.1 bzImage 格式解析</h3>
<p>Linux 内核编译后生成的 bzImage（big zImage）是一个自解压的可执行文件：</p>
<div class="codehilite"><pre><span></span><code>bzImage 结构：
┌─────────────────┐ 0x0000
│   Setup Header  │ 实模式设置代码（arch/x86/boot/header.S）
├─────────────────┤ 0x1F1 (497)
│   Boot Protocol │ 引导协议版本和标志
├─────────────────┤ 0x200 (512)
│   Setup Code    │ 16位/32位混合代码
├─────────────────┤ setup_sects * 512
│  Protected Mode │ 32/64位压缩内核
│  Kernel (vmlinux.gz)│
└─────────────────┘
</code></pre></div>

<p>关键的 setup_header 字段：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">setup_header</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">  </span><span class="n">setup_sects</span><span class="p">;</span><span class="w">      </span><span class="c1">// setup 代码的扇区数</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">root_flags</span><span class="p">;</span><span class="w">       </span><span class="c1">// 根文件系统标志</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">syssize</span><span class="p">;</span><span class="w">          </span><span class="c1">// 压缩内核大小（16字节为单位）</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">ram_size</span><span class="p">;</span><span class="w">         </span><span class="c1">// 废弃</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">vid_mode</span><span class="p">;</span><span class="w">         </span><span class="c1">// 视频模式</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">root_dev</span><span class="p">;</span><span class="w">         </span><span class="c1">// 根设备号</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">boot_flag</span><span class="p">;</span><span class="w">        </span><span class="c1">// 0xAA55 魔数</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">jump</span><span class="p">;</span><span class="w">             </span><span class="c1">// 跳转指令</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">header</span><span class="p">;</span><span class="w">           </span><span class="c1">// &quot;HdrS&quot; 魔数</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">version</span><span class="p">;</span><span class="w">          </span><span class="c1">// 引导协议版本</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">realmode_swtch</span><span class="p">;</span><span class="w">   </span><span class="c1">// 切换到实模式的钩子</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">start_sys_seg</span><span class="p">;</span><span class="w">    </span><span class="c1">// 废弃</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">kernel_version</span><span class="p">;</span><span class="w">   </span><span class="c1">// 内核版本字符串指针</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">  </span><span class="n">type_of_loader</span><span class="p">;</span><span class="w">   </span><span class="c1">// 引导器类型</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">  </span><span class="n">loadflags</span><span class="p">;</span><span class="w">        </span><span class="c1">// 引导标志</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">setup_move_size</span><span class="p">;</span><span class="w">  </span><span class="c1">// 移动到 setup 代码大小</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">code32_start</span><span class="p">;</span><span class="w">     </span><span class="c1">// 32位代码起始地址</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">ramdisk_image</span><span class="p">;</span><span class="w">    </span><span class="c1">// initrd 加载地址</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">ramdisk_size</span><span class="p">;</span><span class="w">     </span><span class="c1">// initrd 大小</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">bootsect_kludge</span><span class="p">;</span><span class="w">  </span><span class="c1">// 废弃</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">heap_end_ptr</span><span class="p">;</span><span class="w">     </span><span class="c1">// setup heap 结束位置</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">  </span><span class="n">ext_loader_ver</span><span class="p">;</span><span class="w">   </span><span class="c1">// 扩展引导器版本</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">  </span><span class="n">ext_loader_type</span><span class="p">;</span><span class="w">  </span><span class="c1">// 扩展引导器类型</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">cmd_line_ptr</span><span class="p">;</span><span class="w">     </span><span class="c1">// 内核命令行地址</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">initrd_addr_max</span><span class="p">;</span><span class="w">  </span><span class="c1">// initrd 最高地址</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">kernel_alignment</span><span class="p">;</span><span class="w"> </span><span class="c1">// 内核对齐要求</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">  </span><span class="n">relocatable_kernel</span><span class="p">;</span><span class="w"> </span><span class="c1">// 内核是否可重定位</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">  </span><span class="n">min_alignment</span><span class="p">;</span><span class="w">    </span><span class="c1">// 最小对齐（2^n）</span>
<span class="w">    </span><span class="n">__u16</span><span class="w"> </span><span class="n">xloadflags</span><span class="p">;</span><span class="w">       </span><span class="c1">// 扩展引导标志</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">cmdline_size</span><span class="p">;</span><span class="w">     </span><span class="c1">// 命令行最大长度</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">hardware_subarch</span><span class="p">;</span><span class="w"> </span><span class="c1">// 硬件子架构</span>
<span class="w">    </span><span class="n">__u64</span><span class="w"> </span><span class="n">hardware_subarch_data</span><span class="p">;</span><span class="w"> </span><span class="c1">// 子架构数据指针</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">payload_offset</span><span class="p">;</span><span class="w">   </span><span class="c1">// 压缩载荷偏移</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">payload_length</span><span class="p">;</span><span class="w">   </span><span class="c1">// 压缩载荷长度</span>
<span class="w">    </span><span class="n">__u64</span><span class="w"> </span><span class="n">setup_data</span><span class="p">;</span><span class="w">       </span><span class="c1">// setup_data 链表</span>
<span class="w">    </span><span class="n">__u64</span><span class="w"> </span><span class="n">pref_address</span><span class="p">;</span><span class="w">     </span><span class="c1">// 首选加载地址</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">init_size</span><span class="p">;</span><span class="w">        </span><span class="c1">// 初始化所需内存大小</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">handover_offset</span><span class="p">;</span><span class="w">  </span><span class="c1">// EFI handover 协议入口</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="1622">16.2.2 解压过程详解</h3>
<p>内核解压发生在保护模式下，主要代码在 <code>arch/x86/boot/compressed/</code> 目录：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// arch/x86/boot/compressed/head_64.S</span>
<span class="nl">startup_64</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// 1. 清除 BSS 段</span>
<span class="w">    </span><span class="n">xorl</span><span class="w"> </span><span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">eax</span>
<span class="w">    </span><span class="n">leaq</span><span class="w"> </span><span class="n">_bss</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="n">rdi</span>
<span class="w">    </span><span class="n">leaq</span><span class="w"> </span><span class="n">_ebss</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="n">rcx</span>
<span class="w">    </span><span class="n">subq</span><span class="w"> </span><span class="o">%</span><span class="n">rdi</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rcx</span>
<span class="w">    </span><span class="n">shrq</span><span class="w"> </span><span class="n">$3</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rcx</span>
<span class="w">    </span><span class="n">rep</span><span class="w"> </span><span class="n">stosq</span>

<span class="w">    </span><span class="c1">// 2. 建立身份映射页表</span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">paging_prepare</span>

<span class="w">    </span><span class="c1">// 3. 调用 C 语言解压函数</span>
<span class="w">    </span><span class="n">pushq</span><span class="w"> </span><span class="o">%</span><span class="n">rsi</span><span class="w">          </span><span class="c1">// boot_params 指针</span>
<span class="w">    </span><span class="n">movq</span><span class="w"> </span><span class="o">%</span><span class="n">rsi</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rdi</span><span class="w">     </span><span class="c1">// 第一个参数</span>
<span class="w">    </span><span class="n">leaq</span><span class="w"> </span><span class="n">boot_heap</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="n">rsi</span><span class="w">  </span><span class="c1">// 堆空间</span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">extract_kernel</span>

<span class="w">    </span><span class="c1">// 4. 跳转到解压后的内核</span>
<span class="w">    </span><span class="n">popq</span><span class="w"> </span><span class="o">%</span><span class="n">rsi</span>
<span class="w">    </span><span class="n">jmp</span><span class="w"> </span><span class="o">*%</span><span class="n">rax</span>
</code></pre></div>

<p>解压算法支持多种格式：</p>
<ul>
<li><strong>GZIP</strong>：默认选择，压缩率和速度平衡</li>
<li><strong>BZIP2</strong>：更好的压缩率，解压较慢</li>
<li><strong>LZMA/XZ</strong>：最佳压缩率，内存需求大</li>
<li><strong>LZO/LZ4</strong>：快速解压，适合嵌入式系统</li>
</ul>
<h3 id="1623">16.2.3 早期内存布局</h3>
<p>解压后的内存布局（x86_64）：</p>
<div class="codehilite"><pre><span></span><code>物理内存布局：
0x00000000 - 0x000FFFFF  实模式内存（1MB）
  0x00000000 - 0x000003FF  中断向量表（IVT）
  0x00000400 - 0x000004FF  BIOS 数据区（BDA）
  0x00000500 - 0x00007BFF  可用内存
  0x00007C00 - 0x00007DFF  MBR 加载区
  0x00080000 - 0x0009FFFF  扩展 BIOS 数据区（EBDA）
  0x000A0000 - 0x000BFFFF  视频内存
  0x000C0000 - 0x000FFFFF  BIOS ROM

0x00100000+              高端内存
  0x00100000              _text（内核代码段开始）
  <span class="k">...</span>                     内核代码
  _etext                  内核代码段结束
  <span class="k">...</span>                     内核数据
  _edata                  初始化数据结束
  __bss_start             BSS 段开始
  _end                    内核镜像结束
</code></pre></div>

<h2 id="163">16.3 早期初始化</h2>
<h3 id="1631-cpu">16.3.1 CPU 模式切换</h3>
<p>x86 处理器的模式演进路径：</p>
<div class="codehilite"><pre><span></span><code>实模式(16位) → 保护模式(32位) → 长模式(64位)
    ↓              ↓                ↓
  20位地址      4GB地址空间      48位虚拟地址
  1MB内存       分段+分页        仅分页
  无保护        特权级保护       NX位支持
</code></pre></div>

<p>实模式到保护模式切换（arch/x86/boot/pm.c）：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 设置 GDT（全局描述符表）</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setup_gdt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">boot_gdt</span><span class="p">[]</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">[</span><span class="n">GDT_ENTRY_BOOT_CS</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GDT_ENTRY</span><span class="p">(</span><span class="mh">0xc09b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xfffff</span><span class="p">),</span><span class="w">  </span><span class="c1">// 代码段</span>
<span class="w">        </span><span class="p">[</span><span class="n">GDT_ENTRY_BOOT_DS</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GDT_ENTRY</span><span class="p">(</span><span class="mh">0xc093</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xfffff</span><span class="p">),</span><span class="w">  </span><span class="c1">// 数据段</span>
<span class="w">        </span><span class="p">[</span><span class="n">GDT_ENTRY_BOOT_TSS</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GDT_ENTRY</span><span class="p">(</span><span class="mh">0x0089</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="mi">103</span><span class="p">),</span><span class="w">  </span><span class="c1">// TSS</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">gdt_ptr</span><span class="w"> </span><span class="n">gdt</span><span class="p">;</span>
<span class="w">    </span><span class="n">gdt</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">boot_gdt</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">gdt</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">boot_gdt</span><span class="p">;</span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;lgdtl %0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;m&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">gdt</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// 切换到保护模式</span>
<span class="nl">protected_mode_jump</span><span class="p">:</span>
<span class="w">    </span><span class="n">movl</span><span class="w"> </span><span class="o">%</span><span class="n">cr0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">eax</span>
<span class="w">    </span><span class="n">orb</span><span class="w"> </span><span class="n">$X86_CR0_PE</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">al</span><span class="w">    </span><span class="c1">// 设置 PE (Protection Enable) 位</span>
<span class="w">    </span><span class="n">movl</span><span class="w"> </span><span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">cr0</span>
<span class="w">    </span><span class="n">ljmp</span><span class="w"> </span><span class="n">$</span><span class="err">\</span><span class="n">_</span><span class="err">\</span><span class="n">_BOOT</span><span class="err">\</span><span class="n">_CS</span><span class="p">,</span><span class="w"> </span><span class="n">$in_pm32</span><span class="w">  </span><span class="c1">// 长跳转刷新 CS</span>
</code></pre></div>

<p>32位到64位长模式切换：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// arch/x86/boot/compressed/head_64.S</span>
<span class="nl">startup_32:</span>
<span class="w">    </span><span class="c1">// 1. 检查 CPU 是否支持长模式</span>
<span class="w">    </span><span class="nf">movl</span><span class="w"> </span><span class="no">$0x80000001</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">    </span><span class="nf">cpuid</span>
<span class="w">    </span><span class="nf">testl</span><span class="w"> </span><span class="no">$</span><span class="p">(</span><span class="mi">1</span><span class="err">&lt;&lt;</span><span class="mi">29</span><span class="p">),</span><span class="w"> </span><span class="nv">%edx</span><span class="w">    </span><span class="c1">// 检查 LM (Long Mode) 位</span>
<span class="w">    </span><span class="nf">jz</span><span class="w"> </span><span class="no">no_longmode</span>

<span class="w">    </span><span class="c1">// 2. 设置 PAE（物理地址扩展）</span>
<span class="w">    </span><span class="nf">movl</span><span class="w"> </span><span class="nv">%cr4</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">    </span><span class="nf">orl</span><span class="w"> </span><span class="no">$X86_CR4_PAE</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">    </span><span class="nf">movl</span><span class="w"> </span><span class="nv">%eax</span><span class="p">,</span><span class="w"> </span><span class="nv">%cr4</span>

<span class="w">    </span><span class="c1">// 3. 加载 PML4 页表</span>
<span class="w">    </span><span class="nf">movl</span><span class="w"> </span><span class="no">$early_level4_pgt</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">    </span><span class="nf">movl</span><span class="w"> </span><span class="nv">%eax</span><span class="p">,</span><span class="w"> </span><span class="nv">%cr3</span>

<span class="w">    </span><span class="c1">// 4. 启用 EFER.LME（长模式使能）</span>
<span class="w">    </span><span class="nf">movl</span><span class="w"> </span><span class="no">$MSR_EFER</span><span class="p">,</span><span class="w"> </span><span class="nv">%ecx</span>
<span class="w">    </span><span class="nf">rdmsr</span>
<span class="w">    </span><span class="nf">orl</span><span class="w"> </span><span class="no">$EFER_LME</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">    </span><span class="nf">wrmsr</span>

<span class="w">    </span><span class="c1">// 5. 启用分页和保护模式</span>
<span class="w">    </span><span class="nf">movl</span><span class="w"> </span><span class="nv">%cr0</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">    </span><span class="nf">orl</span><span class="w"> </span><span class="no">$</span><span class="p">(</span><span class="no">X86_CR0_PG</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="no">X86_CR0_PE</span><span class="p">),</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">    </span><span class="nf">movl</span><span class="w"> </span><span class="nv">%eax</span><span class="p">,</span><span class="w"> </span><span class="nv">%cr0</span>

<span class="w">    </span><span class="c1">// 6. 长跳转进入64位模式</span>
<span class="w">    </span><span class="nf">ljmp</span><span class="w"> </span><span class="no">$</span><span class="err">\</span><span class="no">_</span><span class="err">\</span><span class="no">_KERNEL</span><span class="err">\</span><span class="no">_CS</span><span class="p">,</span><span class="w"> </span><span class="no">$startup_64</span>
</code></pre></div>

<h3 id="1632">16.3.2 早期页表建立</h3>
<p>Linux 使用 4 级页表（x86_64）：</p>
<div class="codehilite"><pre><span></span><code>虚拟地址分解（48位）：
┌────────┬────────┬────────┬────────┬────────┬──────────┐
│ 符号扩展│  PML4  │  PDPT  │   PD   │   PT   │  Offset  │
│ 16 bits│ 9 bits │ 9 bits │ 9 bits │ 9 bits │ 12 bits  │
└────────┴────────┴────────┴────────┴────────┴──────────┘
          ↓         ↓         ↓         ↓         ↓
        PML4E     PDPTE      PDE       PTE    物理页内偏移
</code></pre></div>

<p>早期页表初始化（arch/x86/kernel/head_64.S）：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 早期页表数据结构</span>
<span class="n">__INITDATA</span>
<span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">early_level4_pgt</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">quad</span><span class="w">   </span><span class="n">level3_ident_pgt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">__START_KERNEL_map</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_KERNPG_TABLE</span>
<span class="w">    </span><span class="p">.</span><span class="n">fill</span><span class="w">   </span><span class="mi">511</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>

<span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">level3_ident_pgt</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">quad</span><span class="w">   </span><span class="n">level2_ident_pgt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">__START_KERNEL_map</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_KERNPG_TABLE</span>
<span class="w">    </span><span class="p">.</span><span class="n">fill</span><span class="w">   </span><span class="mi">511</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>

<span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">level2_ident_pgt</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// 映射前 1GB 物理内存（2MB 大页）</span>
<span class="w">    </span><span class="n">PMDS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">__PAGE_KERNEL_IDENT_LARGE_EXEC</span><span class="p">,</span><span class="w"> </span><span class="n">PTRS_PER_PMD</span><span class="p">)</span>
</code></pre></div>

<p>动态页表建立流程：</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">early_alloc_pgt_buf</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">tables</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INIT_PGT_BUF_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>

<span class="w">    </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memblock_find_in_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1ULL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">tables</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span>
<span class="w">        </span><span class="n">panic</span><span class="p">(</span><span class="s">&quot;Cannot find space for the kernel page tables&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">memblock_reserve</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">tables</span><span class="p">);</span>
<span class="w">    </span><span class="n">pgt_buf_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">    </span><span class="n">pgt_buf_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tables</span><span class="p">;</span>
<span class="w">    </span><span class="n">pgt_buf_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1633">16.3.3 中断和异常初始化</h3>
<p>IDT（中断描述符表）设置：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// arch/x86/kernel/idt.c</span>
<span class="n">gate_desc</span><span class="w"> </span><span class="n">idt_table</span><span class="p">[</span><span class="n">IDT_ENTRIES</span><span class="p">]</span><span class="w"> </span><span class="n">__page_aligned_bss</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">__initconst</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">idt_data</span><span class="w"> </span><span class="n">def_idts</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_DE</span><span class="p">,</span><span class="w">       </span><span class="n">divide_error</span><span class="p">),</span><span class="w">        </span><span class="c1">// 除零异常</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_DB</span><span class="p">,</span><span class="w">       </span><span class="n">debug</span><span class="p">),</span><span class="w">               </span><span class="c1">// 调试异常</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_NMI</span><span class="p">,</span><span class="w">      </span><span class="n">nmi</span><span class="p">),</span><span class="w">                 </span><span class="c1">// 不可屏蔽中断</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_BP</span><span class="p">,</span><span class="w">       </span><span class="n">int3</span><span class="p">),</span><span class="w">                </span><span class="c1">// 断点</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_OF</span><span class="p">,</span><span class="w">       </span><span class="n">overflow</span><span class="p">),</span><span class="w">            </span><span class="c1">// 溢出</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_BR</span><span class="p">,</span><span class="w">       </span><span class="n">bounds</span><span class="p">),</span><span class="w">              </span><span class="c1">// 边界检查</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_UD</span><span class="p">,</span><span class="w">       </span><span class="n">invalid_op</span><span class="p">),</span><span class="w">          </span><span class="c1">// 无效操作码</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_NM</span><span class="p">,</span><span class="w">       </span><span class="n">device_not_available</span><span class="p">),</span><span class="w"> </span><span class="c1">// 设备不可用</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_DF</span><span class="p">,</span><span class="w">       </span><span class="n">double_fault</span><span class="p">),</span><span class="w">        </span><span class="c1">// 双重故障</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_OLD_MF</span><span class="p">,</span><span class="w">   </span><span class="n">coprocessor_segment_overrun</span><span class="p">),</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_TS</span><span class="p">,</span><span class="w">       </span><span class="n">invalid_TSS</span><span class="p">),</span><span class="w">         </span><span class="c1">// 无效 TSS</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_NP</span><span class="p">,</span><span class="w">       </span><span class="n">segment_not_present</span><span class="p">),</span><span class="w"> </span><span class="c1">// 段不存在</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_SS</span><span class="p">,</span><span class="w">       </span><span class="n">stack_segment</span><span class="p">),</span><span class="w">       </span><span class="c1">// 栈段错误</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_GP</span><span class="p">,</span><span class="w">       </span><span class="n">general_protection</span><span class="p">),</span><span class="w">  </span><span class="c1">// 通用保护</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_PF</span><span class="p">,</span><span class="w">       </span><span class="n">page_fault</span><span class="p">),</span><span class="w">          </span><span class="c1">// 页面错误</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_MF</span><span class="p">,</span><span class="w">       </span><span class="n">coprocessor_error</span><span class="p">),</span><span class="w">   </span><span class="c1">// 协处理器错误</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_AC</span><span class="p">,</span><span class="w">       </span><span class="n">alignment_check</span><span class="p">),</span><span class="w">     </span><span class="c1">// 对齐检查</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_MC</span><span class="p">,</span><span class="w">       </span><span class="n">machine_check</span><span class="p">),</span><span class="w">       </span><span class="c1">// 机器检查</span>
<span class="w">    </span><span class="n">INTG</span><span class="p">(</span><span class="n">X86_TRAP_XF</span><span class="p">,</span><span class="w">       </span><span class="n">simd_coprocessor_error</span><span class="p">),</span><span class="w"> </span><span class="c1">// SIMD 异常</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">idt_setup_early_traps</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">idt_setup_from_table</span><span class="p">(</span><span class="n">idt_table</span><span class="p">,</span><span class="w"> </span><span class="n">early_idts</span><span class="p">,</span><span class="w"> </span>
<span class="w">                        </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">early_idts</span><span class="p">),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">load_idt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idt_descr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="164-start_kernel">16.4 start_kernel 流程分析</h2>
<h3 id="1641-start_kernel">16.4.1 start_kernel 总体架构</h3>
<p><code>start_kernel()</code> 是内核 C 代码的入口点，负责初始化所有核心子系统：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// init/main.c</span>
<span class="n">asmlinkage</span><span class="w"> </span><span class="n">__visible</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">start_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">command_line</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">after_dashes</span><span class="p">;</span>

<span class="w">    </span><span class="n">set_task_stack_end_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">);</span><span class="w">  </span><span class="c1">// 设置栈魔数</span>
<span class="w">    </span><span class="n">smp_setup_processor_id</span><span class="p">();</span><span class="w">               </span><span class="c1">// 设置 CPU ID</span>
<span class="w">    </span><span class="n">debug_objects_early_init</span><span class="p">();</span><span class="w">             </span><span class="c1">// 调试对象初始化</span>

<span class="w">    </span><span class="n">cgroup_init_early</span><span class="p">();</span><span class="w">                    </span><span class="c1">// cgroup 早期初始化</span>

<span class="w">    </span><span class="n">local_irq_disable</span><span class="p">();</span><span class="w">                    </span><span class="c1">// 禁用本地中断</span>
<span class="w">    </span><span class="n">early_boot_irqs_disabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 架构相关的早期初始化</span>
<span class="w">    </span><span class="n">boot_cpu_init</span><span class="p">();</span>
<span class="w">    </span><span class="n">page_address_init</span><span class="p">();</span>
<span class="w">    </span><span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">linux_banner</span><span class="p">);</span><span class="w">          </span><span class="c1">// 打印内核版本</span>

<span class="w">    </span><span class="n">setup_arch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command_line</span><span class="p">);</span><span class="w">              </span><span class="c1">// 架构相关设置</span>
<span class="w">    </span><span class="n">setup_command_line</span><span class="p">(</span><span class="n">command_line</span><span class="p">);</span><span class="w">       </span><span class="c1">// 处理命令行参数</span>
<span class="w">    </span><span class="n">setup_nr_cpu_ids</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 设置 CPU 数量</span>
<span class="w">    </span><span class="n">setup_per_cpu_areas</span><span class="p">();</span><span class="w">                  </span><span class="c1">// 设置 per-CPU 区域</span>

<span class="w">    </span><span class="n">smp_prepare_boot_cpu</span><span class="p">();</span><span class="w">                 </span><span class="c1">// 准备启动 CPU</span>
<span class="w">    </span><span class="n">boot_cpu_hotplug_init</span><span class="p">();</span>

<span class="w">    </span><span class="n">build_all_zonelists</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="w">              </span><span class="c1">// 构建内存区域链表</span>
<span class="w">    </span><span class="n">page_alloc_init</span><span class="p">();</span><span class="w">                      </span><span class="c1">// 页分配器初始化</span>

<span class="w">    </span><span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Kernel command line: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">saved_command_line</span><span class="p">);</span>

<span class="w">    </span><span class="n">parse_early_param</span><span class="p">();</span><span class="w">                    </span><span class="c1">// 解析早期参数</span>
<span class="w">    </span><span class="n">after_dashes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_args</span><span class="p">(</span><span class="s">&quot;Booting kernel&quot;</span><span class="p">,</span>
<span class="w">                             </span><span class="n">static_command_line</span><span class="p">,</span><span class="w"> </span><span class="n">__start___param</span><span class="p">,</span>
<span class="w">                             </span><span class="n">__stop___param</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">__start___param</span><span class="p">,</span>
<span class="w">                             </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">unknown_bootoption</span><span class="p">);</span>

<span class="w">    </span><span class="n">jump_label_init</span><span class="p">();</span><span class="w">                      </span><span class="c1">// 静态键初始化</span>

<span class="w">    </span><span class="n">setup_log_buf</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">                       </span><span class="c1">// 设置日志缓冲区</span>
<span class="w">    </span><span class="n">vfs_caches_init_early</span><span class="p">();</span><span class="w">                </span><span class="c1">// VFS 缓存早期初始化</span>
<span class="w">    </span><span class="n">sort_main_extable</span><span class="p">();</span><span class="w">                    </span><span class="c1">// 排序异常表</span>
<span class="w">    </span><span class="n">trap_init</span><span class="p">();</span><span class="w">                            </span><span class="c1">// 陷阱门初始化</span>
<span class="w">    </span><span class="n">mm_init</span><span class="p">();</span><span class="w">                              </span><span class="c1">// 内存管理初始化</span>

<span class="w">    </span><span class="n">ftrace_init</span><span class="p">();</span><span class="w">                          </span><span class="c1">// 函数跟踪初始化</span>

<span class="w">    </span><span class="n">sched_init</span><span class="p">();</span><span class="w">                           </span><span class="c1">// 调度器初始化</span>

<span class="w">    </span><span class="n">preempt_disable</span><span class="p">();</span><span class="w">                      </span><span class="c1">// 禁用抢占</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">(),</span>
<span class="w">         </span><span class="s">&quot;Interrupts were enabled early</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="n">local_irq_disable</span><span class="p">();</span>
<span class="w">    </span><span class="n">early_boot_irqs_disabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">local_irq_enable</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 启用中断</span>

<span class="w">    </span><span class="n">kmem_cache_init_late</span><span class="p">();</span><span class="w">                 </span><span class="c1">// slab 后期初始化</span>

<span class="w">    </span><span class="n">console_init</span><span class="p">();</span><span class="w">                         </span><span class="c1">// 控制台初始化</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">panic_later</span><span class="p">)</span>
<span class="w">        </span><span class="n">panic</span><span class="p">(</span><span class="s">&quot;Too many boot %s vars at `%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">panic_later</span><span class="p">,</span>
<span class="w">              </span><span class="n">panic_param</span><span class="p">);</span>

<span class="w">    </span><span class="n">lockdep_init</span><span class="p">();</span><span class="w">                         </span><span class="c1">// 锁依赖初始化</span>

<span class="w">    </span><span class="n">locking_selftest</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 锁自测</span>

<span class="w">    </span><span class="n">mem_encrypt_init</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 内存加密初始化</span>

<span class="w">    </span><span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">initrd_start</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">initrd_below_start_ok</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_low_pfn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">)),</span>
<span class="w">            </span><span class="n">min_low_pfn</span><span class="p">);</span>
<span class="w">        </span><span class="n">initrd_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cp">#endif</span>

<span class="w">    </span><span class="n">setup_per_cpu_pageset</span><span class="p">();</span><span class="w">                </span><span class="c1">// 设置 per-CPU 页集</span>
<span class="w">    </span><span class="n">numa_policy_init</span><span class="p">();</span><span class="w">                     </span><span class="c1">// NUMA 策略初始化</span>
<span class="w">    </span><span class="n">acpi_early_init</span><span class="p">();</span><span class="w">                      </span><span class="c1">// ACPI 早期初始化</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">late_time_init</span><span class="p">)</span>
<span class="w">        </span><span class="n">late_time_init</span><span class="p">();</span>
<span class="w">    </span><span class="n">sched_clock_init</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 调度时钟初始化</span>
<span class="w">    </span><span class="n">calibrate_delay</span><span class="p">();</span><span class="w">                      </span><span class="c1">// 校准延迟循环</span>
<span class="w">    </span><span class="n">pid_idr_init</span><span class="p">();</span><span class="w">                         </span><span class="c1">// PID IDR 初始化</span>
<span class="w">    </span><span class="n">anon_vma_init</span><span class="p">();</span><span class="w">                        </span><span class="c1">// 匿名 VMA 初始化</span>
<span class="w">    </span><span class="cp">#ifdef CONFIG_X86</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">efi_enabled</span><span class="p">(</span><span class="n">EFI_RUNTIME_SERVICES</span><span class="p">))</span>
<span class="w">        </span><span class="n">efi_enter_virtual_mode</span><span class="p">();</span><span class="w">           </span><span class="c1">// EFI 虚拟模式</span>
<span class="w">    </span><span class="cp">#endif</span>
<span class="w">    </span><span class="n">thread_stack_cache_init</span><span class="p">();</span><span class="w">              </span><span class="c1">// 线程栈缓存初始化</span>
<span class="w">    </span><span class="n">cred_init</span><span class="p">();</span><span class="w">                            </span><span class="c1">// 凭证初始化</span>
<span class="w">    </span><span class="n">fork_init</span><span class="p">();</span><span class="w">                            </span><span class="c1">// fork 初始化</span>
<span class="w">    </span><span class="n">proc_caches_init</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 进程缓存初始化</span>
<span class="w">    </span><span class="n">uts_ns_init</span><span class="p">();</span><span class="w">                          </span><span class="c1">// UTS 命名空间初始化</span>
<span class="w">    </span><span class="n">buffer_init</span><span class="p">();</span><span class="w">                          </span><span class="c1">// 缓冲区初始化</span>
<span class="w">    </span><span class="n">key_init</span><span class="p">();</span><span class="w">                             </span><span class="c1">// 密钥管理初始化</span>
<span class="w">    </span><span class="n">security_init</span><span class="p">();</span><span class="w">                        </span><span class="c1">// 安全模块初始化</span>
<span class="w">    </span><span class="n">dbg_late_init</span><span class="p">();</span><span class="w">                        </span><span class="c1">// 调试后期初始化</span>
<span class="w">    </span><span class="n">vfs_caches_init</span><span class="p">();</span><span class="w">                      </span><span class="c1">// VFS 缓存初始化</span>
<span class="w">    </span><span class="n">pagecache_init</span><span class="p">();</span><span class="w">                       </span><span class="c1">// 页缓存初始化</span>
<span class="w">    </span><span class="n">signals_init</span><span class="p">();</span><span class="w">                         </span><span class="c1">// 信号初始化</span>
<span class="w">    </span><span class="n">seq_file_init</span><span class="p">();</span><span class="w">                        </span><span class="c1">// seq_file 初始化</span>
<span class="w">    </span><span class="n">proc_root_init</span><span class="p">();</span><span class="w">                       </span><span class="c1">// proc 根目录初始化</span>
<span class="w">    </span><span class="n">nsfs_init</span><span class="p">();</span><span class="w">                            </span><span class="c1">// 命名空间文件系统初始化</span>
<span class="w">    </span><span class="n">cpuset_init</span><span class="p">();</span><span class="w">                          </span><span class="c1">// cpuset 初始化</span>
<span class="w">    </span><span class="n">cgroup_init</span><span class="p">();</span><span class="w">                          </span><span class="c1">// cgroup 初始化</span>
<span class="w">    </span><span class="n">taskstats_init_early</span><span class="p">();</span><span class="w">                 </span><span class="c1">// 任务统计初始化</span>
<span class="w">    </span><span class="n">delayacct_init</span><span class="p">();</span><span class="w">                       </span><span class="c1">// 延迟统计初始化</span>

<span class="w">    </span><span class="n">poking_init</span><span class="p">();</span><span class="w">                          </span><span class="c1">// 代码修改初始化</span>
<span class="w">    </span><span class="n">check_bugs</span><span class="p">();</span><span class="w">                           </span><span class="c1">// 检查 CPU 缺陷</span>

<span class="w">    </span><span class="n">acpi_subsystem_init</span><span class="p">();</span><span class="w">                  </span><span class="c1">// ACPI 子系统初始化</span>
<span class="w">    </span><span class="n">arch_post_acpi_subsys_init</span><span class="p">();</span><span class="w">           </span><span class="c1">// 架构 ACPI 后初始化</span>
<span class="w">    </span><span class="n">sfi_init_late</span><span class="p">();</span><span class="w">                        </span><span class="c1">// SFI 后期初始化</span>

<span class="w">    </span><span class="cm">/* 完成调度器初始化 */</span>
<span class="w">    </span><span class="n">scheduler_enable</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* 执行所有 initcall */</span>
<span class="w">    </span><span class="n">rest_init</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1642">16.4.2 关键子系统初始化顺序</h3>
<p>初始化顺序的依赖关系：</p>
<div class="codehilite"><pre><span></span><code>内存管理基础设施
    ↓
中断和异常处理
    ↓
调度器核心
    ↓
时钟和定时器
    ↓
进程管理
    ↓
文件系统
    ↓
设备驱动
</code></pre></div>

<p>关键初始化函数详解：</p>
<ol>
<li><strong>mm_init() - 内存管理初始化</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">mm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">page_ext_init_flatmem</span><span class="p">();</span><span class="w">    </span><span class="c1">// 页扩展初始化</span>
<span class="w">    </span><span class="n">mem_init</span><span class="p">();</span><span class="w">                  </span><span class="c1">// 架构相关内存初始化</span>
<span class="w">    </span><span class="n">kmem_cache_init</span><span class="p">();</span><span class="w">          </span><span class="c1">// slab 分配器初始化</span>
<span class="w">    </span><span class="n">pgtable_init</span><span class="p">();</span><span class="w">             </span><span class="c1">// 页表缓存初始化</span>
<span class="w">    </span><span class="n">vmalloc_init</span><span class="p">();</span><span class="w">             </span><span class="c1">// vmalloc 区域初始化</span>
<span class="w">    </span><span class="n">ioremap_huge_init</span><span class="p">();</span><span class="w">        </span><span class="c1">// 大页 ioremap 初始化</span>
<span class="w">    </span><span class="n">kaslr_late_init</span><span class="p">();</span><span class="w">          </span><span class="c1">// KASLR 后期初始化</span>
<span class="p">}</span>
</code></pre></div>

<ol start="2">
<li><strong>sched_init() - 调度器初始化</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">sched_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">alloc_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 初始化等待队列</span>
<span class="w">    </span><span class="n">wait_bit_init</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 分配调度域拓扑</span>
<span class="w">    </span><span class="n">alloc_size</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nr_cpu_ids</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 分配根域</span>
<span class="w">    </span><span class="n">alloc_size</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nr_cpu_ids</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">alloc_size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_NOWAIT</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 设置各种指针...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">init_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_rt_bandwidth</span><span class="p">,</span><span class="w"> </span><span class="n">global_rt_period</span><span class="p">(),</span><span class="w"> </span><span class="n">global_rt_runtime</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// 初始化每个 CPU 的运行队列</span>
<span class="w">    </span><span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">;</span>

<span class="w">        </span><span class="n">rq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jiffies</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">LOAD_FREQ</span><span class="p">;</span>
<span class="w">        </span><span class="n">init_cfs_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">);</span><span class="w">          </span><span class="c1">// CFS 运行队列</span>
<span class="w">        </span><span class="n">init_rt_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">);</span><span class="w">            </span><span class="c1">// RT 运行队列</span>
<span class="w">        </span><span class="n">init_dl_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">);</span><span class="w">            </span><span class="c1">// Deadline 运行队列</span>

<span class="w">        </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
<span class="w">        </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_rt_rq_list</span><span class="p">);</span>

<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">max_idle_balance_cost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>

<span class="w">        </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">);</span>

<span class="w">        </span><span class="n">rq_attach_root</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">def_root_domain</span><span class="p">);</span>

<span class="w">        </span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nohz_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="cp">#ifdef CONFIG_NO_HZ_FULL</span>
<span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">last_sched_tick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="cp">#endif</span>

<span class="w">        </span><span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">set_load_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w">    </span><span class="c1">// 设置 init 任务权重</span>

<span class="w">    </span><span class="c1">// 初始化 CPU 优先级映射</span>
<span class="w">    </span><span class="n">init_cpu_present</span><span class="p">(</span><span class="n">cpu_possible_mask</span><span class="p">);</span>
<span class="w">    </span><span class="n">init_cpu_online</span><span class="p">(</span><span class="n">cpu_possible_mask</span><span class="p">);</span>

<span class="w">    </span><span class="n">scheduler_running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                  </span><span class="c1">// 标记调度器运行</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1643-rest_init">16.4.3 rest_init 与内核线程创建</h3>
<p><code>rest_init()</code> 创建第一批内核线程并切换到用户空间：</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">noinline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__ref</span><span class="w"> </span><span class="n">rest_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>

<span class="w">    </span><span class="n">rcu_scheduler_starting</span><span class="p">();</span><span class="w">       </span><span class="c1">// RCU 调度器启动</span>

<span class="w">    </span><span class="cm">/*</span>

<span class="cm">     * 创建 kernel_init 线程（PID 1）</span>
<span class="cm">     * 这将成为所有用户进程的祖先</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_thread</span><span class="p">(</span><span class="n">kernel_init</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">CLONE_FS</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to create kernel_init thread&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*</span>

<span class="cm">     * 创建 kthreadd 线程（PID 2）</span>
<span class="cm">     * 负责创建其他内核线程</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_thread</span><span class="p">(</span><span class="n">kthreadd</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">CLONE_FS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CLONE_FILES</span><span class="p">);</span>
<span class="w">    </span><span class="n">kthreadd_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">init_pid_ns</span><span class="p">);</span>

<span class="w">    </span><span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthreadd_done</span><span class="p">);</span><span class="w">       </span><span class="c1">// 通知 kthreadd 创建完成</span>

<span class="w">    </span><span class="cm">/*</span>

<span class="cm">     * 当前任务（PID 0）将成为 idle 进程</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">init_idle_bootup_task</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="w">    </span><span class="n">schedule_preempt_disabled</span><span class="p">();</span><span class="w">    </span><span class="c1">// 开始调度</span>

<span class="w">    </span><span class="cm">/* 调用 cpu_idle 循环 */</span>
<span class="w">    </span><span class="n">cpu_startup_entry</span><span class="p">(</span><span class="n">CPUHP_ONLINE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="165-initcall">16.5 initcall 机制</h2>
<h3 id="1651-initcall">16.5.1 initcall 级别体系</h3>
<p>Linux 使用 initcall 机制来管理驱动和模块的初始化顺序。initcall 分为多个级别，确保依赖关系正确：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// include/linux/init.h</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">initcall_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* initcall 级别定义 */</span>
<span class="cp">#define pure_initcall(fn)       __define_initcall(fn, 0)  </span><span class="c1">// 纯初始化</span>
<span class="cp">#define core_initcall(fn)       __define_initcall(fn, 1)  </span><span class="c1">// 核心初始化</span>
<span class="cp">#define core_initcall_sync(fn)  __define_initcall(fn, 1s) </span><span class="c1">// 核心同步</span>
<span class="cp">#define postcore_initcall(fn)   __define_initcall(fn, 2)  </span><span class="c1">// 核心后</span>
<span class="cp">#define postcore_initcall_sync(fn) __define_initcall(fn, 2s)</span>
<span class="cp">#define arch_initcall(fn)       __define_initcall(fn, 3)  </span><span class="c1">// 架构相关</span>
<span class="cp">#define arch_initcall_sync(fn)  __define_initcall(fn, 3s)</span>
<span class="cp">#define subsys_initcall(fn)     __define_initcall(fn, 4)  </span><span class="c1">// 子系统</span>
<span class="cp">#define subsys_initcall_sync(fn) __define_initcall(fn, 4s)</span>
<span class="cp">#define fs_initcall(fn)         __define_initcall(fn, 5)  </span><span class="c1">// 文件系统</span>
<span class="cp">#define fs_initcall_sync(fn)    __define_initcall(fn, 5s)</span>
<span class="cp">#define device_initcall(fn)     __define_initcall(fn, 6)  </span><span class="c1">// 设备驱动</span>
<span class="cp">#define device_initcall_sync(fn) __define_initcall(fn, 6s)</span>
<span class="cp">#define late_initcall(fn)       __define_initcall(fn, 7)  </span><span class="c1">// 后期初始化</span>
<span class="cp">#define late_initcall_sync(fn)  __define_initcall(fn, 7s)</span>

<span class="cm">/* module_init 实际上是 device_initcall */</span>
<span class="cp">#define module_init(x)  __initcall(x);</span>
</code></pre></div>

<p>initcall 执行顺序：</p>
<div class="codehilite"><pre><span></span><code>    0. pure_initcall        最早执行，基础设施
    1. core_initcall        核心组件
    2. postcore_initcall    核心组件之后
    3. arch_initcall        架构特定代码
    4. subsys_initcall      子系统（总线、电源管理等）
    5. fs_initcall          文件系统
    6. device_initcall      设备驱动（module_init）
    7. late_initcall        最后的初始化
</code></pre></div>

<h3 id="1652-initcall">16.5.2 initcall 实现机制</h3>
<p>initcall 通过特殊的链接器脚本段实现：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// include/asm-generic/vmlinux.lds.h</span>
<span class="cp">#define INIT_CALLS_LEVEL(level)                     \</span>
<span class="cp">    __initcall##level##_start = .;                  \</span>
<span class="cp">    KEEP(*(.initcall##level##.init))               \</span>
<span class="cp">    KEEP(*(.initcall##level##s.init))              \</span>

<span class="cp">#define INIT_CALLS                                   \</span>
<span class="cp">    __initcall_start = .;                          \</span>
<span class="cp">    KEEP(*(.initcallearly.init))                   \</span>
<span class="cp">    INIT_CALLS_LEVEL(0)                            \</span>
<span class="cp">    INIT_CALLS_LEVEL(1)                            \</span>
<span class="cp">    INIT_CALLS_LEVEL(2)                            \</span>
<span class="cp">    INIT_CALLS_LEVEL(3)                            \</span>
<span class="cp">    INIT_CALLS_LEVEL(4)                            \</span>
<span class="cp">    INIT_CALLS_LEVEL(5)                            \</span>
<span class="cp">    INIT_CALLS_LEVEL(rootfs)                       \</span>
<span class="cp">    INIT_CALLS_LEVEL(6)                            \</span>
<span class="cp">    INIT_CALLS_LEVEL(7)                            \</span>
<span class="cp">    __initcall_end = .;</span>
</code></pre></div>

<p>宏展开示例：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 驱动代码</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">my_driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">my_driver_init</span><span class="p">);</span>

<span class="c1">// 展开后</span>
<span class="k">static</span><span class="w"> </span><span class="n">initcall_t</span><span class="w"> </span><span class="n">__initcall_my_driver_init6</span><span class="w"> </span>
<span class="w">    </span><span class="n">__used</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__section__</span><span class="p">(</span><span class="s">&quot;.initcall6.init&quot;</span><span class="p">)))</span><span class="w"> </span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">my_driver_init</span><span class="p">;</span>
</code></pre></div>

<h3 id="1653-do_initcalls">16.5.3 do_initcalls 执行流程</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// init/main.c</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">do_initcalls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">initcall_levels</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">level</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">do_initcall_level</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">do_initcall_level</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">initcall_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">fn</span><span class="p">;</span>

<span class="w">    </span><span class="n">strcpy</span><span class="p">(</span><span class="n">initcall_command_line</span><span class="p">,</span><span class="w"> </span><span class="n">saved_command_line</span><span class="p">);</span>
<span class="w">    </span><span class="n">parse_args</span><span class="p">(</span><span class="n">initcall_level_names</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
<span class="w">               </span><span class="n">initcall_command_line</span><span class="p">,</span><span class="w"> </span><span class="n">__start___param</span><span class="p">,</span>
<span class="w">               </span><span class="n">__stop___param</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">__start___param</span><span class="p">,</span>
<span class="w">               </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span>
<span class="w">               </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">ignore_unknown_bootoption</span><span class="p">);</span>

<span class="w">    </span><span class="n">trace_initcall_level</span><span class="p">(</span><span class="n">initcall_level_names</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initcall_levels</span><span class="p">[</span><span class="n">level</span><span class="p">];</span><span class="w"> </span><span class="n">fn</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">initcall_levels</span><span class="p">[</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">fn</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">do_one_initcall</span><span class="p">(</span><span class="n">initcall_from_entry</span><span class="p">(</span><span class="n">fn</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">__init_or_module</span><span class="w"> </span><span class="nf">do_one_initcall</span><span class="p">(</span><span class="n">initcall_t</span><span class="w"> </span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preempt_count</span><span class="p">();</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">initcall_blacklisted</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

<span class="w">    </span><span class="n">trace_initcall_start</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">();</span>
<span class="w">    </span><span class="n">trace_initcall_finish</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>

<span class="w">    </span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sprintf</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;preemption imbalance &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">preempt_count_set</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">strlcat</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;disabled interrupts &quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">));</span>
<span class="w">        </span><span class="n">local_irq_enable</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">WARN</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;initcall %pS returned with %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="n">msgbuf</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1654">16.5.4 依赖管理与调试</h3>
<p>initcall 调试参数：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 内核命令行参数</span>
<span class="nv">initcall_debug</span><span class="o">=</span><span class="m">1</span><span class="w">        </span><span class="c1"># 打印每个 initcall 的执行时间</span>
<span class="nv">initcall_blacklist</span><span class="o">=</span>foo_init,bar_init<span class="w">  </span><span class="c1"># 黑名单特定 initcall</span>
</code></pre></div>

<p>依赖声明示例：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用 module_param 声明依赖</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">depends_on_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">depends_on_foo</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">depends_on_foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Waiting for foo module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">;</span><span class="w">  </span><span class="c1">// 延迟探测</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 正常初始化</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="166-systemd">16.6 systemd 与用户空间启动</h2>
<h3 id="1661-kernel_init">16.6.1 kernel_init 进程</h3>
<p>kernel_init (PID 1) 是所有用户空间进程的祖先：</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__ref</span><span class="w"> </span><span class="nf">kernel_init</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="n">kernel_init_freeable</span><span class="p">();</span><span class="w">  </span><span class="c1">// 执行可释放的初始化</span>

<span class="w">    </span><span class="cm">/* 需要在释放内存前完成所有异步调用 */</span>
<span class="w">    </span><span class="n">async_synchronize_full</span><span class="p">();</span>

<span class="w">    </span><span class="n">kprobe_free_init_mem</span><span class="p">();</span>
<span class="w">    </span><span class="n">ftrace_free_init_mem</span><span class="p">();</span>
<span class="w">    </span><span class="n">free_initmem</span><span class="p">();</span><span class="w">          </span><span class="c1">// 释放 __init 段内存</span>

<span class="w">    </span><span class="n">mark_readonly</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/*</span>

<span class="cm">     * Kernel mappings are now finalized - update the userspace</span>
<span class="cm">     * page-table to finalize PTI.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">pti_finalize</span><span class="p">();</span>

<span class="w">    </span><span class="n">system_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SYSTEM_RUNNING</span><span class="p">;</span>
<span class="w">    </span><span class="n">numa_default_policy</span><span class="p">();</span>

<span class="w">    </span><span class="n">rcu_end_inkernel_boot</span><span class="p">();</span>

<span class="w">    </span><span class="n">do_sysctl_args</span><span class="p">();</span><span class="w">        </span><span class="c1">// 处理 sysctl 参数</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_init_process</span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to execute %s (error %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">               </span><span class="n">ramdisk_execute_command</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*</span>

<span class="cm">     * 尝试运行 init 进程</span>
<span class="cm">     * 按顺序尝试不同的路径</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">execute_command</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_init_process</span><span class="p">(</span><span class="n">execute_command</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">panic</span><span class="p">(</span><span class="s">&quot;Requested init %s failed (error %d).&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="n">execute_command</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">&quot;/sbin/init&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">&quot;/etc/init&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">&quot;/bin/init&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">&quot;/bin/sh&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">&quot;No working init found. Try passing init= option to kernel.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1662-systemd">16.6.2 systemd 架构</h3>
<p>systemd 作为现代 Linux 的 init 系统，采用并行化启动：</p>
<div class="codehilite"><pre><span></span><code>systemd 核心概念：
┌──────────────┐
│    Unit      │  基本管理单元
├──────────────┤
│   Service    │  守护进程
│   Socket     │  套接字激活
│   Target     │  同步点
│   Mount      │  挂载点
│   Timer      │  定时器
│   Path       │  路径监控
│   Slice      │  资源控制组
│   Scope      │  外部进程组
│   Device     │  设备单元
│   Swap       │  交换分区
└──────────────┘
</code></pre></div>

<p>systemd 启动顺序：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="kd">def</span><span class="n">ault</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">通常链接到</span><span class="w"> </span><span class="n">multi</span><span class="o">-</span><span class="n">user</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="n">或</span><span class="w"> </span><span class="n">graphical</span><span class="mf">.</span><span class="n">target</span><span class="p">)</span>
<span class="w">   </span><span class="err">↓</span>

<span class="mf">2.</span><span class="w"> </span><span class="n">basic</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">基础系统</span><span class="p">)</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="kr">sys</span><span class="n">init</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">系统初始化</span><span class="p">)</span>
<span class="w">   </span><span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">local</span><span class="o">-</span><span class="n">fs</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">本地文件系统</span><span class="p">)</span>
<span class="w">   </span><span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">swap</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">交换分区</span><span class="p">)</span>
<span class="w">   </span><span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="n">cryptsetup</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">加密卷</span><span class="p">)</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">sockets</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">套接字</span><span class="p">)</span>
<span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="n">timers</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">定时器</span><span class="p">)</span>
<span class="w">   </span><span class="err">↓</span>

<span class="mf">3.</span><span class="w"> </span><span class="n">multi</span><span class="o">-</span><span class="n">user</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">多用户模式</span><span class="p">)</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">network</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">网络服务</span><span class="p">)</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="c1">remote-fs.target (远程文件系统)</span>
<span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="err">[</span><span class="n">各种服务</span><span class="mf">...</span><span class="err">]</span>
<span class="w">   </span><span class="err">↓</span>

<span class="mf">4.</span><span class="w"> </span><span class="n">graphical</span><span class="mf">.</span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">图形界面</span><span class="err">，</span><span class="n">可选</span><span class="p">)</span>
</code></pre></div>

<h3 id="1663">16.6.3 启动优化技术</h3>
<ol>
<li><strong>并行化启动</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># systemd service 文件</span>
<span class="k">[Unit]</span>
<span class="na">Description</span><span class="o">=</span><span class="s">My Service</span>
<span class="na">After</span><span class="o">=</span><span class="s">network.target</span><span class="w">       </span><span class="c1"># 依赖声明</span>
<span class="na">Wants</span><span class="o">=</span><span class="s">other.service</span><span class="w">        </span><span class="c1"># 弱依赖</span>

<span class="k">[Service]</span>
<span class="na">Type</span><span class="o">=</span><span class="s">notify</span><span class="w">                </span><span class="c1"># 支持 sd_notify</span>
<span class="na">ExecStart</span><span class="o">=</span><span class="s">/usr/bin/myservice</span>
<span class="na">Restart</span><span class="o">=</span><span class="s">on-failure</span>

<span class="k">[Install]</span>
<span class="na">WantedBy</span><span class="o">=</span><span class="s">multi-user.target</span>
</code></pre></div>

<ol start="2">
<li><strong>套接字激活</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用 systemd 套接字激活</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sd_listen_fds</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">unset_environment</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd_listen_fds</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用 systemd 传递的文件描述符</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SD_LISTEN_FDS_START</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<ol start="3">
<li><strong>启动时间分析</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># systemd 启动分析工具</span>
systemd-analyze<span class="w">                 </span><span class="c1"># 总体启动时间</span>
systemd-analyze<span class="w"> </span>blame<span class="w">           </span><span class="c1"># 每个服务的启动时间</span>
systemd-analyze<span class="w"> </span>critical-chain<span class="w">  </span><span class="c1"># 关键路径分析</span>
systemd-analyze<span class="w"> </span>plot<span class="w"> </span>&gt;<span class="w"> </span>boot.svg<span class="w"> </span><span class="c1"># 生成启动时序图</span>
</code></pre></div>

<h3 id="1664-initramfs">16.6.4 initramfs 与早期用户空间</h3>
<p>initramfs（initial RAM filesystem）提供早期用户空间环境：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// init/initramfs.c</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">populate_rootfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">err</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 如果没有 initramfs，直接返回 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">initrd_start</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 检查是否是 cpio 格式 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">initrd_start</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_INITRAMFS_FORCE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unpack_to_rootfs</span><span class="p">((</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">,</span>
<span class="w">                              </span><span class="n">initrd_size</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">free_initrd_mem</span><span class="p">(</span><span class="n">initrd_start</span><span class="p">,</span><span class="w"> </span><span class="n">initrd_end</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 解压 initramfs */</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unpack_to_rootfs</span><span class="p">(</span><span class="n">__initramfs_start</span><span class="p">,</span>
<span class="w">                          </span><span class="n">__initramfs_size</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="w">        </span><span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">rootfs_initcall</span><span class="p">(</span><span class="n">populate_rootfs</span><span class="p">);</span>
</code></pre></div>

<p>initramfs 生成脚本：</p>
<div class="codehilite"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># 创建 initramfs</span>

<span class="c1"># 创建基本目录结构</span>
mkdir<span class="w"> </span>-p<span class="w"> </span>initramfs/<span class="o">{</span>bin,sbin,etc,proc,sys,dev,lib,lib64<span class="o">}</span>

<span class="c1"># 复制必要的二进制文件</span>
cp<span class="w"> </span>/bin/busybox<span class="w"> </span>initramfs/bin/
<span class="k">for</span><span class="w"> </span>cmd<span class="w"> </span><span class="k">in</span><span class="w"> </span>sh<span class="w"> </span>ls<span class="w"> </span>mount<span class="w"> </span>umount<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span>ln<span class="w"> </span>-s<span class="w"> </span>busybox<span class="w"> </span>initramfs/bin/<span class="nv">$cmd</span>
<span class="k">done</span>

<span class="c1"># 创建 init 脚本</span>
cat<span class="w"> </span>&gt;<span class="w"> </span>initramfs/init<span class="w"> </span><span class="s">&lt;&lt; &#39;EOF&#39;</span>
<span class="s">#!/bin/sh</span>
<span class="s">/bin/mount -t proc none /proc</span>
<span class="s">/bin/mount -t sysfs none /sys</span>
<span class="s">/bin/mount -t devtmpfs none /dev</span>

<span class="s"># 挂载真实根文件系统</span>
<span class="s">/bin/mount -t ext4 /dev/sda1 /newroot</span>

<span class="s"># 切换根文件系统</span>
<span class="s">exec switch_root /newroot /sbin/init</span>
<span class="s">EOF</span>
chmod<span class="w"> </span>+x<span class="w"> </span>initramfs/init

<span class="c1"># 打包成 cpio 归档</span>
<span class="nb">cd</span><span class="w"> </span>initramfs
find<span class="w"> </span>.<span class="w"> </span><span class="p">|</span><span class="w"> </span>cpio<span class="w"> </span>-o<span class="w"> </span>-H<span class="w"> </span>newc<span class="w"> </span><span class="p">|</span><span class="w"> </span>gzip<span class="w"> </span>&gt;<span class="w"> </span>../initramfs.cpio.gz
</code></pre></div>

<h2 id="_2">本章小结</h2>
<p>本章深入探讨了 Linux 内核从上电到用户空间启动的完整过程。我们了解了：</p>
<ol>
<li><strong>固件引导阶段</strong>：BIOS/UEFI 的工作原理，bootloader 的多阶段加载机制，以及引导协议的设计</li>
<li><strong>内核解压和早期初始化</strong>：bzImage 格式、解压算法选择、CPU 模式切换（实模式→保护模式→长模式）</li>
<li><strong>start_kernel 执行流程</strong>：各个子系统的初始化顺序和依赖关系，从内存管理到调度器的建立</li>
<li><strong>initcall 机制</strong>：驱动和模块的分级初始化系统，通过链接器脚本实现的优雅设计</li>
<li><strong>用户空间启动</strong>：kernel_init 进程的创建，systemd 的并行化启动架构，initramfs 的作用</li>
</ol>
<p>关键技术要点：</p>
<ul>
<li>页表的建立过程：从早期恒等映射到完整的虚拟内存系统</li>
<li>中断系统的初始化：IDT 表的设置和异常处理机制</li>
<li>进程 0、1、2 的特殊角色：idle、init 和 kthreadd</li>
<li>systemd 的 target 依赖图和套接字激活机制</li>
</ul>
<p>启动优化的核心思想：</p>
<ul>
<li>并行化：利用多核 CPU 并行执行初始化任务</li>
<li>延迟加载：将非关键组件推迟到需要时才初始化</li>
<li>缓存优化：合理安排代码和数据布局，减少缓存失效</li>
</ul>
<h2 id="_3">练习题</h2>
<h3 id="_4">基础题</h3>
<p><strong>练习 16.1</strong>：解释 BIOS 和 UEFI 启动的主要区别是什么？为什么现代系统倾向于使用 UEFI？</p>
<details>
<summary>答案</summary>
<p>主要区别：</p>
<ol>
<li><strong>启动模式</strong>：BIOS 使用 16 位实模式启动，UEFI 可以直接在 32/64 位模式下运行</li>
<li><strong>分区支持</strong>：BIOS 使用 MBR（最大 2TB），UEFI 使用 GPT（支持超大硬盘）</li>
<li><strong>引导过程</strong>：BIOS 需要多阶段引导（MBR→活动分区），UEFI 可以直接从 ESP 分区加载引导器</li>
<li><strong>安全性</strong>：UEFI 支持安全启动（Secure Boot），可以验证引导器签名</li>
<li><strong>界面</strong>：UEFI 提供图形化设置界面，支持鼠标操作</li>
<li><strong>驱动</strong>：UEFI 有标准的驱动模型，BIOS 需要 INT 13h 等中断调用</li>
</ol>
<p>选择 UEFI 的原因：支持大容量硬盘、更快的启动速度、更好的安全性、网络启动支持</p>
</details>
<p><strong>练习 16.2</strong>：在 x86_64 架构下，内核从实模式切换到长模式需要经过哪些步骤？每个步骤的关键操作是什么？</p>
<details>
<summary>答案</summary>
<p>切换步骤：</p>
<ol>
<li>
<p><strong>实模式→保护模式</strong>：
   - 设置 GDT（全局描述符表）
   - 设置 CR0.PE 位（保护模式使能）
   - 执行长跳转刷新 CS 段选择器</p>
</li>
<li>
<p><strong>保护模式→长模式兼容</strong>：
   - 检查 CPUID 确认 CPU 支持长模式
   - 设置 CR4.PAE 位（物理地址扩展）
   - 建立 4 级页表（PML4）
   - 设置 CR3 指向页表基址</p>
</li>
<li>
<p><strong>启用长模式</strong>：
   - 设置 EFER.LME 位（长模式使能）
   - 设置 CR0.PG 位（启用分页）
   - 执行长跳转进入 64 位代码段</p>
</li>
</ol>
<p>关键点：必须先启用 PAE，然后设置 LME，最后启用分页</p>
</details>
<p><strong>练习 16.3</strong>：解释 initcall 的七个级别及其用途，为什么需要这种分级机制？</p>
<details>
<summary>答案</summary>
<p>initcall 级别：</p>
<ol>
<li><strong>pure_initcall (0)</strong>：最基础的初始化，如调试设施</li>
<li><strong>core_initcall (1)</strong>：核心组件，如 CPU、内存检测</li>
<li><strong>postcore_initcall (2)</strong>：核心后初始化，如 IRQ 子系统</li>
<li><strong>arch_initcall (3)</strong>：架构特定初始化，如平台设备</li>
<li><strong>subsys_initcall (4)</strong>：子系统初始化，如总线、电源管理</li>
<li><strong>fs_initcall (5)</strong>：文件系统初始化</li>
<li><strong>device_initcall (6)</strong>：设备驱动（module_init）</li>
<li><strong>late_initcall (7)</strong>：最后的清理和优化</li>
</ol>
<p>需要分级的原因：</p>
<ul>
<li>确保依赖关系正确（如总线必须在设备之前初始化）</li>
<li>避免初始化顺序错误导致的崩溃</li>
<li>提供确定性的初始化顺序</li>
<li>便于调试和问题定位</li>
</ul>
</details>
<h3 id="_5">进阶题</h3>
<p><strong>练习 16.4</strong>：分析 start_kernel 中为什么要先禁用中断，然后在 sched_init 之后才启用？这个顺序如果改变会有什么问题？</p>
<details>
<summary>答案</summary>
<p>禁用中断的原因：</p>
<ol>
<li><strong>数据结构未就绪</strong>：早期初始化时，中断处理所需的数据结构（如 IDT、per-CPU 变量）还未建立</li>
<li><strong>调度器未运行</strong>：中断处理可能需要调度，但调度器还未初始化</li>
<li><strong>避免竞态条件</strong>：初始化过程中的全局数据结构修改需要原子性</li>
</ol>
<p>必须在 sched_init 后启用的原因：</p>
<ul>
<li>中断处理可能唤醒进程，需要调度器支持</li>
<li>时钟中断需要更新调度器的时间片</li>
<li>软中断处理需要 ksoftirqd 线程</li>
</ul>
<p>如果过早启用中断：</p>
<ul>
<li>可能触发空指针解引用（处理函数未注册）</li>
<li>导致死锁（锁机制未初始化）</li>
<li>系统崩溃（必要的数据结构未建立）</li>
</ul>
<p>如果过晚启用中断：</p>
<ul>
<li>某些依赖中断的初始化会失败</li>
<li>定时器相关功能无法工作</li>
<li>设备检测可能超时</li>
</ul>
</details>
<p><strong>练习 16.5</strong>：设计一个最小的 initramfs，要求能够：挂载真实根文件系统、建立基本的 /dev 设备节点、处理启动失败的应急 shell。给出具体实现。</p>
<details>
<summary>答案</summary>
<p>最小 initramfs 实现：</p>
<div class="codehilite"><pre><span></span><code><span class="ch">#!/bin/bash</span>
<span class="c1"># 创建目录结构</span>
mkdir<span class="w"> </span>-p<span class="w"> </span>minimal_initramfs/<span class="o">{</span>bin,dev,etc,lib,lib64,mnt,proc,sys,root,tmp<span class="o">}</span>

<span class="c1"># 安装 busybox（静态链接版本）</span>
cp<span class="w"> </span>/bin/busybox<span class="w"> </span>minimal_initramfs/bin/
<span class="nb">cd</span><span class="w"> </span>minimal_initramfs/bin
<span class="k">for</span><span class="w"> </span>cmd<span class="w"> </span><span class="k">in</span><span class="w"> </span>sh<span class="w"> </span>mount<span class="w"> </span>umount<span class="w"> </span>switch_root<span class="w"> </span>mknod<span class="w"> </span>ls<span class="w"> </span>cat<span class="w"> </span>echo<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span>ln<span class="w"> </span>-s<span class="w"> </span>busybox<span class="w"> </span><span class="nv">$cmd</span>
<span class="k">done</span>
<span class="nb">cd</span><span class="w"> </span>../..

<span class="c1"># 创建 init 脚本</span>
cat<span class="w"> </span>&gt;<span class="w"> </span>minimal_initramfs/init<span class="w"> </span><span class="s">&lt;&lt; &#39;INIT_SCRIPT&#39;</span>
<span class="s">#!/bin/sh</span>

<span class="s"># 应急 shell 函数</span>
<span class="s">rescue_shell() {</span>
<span class="s">    echo &quot;启动失败，进入应急 shell&quot;</span>
<span class="s">    echo &quot;问题：$1&quot;</span>
<span class="s">    exec sh</span>
<span class="s">}</span>

<span class="s"># 挂载必要的文件系统</span>
<span class="s">mount -t proc none /proc || rescue_shell &quot;无法挂载 /proc&quot;</span>
<span class="s">mount -t sysfs none /sys || rescue_shell &quot;无法挂载 /sys&quot;</span>
<span class="s">mount -t devtmpfs none /dev || {</span>
<span class="s">    # 如果 devtmpfs 不可用，手动创建设备节点</span>
<span class="s">    mknod /dev/null c 1 3</span>
<span class="s">    mknod /dev/zero c 1 5</span>
<span class="s">    mknod /dev/random c 1 8</span>
<span class="s">    mknod /dev/urandom c 1 9</span>
<span class="s">    mknod /dev/tty c 5 0</span>
<span class="s">    mknod /dev/console c 5 1</span>
<span class="s">    mknod /dev/sda b 8 0</span>
<span class="s">    mknod /dev/sda1 b 8 1</span>
<span class="s">}</span>

<span class="s"># 解析内核命令行获取根设备</span>
<span class="s">ROOT_DEV=&quot;&quot;</span>
<span class="s">for param in $(cat /proc/cmdline); do</span>
<span class="s">    case $param in</span>
<span class="s">        root=*)</span>
<span class="s">            ROOT_DEV=&quot;${param#root=}&quot;</span>
<span class="s">            ;;</span>
<span class="s">    esac</span>
<span class="s">done</span>

<span class="s">[ -z &quot;$ROOT_DEV&quot; ] &amp;&amp; rescue_shell &quot;未指定 root 参数&quot;</span>

<span class="s"># 等待根设备出现（最多 10 秒）</span>
<span class="s">COUNTER=0</span>
<span class="s">while [ ! -b &quot;$ROOT_DEV&quot; ]; do</span>
<span class="s">    sleep 1</span>
<span class="s">    COUNTER=$((COUNTER + 1))</span>
<span class="s">    [ $COUNTER -ge 10 ] &amp;&amp; rescue\_shell &quot;根设备 $ROOT_DEV 不存在&quot;</span>
<span class="s">done</span>

<span class="s"># 挂载根文件系统</span>
<span class="s">mount -o ro &quot;$ROOT_DEV&quot; /mnt || rescue_shell &quot;无法挂载根文件系统&quot;</span>

<span class="s"># 检查 init 是否存在</span>
<span class="s">[ -x /mnt/sbin/init ] || rescue_shell &quot;/sbin/init 不存在&quot;</span>

<span class="s"># 清理并切换根</span>
<span class="s">umount /proc</span>
<span class="s">umount /sys</span>
<span class="s">umount /dev</span>

<span class="s"># 切换到真实根文件系统</span>
<span class="s">exec switch_root /mnt /sbin/init || rescue_shell &quot;switch_root 失败&quot;</span>
<span class="s">INIT_SCRIPT</span>

chmod<span class="w"> </span>+x<span class="w"> </span>minimal_initramfs/init

<span class="c1"># 打包</span>
<span class="nb">cd</span><span class="w"> </span>minimal_initramfs
find<span class="w"> </span>.<span class="w"> </span><span class="p">|</span><span class="w"> </span>cpio<span class="w"> </span>-o<span class="w"> </span>-H<span class="w"> </span>newc<span class="w"> </span><span class="p">|</span><span class="w"> </span>gzip<span class="w"> </span>&gt;<span class="w"> </span>../minimal_initramfs.cpio.gz
<span class="nb">cd</span><span class="w"> </span>..

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;initramfs 创建完成：minimal_initramfs.cpio.gz&quot;</span>
</code></pre></div>

<p>关键设计点：</p>
<ol>
<li>使用静态链接的 busybox 减少依赖</li>
<li>实现 rescue_shell 提供调试能力</li>
<li>支持 devtmpfs 和手动创建设备节点两种方式</li>
<li>解析内核命令行获取启动参数</li>
<li>实现设备等待机制避免竞态条件</li>
</ol>
</details>
<p><strong>练习 16.6</strong>：systemd 的 socket activation 机制是如何工作的？设计一个支持 socket activation 的简单服务。</p>
<details>
<summary>答案</summary>
<p>Socket Activation 工作原理：</p>
<ol>
<li>systemd 预先创建并监听套接字</li>
<li>当有连接到达时，systemd 启动对应的服务</li>
<li>systemd 通过环境变量传递套接字文件描述符</li>
<li>服务直接使用这些文件描述符，无需自己创建套接字</li>
</ol>
<p>实现示例：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// echo_server.c - 支持 socket activation 的回显服务器</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;systemd/sd-daemon.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/socket.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;netinet/in.h&gt;</span>

<span class="cp">#define BUFFER_SIZE 1024</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">listen_fd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n_fds</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 检查是否由 systemd 启动</span>
<span class="w">    </span><span class="n">n_fds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd_listen_fds</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n_fds</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用 systemd 传递的套接字</span>
<span class="w">        </span><span class="n">listen_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SD_LISTEN_FDS_START</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">sd_notify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;READY=1</span><span class="se">\n</span><span class="s">STATUS=Using systemd socket&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 回退：自己创建套接字</span>
<span class="w">        </span><span class="n">listen_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_in</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">.</span><span class="n">sin_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_INET</span><span class="p">,</span>
<span class="w">            </span><span class="p">.</span><span class="n">sin_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htons</span><span class="p">(</span><span class="mi">8080</span><span class="p">),</span>
<span class="w">            </span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INADDR_ANY</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">listen_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span>
<span class="w">            </span><span class="n">listen</span><span class="p">(</span><span class="n">listen_fd</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;Failed to create socket&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 主循环</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">client_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accept</span><span class="p">(</span><span class="n">listen_fd</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">client_fd</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>

<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">buffer</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="w">            </span><span class="n">write</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w">  </span><span class="c1">// 回显</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">client_fd</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 通知 systemd 处理了一个连接</span>
<span class="w">        </span><span class="n">sd_notify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;STATUS=Processed a connection&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>systemd 配置文件：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># echo.socket</span>
<span class="k">[Unit]</span>
<span class="na">Description</span><span class="o">=</span><span class="s">Echo Server Socket</span>

<span class="k">[Socket]</span>
<span class="na">ListenStream</span><span class="o">=</span><span class="s">8080</span>
<span class="na">Accept</span><span class="o">=</span><span class="s">no</span>

<span class="k">[Install]</span>
<span class="na">WantedBy</span><span class="o">=</span><span class="s">sockets.target</span>

<span class="c1"># echo.service</span>
<span class="k">[Unit]</span>
<span class="na">Description</span><span class="o">=</span><span class="s">Echo Server</span>
<span class="na">Requires</span><span class="o">=</span><span class="s">echo.socket</span>

<span class="k">[Service]</span>
<span class="na">Type</span><span class="o">=</span><span class="s">notify</span>
<span class="na">ExecStart</span><span class="o">=</span><span class="s">/usr/local/bin/echo_server</span>
<span class="na">StandardOutput</span><span class="o">=</span><span class="s">journal</span>
<span class="na">Restart</span><span class="o">=</span><span class="s">on-failure</span>

<span class="k">[Install]</span>
<span class="na">WantedBy</span><span class="o">=</span><span class="s">multi-user.target</span>
</code></pre></div>

<p>优势：</p>
<ul>
<li>零停机时间重启（套接字保持监听）</li>
<li>按需启动服务（节省资源）</li>
<li>并行化启动（服务可以延迟到真正需要时）</li>
</ul>
</details>
<h3 id="_6">挑战题</h3>
<p><strong>练习 16.7</strong>：分析 Linux 内核启动过程中的内存布局变化，从实模式的 1MB 限制到最终的虚拟内存系统。画出各个阶段的内存映射图。</p>
<details>
<summary>提示</summary>
<p>需要考虑的阶段：</p>
<ol>
<li>实模式：段:偏移寻址，20 位地址总线</li>
<li>保护模式早期：恒等映射，GDT 段描述符</li>
<li>启用分页后：临时页表，内核空间映射</li>
<li>最终状态：完整的虚拟内存布局</li>
</ol>
<p>关键转换点：</p>
<ul>
<li>setup_idt：建立中断描述符表</li>
<li>init_mem_mapping：建立内核直接映射</li>
<li>setup_per_cpu_areas：建立 per-CPU 区域</li>
<li>vmalloc_init：初始化 vmalloc 区域</li>
</ul>
<p>需要关注的地址范围：</p>
<ul>
<li>0-1MB：实模式可访问区域</li>
<li>1MB-16MB：ISA DMA 区域</li>
<li>内核代码段：_text 到 _etext</li>
<li>内核直接映射：PAGE_OFFSET 开始</li>
<li>vmalloc 区域：VMALLOC_START 到 VMALLOC_END</li>
</ul>
</details>
<p><strong>练习 16.8</strong>：设计并实现一个启动时间分析工具，能够精确测量内核各个初始化阶段的耗时，并生成火焰图。考虑如何处理早期启动（时钟未初始化）的计时问题。</p>
<details>
<summary>提示</summary>
<p>实现思路：</p>
<ol>
<li><strong>早期计时</strong>：使用 TSC（Time Stamp Counter）或 HPET</li>
<li><strong>数据收集</strong>：在每个 initcall 前后记录时间戳</li>
<li><strong>存储机制</strong>：使用静态数组或 early_memremap</li>
<li><strong>数据导出</strong>：通过 /proc 或 debugfs 接口</li>
<li><strong>可视化</strong>：转换为 FlameGraph 格式</li>
</ol>
<p>关键技术点：</p>
<ul>
<li>rdtsc 指令读取 CPU 时间戳</li>
<li>__init 段的内存会被释放，需要持久化存储</li>
<li>考虑多 CPU 的时间同步问题</li>
<li>处理时钟频率变化（CPU 动态调频）</li>
</ul>
<p>输出格式设计：</p>
<div class="codehilite"><pre><span></span><code>initcall_name;parent_function;duration_us
</code></pre></div>

<p>工具集成：</p>
<ul>
<li>与 ftrace 集成获取更详细的调用栈</li>
<li>支持 bootchart 格式输出</li>
<li>生成 systemd-analyze 兼容的数据</li>
</ul>
</details>
<h2 id="gotchas">常见陷阱与错误 (Gotchas)</h2>
<h3 id="1">1. 启动参数错误</h3>
<p><strong>问题</strong>：内核命令行参数拼写错误或格式不正确导致启动失败</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误：参数之间需要空格</span>
<span class="nv">root</span><span class="o">=</span>/dev/sda1init<span class="o">=</span>/sbin/init<span class="w">  </span>

<span class="c1"># 正确：</span>
<span class="nv">root</span><span class="o">=</span>/dev/sda1<span class="w"> </span><span class="nv">init</span><span class="o">=</span>/sbin/init
</code></pre></div>

<p><strong>解决</strong>：使用 <code>early_param</code> 和 <code>__setup</code> 正确注册参数处理函数</p>
<h3 id="2-initcall">2. initcall 顺序依赖</h3>
<p><strong>问题</strong>：驱动初始化顺序错误导致依赖未满足</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：网卡驱动可能在网络子系统之前初始化</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">network_driver_init</span><span class="p">);</span><span class="w">  </span><span class="c1">// device_initcall 级别</span>

<span class="c1">// 正确：使用更晚的初始化级别</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">network_driver_init</span><span class="p">);</span>
</code></pre></div>

<h3 id="3">3. 早期内存访问</h3>
<p><strong>问题</strong>：在 MMU 启用前访问虚拟地址</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：早期代码不能使用 kmalloc</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">early_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w">  </span><span class="c1">// 崩溃！</span>
<span class="p">}</span>

<span class="c1">// 正确：使用 alloc_bootmem 或静态分配</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">early_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w">  </span><span class="c1">// 或 alloc_bootmem(256)</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="4-init">4. init 段内存释放</h3>
<p><strong>问题</strong>：__init 函数的指针在 init 段释放后使用</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：保存 __init 函数指针</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">saved_func</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">saved_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_init_function</span><span class="p">;</span><span class="w">  </span><span class="c1">// 危险！</span>
<span class="p">}</span>

<span class="c1">// 正确：不保存 __init 函数指针，或移除 __init</span>
</code></pre></div>

<h3 id="5">5. 设备探测竞态</h3>
<p><strong>问题</strong>：根设备还未出现就尝试挂载</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 内核 panic: VFS: Unable to mount root fs</span>
</code></pre></div>

<p><strong>解决</strong>：使用 rootwait 参数或在 initramfs 中实现等待逻辑</p>
<h3 id="6-uefi">6. UEFI 安全启动</h3>
<p><strong>问题</strong>：未签名的内核或模块在 Secure Boot 环境下无法加载
<strong>解决</strong>：</p>
<ul>
<li>使用 MOK (Machine Owner Key) 签名内核模块</li>
<li>或在 BIOS 中禁用 Secure Boot</li>
<li>使用 shim 加载器链</li>
</ul>
<h2 id="_7">最佳实践检查清单</h2>
<h3 id="_8">启动性能优化</h3>
<ul>
<li>[ ] 选择合适的内核压缩算法（LZ4 用于快速解压）</li>
<li>[ ] 精简内核配置，移除不需要的驱动</li>
<li>[ ] 使用 initcall_blacklist 禁用不必要的初始化</li>
<li>[ ] 启用并行化选项（如 PARALLEL_BOOT）</li>
<li>[ ] 优化 initramfs 大小，只包含必要组件</li>
</ul>
<h3 id="initcall">initcall 设计</h3>
<ul>
<li>[ ] 选择正确的 initcall 级别</li>
<li>[ ] 实现 -EPROBE_DEFER 支持延迟探测</li>
<li>[ ] 避免在 initcall 中进行长时间阻塞操作</li>
<li>[ ] 使用 async_schedule 进行异步初始化</li>
<li>[ ] 添加适当的错误处理和回滚机制</li>
</ul>
<h3 id="_9">调试和诊断</h3>
<ul>
<li>[ ] 启用 initcall_debug 跟踪启动过程</li>
<li>[ ] 使用 ftrace 的 function_graph 跟踪器</li>
<li>[ ] 配置 early_printk 用于早期调试</li>
<li>[ ] 保存启动日志用于后续分析</li>
<li>[ ] 使用 systemd-analyze 分析用户空间启动</li>
</ul>
<h3 id="_10">安全考虑</h3>
<ul>
<li>[ ] 验证引导器和内核签名（Secure Boot）</li>
<li>[ ] 保护内核命令行参数（避免注入）</li>
<li>[ ] 限制 initramfs 的权限和内容</li>
<li>[ ] 启用 KASLR（内核地址空间随机化）</li>
<li>[ ] 审计 init 脚本避免安全漏洞</li>
</ul>
<h3 id="_11">可靠性保证</h3>
<ul>
<li>[ ] 实现 watchdog 监控启动过程</li>
<li>[ ] 提供失败后的恢复机制（rescue shell）</li>
<li>[ ] 记录关键启动阶段的检查点</li>
<li>[ ] 实现启动失败的自动回滚</li>
<li>[ ] 测试各种启动失败场景</li>
</ul>
<h3 id="_12">文档和维护</h3>
<ul>
<li>[ ] 记录自定义的内核参数</li>
<li>[ ] 维护 initcall 依赖关系文档</li>
<li>[ ] 记录启动时间基准和优化历史</li>
<li>[ ] 提供启动问题的故障排除指南</li>
<li>[ ] 定期更新和测试恢复流程</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter15.html" class="nav-link prev">← 第15章：性能分析与调试</a><a href="CLAUDE.html" class="nav-link next">Untitled →</a></nav>
        </main>
    </div>
</body>
</html>