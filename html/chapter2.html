<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第2章：进程管理与任务调度</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Linux 内核源代码深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：Linux 内核概述与发展史</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：进程管理与任务调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：内存管理架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：进程间通信机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：虚拟文件系统（VFS）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：具体文件系统实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：块设备层与I/O调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：设备驱动模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：网络协议栈</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：内核同步机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：并发编程模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：容器与命名空间</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：安全子系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：实时Linux</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：性能分析与调试</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：引导过程与初始化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="2">第2章：进程管理与任务调度</h1>
<p>进程管理是操作系统的核心功能之一，Linux内核通过精妙的数据结构和算法实现了高效的进程创建、调度和管理。本章深入剖析Linux进程管理机制的演化历程，从早期简单的task_struct到现代复杂的调度器实现。我们将探讨进程描述符的设计哲学、进程创建的写时复制优化、调度算法从O(1)到CFS再到EEVDF的革命性进展，以及上下文切换的底层实现。通过本章学习，读者将掌握Linux如何在数千个进程间实现公平高效的CPU时间分配，理解内核如何在微秒级别完成进程切换，以及现代调度器如何适应多核、NUMA和异构计算环境。</p>
<h2 id="21-task_struct">2.1 task_struct 结构体演进</h2>
<h3 id="211-linux-011">2.1.1 从Linux 0.11到现代版本</h3>
<p>在Linux 0.11中，进程描述符是一个仅包含几十个字段的简单结构体，主要包含进程状态、寄存器保存区、信号处理和文件描述符表。这个早期版本的设计反映了当时Unix的简洁哲学——每个进程仅需要最基本的控制信息。然而，随着Linux从一个业余项目发展成企业级操作系统，task_struct经历了翻天覆地的变化。每一次Linux的重大特性引入——SMP支持、NUMA架构、容器技术、安全框架——都在task_struct中留下了印记。</p>
<p>这种演进并非简单的字段堆砌。内核开发者们在每个版本中都要平衡功能性与性能的矛盾。例如，2.6版本引入的线程支持要求task_struct能够高效地表示线程与进程的关系，这导致了轻量级进程（LWP）概念的引入。而容器技术的兴起又要求task_struct支持多层次的资源隔离和命名空间管理。现代的task_struct已经成为一个精心设计的数据结构，它不仅要容纳进程的所有状态信息，还要考虑缓存局部性、内存占用和访问性能。</p>
<div class="codehilite"><pre><span></span><code>Linux 0.11 task_struct (约100行)
    |
    v
Linux 2.4 task_struct (约300行) - 引入SMP支持
    |
    v  
Linux 2.6 task_struct (约500行) - 添加线程支持、调度域
    |
    v
Linux 6.x task_struct (约700行) - 容器、cgroup、安全增强
</code></pre></div>

<p>从内存占用角度看，早期的task_struct仅占用几KB内存，而现代版本在x86_64架构上通常占用3-4KB。这种增长并非线性的——内核开发者通过将某些字段移到动态分配的结构中（如mm_struct、files_struct）来控制核心结构的大小。这种设计体现了"为常见情况优化，为特殊情况提供扩展"的原则。</p>
<h3 id="212">2.1.2 核心字段分析</h3>
<p>现代task_struct的设计体现了Linux内核的模块化思想。每个子系统都在task_struct中维护自己的状态信息，但通过指针间接引用来避免结构体过度膨胀。这种设计允许不同子系统独立演进，同时保持了良好的缓存局部性——频繁访问的字段被精心安排在相邻的内存位置。</p>
<p><strong>进程标识与关系</strong></p>
<p>进程标识系统经历了从简单整数到复杂命名空间的演变。早期Linux使用简单的pid计数器，而现代版本支持PID命名空间的层级结构，使得容器内的进程可以拥有独立的PID空间：</p>
<ul>
<li><code>pid_t pid</code>: 进程ID，在其命名空间内唯一。内核维护了一个全局的PID分配器，使用IDR（整数ID管理）机制确保快速分配和查找</li>
<li><code>pid_t tgid</code>: 线程组ID，实现了POSIX线程语义。当创建线程时，所有线程共享同一个tgid，这就是用户空间看到的"进程ID"</li>
<li><code>struct task_struct *parent</code>: 父进程指针，形成进程树结构。当父进程退出时，子进程会被init进程（或subreaper）收养</li>
<li><code>struct list_head children</code>: 子进程链表头，使用内核标准的双向链表实现，支持O(1)的插入和删除</li>
<li><code>struct list_head sibling</code>: 兄弟进程链表节点，连接同一父进程的所有子进程</li>
</ul>
<p>这种关系网络不仅用于进程管理，还支撑着信号传递、资源继承和会话管理等机制。例如，当发送信号给进程组时，内核需要遍历这些关系链表来找到所有目标进程。</p>
<p><strong>调度相关字段</strong></p>
<p>调度字段的设计反映了Linux调度器的演进历史。从最初的简单优先级到现在的多调度类架构，每个阶段的创新都在这里留下痕迹：</p>
<ul>
<li><code>int prio</code>: 动态优先级（0-139），这是调度器实际使用的优先级。0-99为实时优先级，100-139为普通优先级。动态优先级会根据进程行为（如交互性）进行调整</li>
<li><code>int static_prio</code>: 静态优先级，由nice值（-20到19）映射而来，使用公式：static_prio = 120 + nice。这个值在进程生命周期内保持不变，除非显式修改nice值</li>
<li><code>struct sched_entity se</code>: CFS调度实体，包含虚拟运行时间、负载权重等信息。这是一个嵌入结构而非指针，确保访问时的缓存友好性</li>
<li><code>struct sched_rt_entity rt</code>: 实时调度实体，维护实时进程的运行时配额和周期信息。支持带宽控制，防止实时进程完全占用CPU</li>
<li><code>unsigned int policy</code>: 调度策略位掩码，支持六种策略的灵活组合。SCHED_NORMAL用于普通交互进程，SCHED_BATCH用于批处理，SCHED_IDLE用于极低优先级任务</li>
</ul>
<p><strong>内存管理</strong></p>
<p>内存管理字段展现了Linux虚拟内存系统的复杂性。进程的内存视图通过mm_struct描述，而内核线程则有特殊的处理方式：</p>
<ul>
<li><code>struct mm_struct *mm</code>: 内存描述符指针，指向描述整个进程地址空间的结构。包含了页表、VMA（虚拟内存区域）链表、内存统计等关键信息。内核线程的mm为NULL</li>
<li><code>struct mm_struct *active_mm</code>: 活动内存描述符，这是一个优化技巧。内核线程没有自己的地址空间，但需要一个有效的页表来访问内核空间。它们"借用"前一个用户进程的mm，避免了不必要的TLB刷新</li>
<li><code>unsigned long total_vm</code>: 进程虚拟内存总量，以页为单位。包括代码段、数据段、堆、栈、共享库等所有映射区域</li>
<li><code>unsigned long hiwater_rss</code>: RSS（Resident Set Size）高水位标记，记录进程使用物理内存的历史最大值。用于资源审计和OOM决策</li>
</ul>
<p><strong>文件系统</strong></p>
<p>文件系统相关字段体现了"一切皆文件"的Unix哲学：</p>
<ul>
<li><code>struct fs_struct *fs</code>: 包含进程的文件系统上下文——根目录、当前工作目录和umask。通过引用计数共享，fork时可以选择共享或复制</li>
<li><code>struct files_struct *files</code>: 打开文件描述符表，这是一个可扩展的结构。前64个文件描述符使用固定数组（快速路径），超过后使用动态分配的位图和数组</li>
<li><code>struct nsproxy *nsproxy</code>: 命名空间代理，指向进程的各种命名空间（mount、PID、network、IPC、UTS、user、cgroup、time）。这是容器技术的基础</li>
</ul>
<h3 id="213">2.1.3 内存布局优化</h3>
<p>Linux内核对task_struct的内存布局进行了精心优化，这种优化不仅关乎内存使用效率，更重要的是缓存性能。在现代处理器上，缓存未命中的代价可能高达数百个CPU周期，因此合理的内存布局可以带来显著的性能提升。</p>
<p><strong>缓存行对齐策略</strong></p>
<p>内核开发者通过性能分析工具（如perf）识别出task_struct中的热点字段，并将它们聚集在一起。这种布局确保在进程调度、信号处理等关键路径上，所需的数据能够在尽可能少的缓存行中找到：</p>
<ol>
<li><strong>缓存行对齐</strong>: 频繁访问的字段放在同一缓存行（通常64字节）。例如，进程状态、调度信息和运行时统计被安排在相邻位置，一次缓存行填充就能获取多个相关字段</li>
<li><strong>thread_info分离</strong>: 早期版本将thread_info嵌入内核栈底部，通过栈指针掩码快速获取。现代版本将其分离，避免栈溢出破坏关键控制信息</li>
<li><strong>slab分配器优化</strong>: task_struct使用专门的slab缓存（task_struct_cachep），预分配对象池减少内存分配开销，同时保证对齐和局部性</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="w">     </span><span class="err">高地址</span>
<span class="w">    </span><span class="err">┌─────────────┐</span>
<span class="w">    </span><span class="err">│</span><span class="w">   </span><span class="err">内核栈</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="mh">8</span><span class="n">KB</span><span class="p">(</span><span class="mh">32</span><span class="err">位</span><span class="p">)</span><span class="o">/</span><span class="mh">16</span><span class="n">KB</span><span class="p">(</span><span class="mh">64</span><span class="err">位</span><span class="p">)</span>
<span class="w">    </span><span class="err">├─────────────┤</span>
<span class="w">    </span><span class="err">│</span><span class="w">   </span><span class="err">红区保护</span><span class="w">   </span><span class="err">│</span><span class="w"> </span><span class="err">防止栈溢出</span>
<span class="w">    </span><span class="err">├─────────────┤</span>
<span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">thread_info</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="n">x86已移至per</span><span class="o">-</span><span class="n">CPU变量</span>
<span class="w">    </span><span class="err">├─────────────┤</span>
<span class="w">    </span><span class="err">│</span><span class="w">  </span><span class="n">pt_regs</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="err">系统调用</span><span class="o">/</span><span class="err">中断时保存</span>
<span class="w">    </span><span class="err">└─────────────┘</span>
<span class="w">     </span><span class="err">低地址</span>

<span class="err">现代</span><span class="nl">task_struct访问机制:</span>
<span class="p">#</span><span class="n">define</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">get_current</span><span class="p">()</span>

<span class="c1">// x86_64实现 - 使用per-CPU变量</span>
<span class="n">static</span><span class="w"> </span><span class="n">inline</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">get_current</span><span class="p">(</span><span class="k">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this_cpu_read_stable</span><span class="p">(</span><span class="n">current_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ARM64实现 - 使用专用寄存器</span>
<span class="n">static</span><span class="w"> </span><span class="n">inline</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">get_current</span><span class="p">(</span><span class="k">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">task_struct</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">read_sysreg</span><span class="p">(</span><span class="n">sp_el0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>内存占用优化技巧</strong></p>
<p>为了控制task_struct的大小，内核采用了多种优化技术：</p>
<ul>
<li><strong>指针间接</strong>: 大型子结构（如mm_struct、files_struct）通过指针引用，只有在需要时才分配</li>
<li><strong>联合体复用</strong>: 互斥的字段使用union共享内存，如退出码和运行时信息</li>
<li><strong>位域压缩</strong>: 布尔标志和小范围枚举使用位域，多个标志压缩到一个字节</li>
<li><strong>动态数组</strong>: 可变长度的数据（如审计上下文）使用灵活数组成员或单独分配</li>
</ul>
<h3 id="214-pid">2.1.4 PID管理机制</h3>
<p>Linux的PID管理系统是一个精妙的多层架构，它不仅要支持传统的进程ID分配，还要满足现代容器技术的命名空间隔离需求。这个系统的演进反映了Linux从单一系统到容器化平台的转变。</p>
<p><strong>PID命名空间的层级结构</strong></p>
<p>PID命名空间允许不同的进程组看到不同的PID视图。这对容器技术至关重要——容器内的进程可以认为自己是PID 1，而在宿主机上它可能是PID 12345。这种虚拟化通过struct pid的层级设计实现：</p>
<div class="codehilite"><pre><span></span><code><span class="n">struct</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">refcount_t</span><span class="w"> </span><span class="nf">count</span><span class="p">;</span><span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">引用计数</span><span class="err">，</span><span class="n">防止过早释放</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="k">level</span><span class="p">;</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="n">命名空间嵌套深度</span><span class="err">（</span><span class="mi">0</span><span class="n">为根</span><span class="err">）</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w">         </span><span class="o">//</span><span class="w"> </span><span class="n">保护tasks链表的自旋锁</span>
<span class="w">    </span><span class="cm">/* 按类型组织的任务链表：</span>

<span class="cm">     * PIDTYPE_PID - 单个任务</span>
<span class="cm">     * PIDTYPE_TGID - 线程组领导</span>
<span class="cm">     * PIDTYPE_PGID - 进程组</span>
<span class="cm">     * PIDTYPE_SID - 会话</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">hlist_head</span><span class="w"> </span><span class="n">tasks</span><span class="o">[</span><span class="n">PIDTYPE_MAX</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">upid</span><span class="w"> </span><span class="n">numbers</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">灵活数组</span><span class="err">，</span><span class="n">每层一个upid</span>
<span class="err">}</span><span class="p">;</span>

<span class="n">struct</span><span class="w"> </span><span class="n">upid</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">nr</span><span class="p">;</span><span class="w">                   </span><span class="o">//</span><span class="w"> </span><span class="n">该层命名空间中的PID值</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">pid_namespace</span><span class="w"> </span><span class="o">*</span><span class="n">ns</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">指向所属命名空间</span>
<span class="err">}</span><span class="p">;</span>
</code></pre></div>

<p><strong>PID分配算法的演进</strong></p>
<p>早期Linux使用简单的递增计数器分配PID，当达到上限时回绕。这种方法简单但存在问题：PID重用过快可能导致安全问题（如信号误发）。现代内核采用更复杂的策略：</p>
<p>PID分配采用位图+IDR(基数树)的混合机制：</p>
<ul>
<li><strong>位图加速</strong>: 每个命名空间维护一个位图，标记已使用的PID。使用find_next_zero_bit()硬件指令加速查找空闲PID</li>
<li><strong>IDR映射</strong>: 整数ID到指针的映射，支持O(log n)的查找。通过基数树实现，内存效率高，支持稀疏ID分配</li>
<li><strong>PID范围</strong>: 默认32768（可通过/proc/sys/kernel/pid_max调整到2^22），保留低PID给系统进程</li>
<li><strong>分配策略</strong>: 优先分配最近释放的PID（热缓存），但会延迟重用（避免混淆）</li>
</ul>
<p><strong>PID哈希表与快速查找</strong></p>
<p>为了支持通过PID快速找到task_struct，内核维护了多个哈希表：</p>
<div class="codehilite"><pre><span></span><code><span class="err">全局</span><span class="n">PID哈希表组织</span><span class="o">:</span>
<span class="n">pid_hash</span><span class="o">[</span><span class="n">hash</span><span class="o">(</span><span class="n">pid</span><span class="o">)]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">task_struct</span>

<span class="err">命名空间内查找</span><span class="o">:</span>
<span class="n">pid_namespace</span><span class="o">::</span><span class="n">idr</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">特定层级的</span><span class="n">upid</span>

<span class="err">进程组</span><span class="o">/</span><span class="err">会话查找</span><span class="o">:</span>
<span class="err">通过</span><span class="n">PIDTYPE_PGID</span><span class="o">/</span><span class="n">PIDTYPE_SID链表遍历</span>
</code></pre></div>

<p>这种多级索引结构确保了各种PID相关操作的高效性：</p>
<ul>
<li>kill()系统调用通过PID找进程：O(1)哈希查找</li>
<li>获取进程组所有成员：O(n)链表遍历</li>
<li>容器内PID转换：O(1)数组索引</li>
</ul>
<h2 id="22-forkvforkclone">2.2 进程创建：fork/vfork/clone 实现</h2>
<p>进程创建是操作系统最基础也是最复杂的操作之一。Linux通过三个系统调用提供了不同层次的进程创建能力，每个都针对特定场景进行了优化。这种设计体现了Linux的实用主义哲学——不追求理论上的完美，而是为实际使用场景提供最优解。</p>
<h3 id="221-fork">2.2.1 fork的写时复制机制</h3>
<p>fork()系统调用是Unix进程创建的经典接口，其语义简洁优雅：创建一个与父进程几乎完全相同的子进程。然而，这种简洁的背后隐藏着巨大的性能挑战——如果真的复制父进程的所有内存，一个占用数GB内存的进程fork将造成灾难性的延迟。Linux通过写时复制(Copy-On-Write, COW)技术巧妙地解决了这个问题。</p>
<p><strong>fork的内核实现路径</strong></p>
<p>现代Linux中，fork()实际上是kernel_clone()的一个简单包装。这种统一的实现减少了代码重复，提高了可维护性：</p>
<div class="codehilite"><pre><span></span><code>fork()系统调用的完整流程:

1. sys_fork() → kernel_clone(SIGCHLD, 0, 0, NULL, NULL, 0)
2. 分配新的task_struct:
   <span class="k">-</span> dup_task_struct(): 复制当前进程的task_struct
   <span class="k">-</span> 分配新的内核栈（通过alloc_thread_stack_node）
   <span class="k">-</span> 复制thread_info和寄存器状态

3. 初始化子进程特有字段:
   <span class="k">-</span> 分配新的PID（alloc_pid）
   <span class="k">-</span> 设置进程关系（父子、兄弟链表）
   <span class="k">-</span> 清零统计信息（CPU时间、缺页次数等）

4. 复制进程资源（按需共享或复制）:
   <span class="k">-</span> copy_mm(): 复制内存管理结构，设置COW
   <span class="k">-</span> copy_files(): 复制或共享文件描述符表
   <span class="k">-</span> copy_sighand(): 复制信号处理器
   <span class="k">-</span> copy_thread(): 设置子进程返回值为0
   <span class="k">-</span> copy_namespaces(): 复制或共享命名空间

5. 调度器处理:
   <span class="k">-</span> 设置子进程状态为TASK_RUNNING
   <span class="k">-</span> 将子进程加入就绪队列（wake_up_new_task）
   <span class="k">-</span> 可能触发负载均衡
</code></pre></div>

<p><strong>COW机制的精妙实现</strong></p>
<p>COW的核心思想是"延迟复制直到真正需要"。当fork时，父子进程共享相同的物理页面，只有当某一方试图修改页面时才进行实际的复制：</p>
<div class="codehilite"><pre><span></span><code><span class="n">COW的页表操作细节</span><span class="o">:</span>

<span class="err">初始状态（</span><span class="n">fork前</span><span class="err">）</span><span class="o">:</span>
<span class="err">父进程</span><span class="n">PTE</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="n">PRESENT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USER</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">物理页</span><span class="n">A</span>

<span class="n">fork后</span><span class="err">（共享阶段）</span><span class="o">:</span>
<span class="err">父进程</span><span class="n">PTE</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="n">PRESENT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RO</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USER</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">COW</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">物理页</span><span class="n">A</span>
<span class="err">子进程</span><span class="n">PTE</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="n">PRESENT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RO</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">USER</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">COW</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">物理页</span><span class="n">A</span>
<span class="err">物理页</span><span class="n">A引用计数</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span>

<span class="err">写操作触发（缺页异常处理）</span><span class="o">:</span>

<span class="mi">1</span><span class="o">.</span><span class="w"> </span><span class="n">CPU尝试写入</span><span class="err">，发现页面只读，触发缺页异常</span>
<span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="n">do_wp_page</span><span class="o">()</span><span class="err">处理写保护异常</span><span class="o">:</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="err">页面引用计数</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">       </span><span class="c1">// 最后一个引用，直接恢复写权限</span>
<span class="w">       </span><span class="err">设置</span><span class="n">PTE为RW</span>
<span class="w">   </span><span class="o">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="o">{</span>
<span class="w">       </span><span class="c1">// 多个引用，需要复制</span>
<span class="w">       </span><span class="err">分配新物理页</span><span class="n">B</span>
<span class="w">       </span><span class="err">复制</span><span class="n">A的内容到B</span>
<span class="w">       </span><span class="err">更新</span><span class="n">PTE指向B</span><span class="err">，设置</span><span class="n">RW</span>
<span class="w">       </span><span class="err">减少</span><span class="n">A的引用计数</span>
<span class="w">   </span><span class="o">}</span>

<span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="err">刷新</span><span class="n">TLB项</span>
<span class="mi">4</span><span class="o">.</span><span class="w"> </span><span class="err">返回用户空间，重试写操作</span>
</code></pre></div>

<p>COW带来的性能提升是惊人的。实验数据显示：</p>
<ul>
<li>fork后立即exec的场景（如shell执行命令）：节省99%以上的内存复制</li>
<li>fork后父子进程分别运行：平均只有10-20%的页面被复制</li>
<li>大内存进程（如数据库）fork：延迟从秒级降至毫秒级</li>
</ul>
<p><strong>COW的边界情况处理</strong></p>
<p>COW虽然强大，但也带来了复杂性。内核必须处理各种边界情况：</p>
<ol>
<li><strong>巨页（Huge Pages）的COW</strong>: 2MB/1GB的巨页复制开销大，内核可能选择分裂成普通页</li>
<li><strong>KSM（内核同页合并）冲突</strong>: KSM可能将相同内容的页面合并，需要特殊的COW处理</li>
<li><strong>透明大页（THP）</strong>: 动态的大页管理增加了COW的复杂度</li>
<li><strong>NUMA系统的页面迁移</strong>: COW页面可能需要迁移到本地节点</li>
</ol>
<h3 id="222-vfork">2.2.2 vfork的栈共享优化</h3>
<p>vfork()是Unix历史上一个有趣的优化尝试。在COW技术成熟之前，fork的开销确实很大，因此BSD Unix引入了vfork作为一种"危险但高效"的替代方案。即使在COW普及后，vfork仍然因其极致的性能优势在某些场景下被保留——它完全避免了页表复制和TLB刷新的开销。</p>
<p><strong>vfork的语义保证与实现</strong></p>
<p>vfork()的核心设计理念是"借用而非复制"。子进程暂时借用父进程的一切资源，包括最危险的栈空间：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// vfork的三个关键语义:</span>

<span class="mf">1.</span><span class="w"> </span><span class="n">父子进程共享完整的地址空间</span><span class="p">(</span><span class="n">包括栈</span><span class="err">、</span><span class="n">堆</span><span class="err">、</span><span class="n">数据段</span><span class="p">)</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">父进程阻塞直到子进程调用exec或_exit</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">子进程在共享期间的行为受到严格限制</span>

<span class="nl">内核实现的关键点</span><span class="p">:</span>
<span class="n">kernel_clone</span><span class="p">(</span><span class="n">CLONE_VFORK</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CLONE_VM</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SIGCHLD</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>

<span class="o">-</span><span class="w"> </span><span class="n">CLONE_VFORK</span><span class="o">:</span><span class="w"> </span><span class="n">设置完成等待机制</span><span class="p">(</span><span class="n">vfork_done</span><span class="p">)</span>
<span class="o">-</span><span class="w"> </span><span class="n">CLONE_VM</span><span class="o">:</span><span class="w"> </span><span class="n">共享mm_struct</span><span class="err">，</span><span class="n">不复制页表</span>
<span class="o">-</span><span class="w"> </span><span class="n">父进程通过wait_for_vfork_done</span><span class="p">()</span><span class="n">睡眠</span>
</code></pre></div>

<p><strong>vfork的性能优势分析</strong></p>
<p>vfork相比fork的性能提升主要来自三个方面：</p>
<ol>
<li><strong>无页表复制</strong>: fork需要复制整个页表层级（4级页表），大进程可能需要复制数MB的页表</li>
<li><strong>无TLB刷新</strong>: 不切换地址空间，避免了昂贵的TLB刷新操作</li>
<li><strong>无COW设置</strong>: 不需要遍历页表设置写保护，节省了页表遍历时间</li>
</ol>
<p>实测数据（在一个1GB内存映射的进程上）：</p>
<ul>
<li>fork: 2-3ms（主要是页表复制）</li>
<li>vfork: 20-30μs（仅创建task_struct）</li>
<li>性能提升: 100倍</li>
</ul>
<p><strong>vfork的危险性与陷阱</strong></p>
<p>vfork的共享语义使其成为Linux中最容易误用的系统调用之一：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 危险示例1 - 破坏父进程栈帧</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">parent_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vfork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w">  </span><span class="c1">// 直接修改父进程的变量！</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">          </span><span class="c1">// 错误：破坏父进程的栈帧</span>
<span class="w">        </span><span class="c1">// 正确做法：_exit(0) 或 exec*()</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">parent_var</span><span class="p">);</span><span class="w">  </span><span class="c1">// 输出200，栈已被破坏</span>
<span class="p">}</span>

<span class="c1">// 危险示例2 - 栈指针混乱</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">dangerous</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vfork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 子进程的栈帧覆盖了父进程的栈空间</span>
<span class="w">        </span><span class="n">recursive_function</span><span class="p">();</span><span class="w">  </span><span class="c1">// 可能破坏父进程的返回地址</span>
<span class="w">        </span><span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 危险示例3 - 信号处理竞争</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vfork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">);</span><span class="w">  </span><span class="c1">// 修改了父进程的信号处理器！</span>
<span class="w">    </span><span class="n">exec</span><span class="o">*</span><span class="p">(...);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>vfork的现代使用指南</strong></p>
<p>尽管危险，vfork在某些场景下仍然有价值：</p>
<ol>
<li><strong>嵌入式系统</strong>: 内存受限，避免页表复制很重要</li>
<li><strong>大内存进程的exec</strong>: 数据库启动脚本等场景</li>
<li><strong>高频进程创建</strong>: 某些系统守护进程</li>
</ol>
<p>安全使用vfork的黄金法则：</p>
<ul>
<li>子进程中只调用_exit()或exec*()</li>
<li>不使用任何库函数（可能修改全局状态）</li>
<li>不修改任何变量（除了vfork的返回值）</li>
<li>优先考虑使用posix_spawn()（内部可能用vfork）</li>
</ul>
<h3 id="223-clone">2.2.3 clone的灵活控制</h3>
<p>clone()提供了最灵活的进程/线程创建接口：</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="nl">关键标志位</span><span class="p">:</span>
<span class="n">CLONE_VM</span><span class="w">       </span><span class="n">共享地址空间</span><span class="p">(</span><span class="n">线程</span><span class="p">)</span>
<span class="n">CLONE_FILES</span><span class="w">    </span><span class="n">共享文件描述符表</span>
<span class="n">CLONE_SIGHAND</span><span class="w">  </span><span class="n">共享信号处理器</span>
<span class="n">CLONE_THREAD</span><span class="w">   </span><span class="n">同一线程组</span>
<span class="n">CLONE_NEWNS</span><span class="w">    </span><span class="n">新mount命名空间</span>
<span class="n">CLONE_NEWPID</span><span class="w">   </span><span class="n">新PID命名空间</span>
<span class="n">CLONE_NEWNET</span><span class="w">   </span><span class="n">新网络命名空间</span>
</code></pre></div>

<p>pthread_create的实现就是基于clone：</p>
<div class="codehilite"><pre><span></span><code><span class="n">clone</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span><span class="w"> </span><span class="n">stack_top</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="n">CLONE_VM</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CLONE_FILES</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CLONE_SIGHAND</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">      </span><span class="n">CLONE_THREAD</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CLONE_SETTLS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CLONE_PARENT_SETTID</span><span class="w"> </span><span class="o">|</span>
<span class="w">      </span><span class="n">CLONE_CHILD_CLEARTID</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
</code></pre></div>

<h3 id="224">2.2.4 创建开销对比</h3>
<p>不同创建方式的性能特征：</p>
<p>| 方法 | 时间(μs) | 内存开销 | 适用场景 |</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间(μs)</th>
<th>内存开销</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork()</td>
<td>100-200</td>
<td>COW延迟复制</td>
<td>独立进程</td>
</tr>
<tr>
<td>vfork()</td>
<td>20-30</td>
<td>无额外开销</td>
<td>fork+exec</td>
</tr>
<tr>
<td>clone(线程)</td>
<td>30-50</td>
<td>共享大部分</td>
<td>多线程</td>
</tr>
<tr>
<td>clone(容器)</td>
<td>150-300</td>
<td>命名空间开销</td>
<td>容器隔离</td>
</tr>
</tbody>
</table>
<h2 id="23-o1-cfs-eevdf">2.3 调度器发展：O(1) → CFS → EEVDF</h2>
<h3 id="231-o1">2.3.1 O(1)调度器的位图技巧</h3>
<p>Ingo Molnar在2.6早期引入的O(1)调度器，通过位图实现了常数时间复杂度：</p>
<div class="codehilite"><pre><span></span><code><span class="nl">运行队列结构</span><span class="p">:</span>
<span class="n">struct</span><span class="w"> </span><span class="n">runqueue</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">nr_running</span><span class="p">;</span>

<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">prio_array</span><span class="w"> </span><span class="o">*</span><span class="n">active</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">活动优先级数组</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">prio_array</span><span class="w"> </span><span class="o">*</span><span class="n">expired</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">过期优先级数组</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">prio_array</span><span class="w"> </span><span class="n">arrays</span><span class="o">[</span><span class="n">2</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">实际数组存储</span>
<span class="err">}</span><span class="p">;</span>

<span class="n">struct</span><span class="w"> </span><span class="n">prio_array</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">nr_active</span><span class="p">;</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">bitmap</span><span class="o">[</span><span class="n">BITMAP_SIZE</span><span class="o">]</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="mi">140</span><span class="n">个优先级的位图</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">list_head</span><span class="w"> </span><span class="n">queue</span><span class="o">[</span><span class="n">MAX_PRIO</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">每个优先级的任务队列</span>
<span class="err">}</span><span class="p">;</span>
</code></pre></div>

<p><strong>O(1)的核心算法</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nl">选择下一个任务</span><span class="p">:</span>

<span class="mf">1.</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_first_bit</span><span class="p">(</span><span class="k">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">)</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">硬件指令</span><span class="err">，</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="mf">2.</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">array</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span><span class="p">)</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">时间片用完后移到expired数组</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">active数组空时</span><span class="err">，</span><span class="n">交换active和expired指针</span>
</code></pre></div>

<p>O(1)调度器的问题：</p>
<ul>
<li>交互性判断不准确</li>
<li>优先级计算复杂</li>
<li>公平性不足</li>
</ul>
<h3 id="232-cfs">2.3.2 CFS的红黑树实现</h3>
<p>完全公平调度器(CFS)由Ingo Molnar在2.6.23引入，基于"理想多任务处理器"模型：</p>
<div class="codehilite"><pre><span></span><code><span class="err">核心思想</span><span class="p">:</span><span class="w"> </span><span class="err">虚拟运行时间</span><span class="p">(</span><span class="n">vruntime</span><span class="p">)</span>
<span class="n">vruntime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">实际运行时间</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">NICE_0_LOAD</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="err">进程权重</span><span class="p">)</span>

<span class="n">struct</span><span class="w"> </span><span class="n">sched_entity</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">vruntime</span><span class="p">;</span><span class="w">           </span><span class="o">//</span><span class="w"> </span><span class="err">虚拟运行时间</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">sum_exec_runtime</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="err">实际运行时间累计</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">rb_node</span><span class="w"> </span><span class="n">run_node</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">红黑树节点</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">on_rq</span><span class="p">;</span><span class="w">     </span><span class="o">//</span><span class="w"> </span><span class="err">是否在运行队列</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="err">负载权重</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">load_weight</span><span class="w"> </span><span class="nb">load</span><span class="p">;</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">load_weight</span><span class="w"> </span><span class="n">avg_load</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>CFS运行队列</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="n">struct</span><span class="w"> </span><span class="n">cfs_rq</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">rb_root_cached</span><span class="w"> </span><span class="n">tasks_timeline</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="err">红黑树根</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">;</span><span class="w">             </span><span class="o">//</span><span class="w"> </span><span class="err">当前运行</span>
<span class="w">    </span><span class="n">struct</span><span class="w"> </span><span class="n">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">             </span><span class="o">//</span><span class="w"> </span><span class="err">下一个运行</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">min_vruntime</span><span class="p">;</span><span class="w">                      </span><span class="o">//</span><span class="w"> </span><span class="err">最小</span><span class="n">vruntime基准</span>

<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">nr_running</span><span class="p">;</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="nb">load</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>CFS核心操作</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="err">入队</span><span class="p">:</span><span class="w"> </span><span class="err">按</span><span class="n">vruntime插入红黑树</span><span class="w"> </span><span class="n">O</span><span class="p">(</span><span class="nb">log</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="mf">2.</span><span class="w"> </span><span class="err">选择</span><span class="p">:</span><span class="w"> </span><span class="err">最左节点</span><span class="p">(</span><span class="err">最小</span><span class="n">vruntime</span><span class="p">)</span><span class="w"> </span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="err">缓存</span><span class="p">]</span>
<span class="mf">3.</span><span class="w"> </span><span class="err">时间片</span><span class="p">:</span><span class="w"> </span>
<span class="w">   </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sched_period</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">se</span><span class="o">.</span><span class="n">load</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cfs_rq</span><span class="o">.</span><span class="n">load</span>
<span class="w">   </span><span class="err">默认</span><span class="n">sched_period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="n">ms</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nr_running</span><span class="w"> </span><span class="p">(</span><span class="err">最大</span><span class="mi">48</span><span class="n">ms</span><span class="p">)</span>

<span class="mf">4.</span><span class="w"> </span><span class="err">抢占检查</span><span class="p">:</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">vruntime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">leftmost</span><span class="o">.</span><span class="n">vruntime</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sched_granularity</span><span class="p">)</span>
<span class="w">       </span><span class="err">触发抢占</span>
</code></pre></div>

<h3 id="233-eevdf">2.3.3 EEVDF的延迟保证</h3>
<p>EEVDF(Earliest Eligible Virtual Deadline First)在6.6版本引入，增强了延迟保证：</p>
<div class="codehilite"><pre><span></span><code><span class="n">EEVDF核心概念</span><span class="o">:</span>

<span class="mi">1</span><span class="o">.</span><span class="w"> </span><span class="err">虚拟截止时间</span><span class="o">:</span><span class="w"> </span><span class="n">vdeadline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vruntime</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">slice</span>
<span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="err">延迟</span><span class="n">nice</span><span class="o">:</span><span class="w"> </span><span class="err">每个任务可设置延迟敏感度</span>
<span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="err">资格时间</span><span class="o">:</span><span class="w"> </span><span class="n">eligible_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vruntime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">lag</span>

<span class="err">选择算法</span><span class="o">:</span>
<span class="err">在所有</span><span class="n">eligible的任务中</span><span class="err">，选择</span><span class="n">vdeadline最早的</span>
</code></pre></div>

<p>EEVDF相比CFS的改进：</p>
<ul>
<li>更好的延迟保证</li>
<li>避免饥饿</li>
<li>支持延迟敏感度设置</li>
</ul>
<h3 id="234">2.3.4 调度类架构</h3>
<p>Linux支持多种调度类，按优先级排序：</p>
<div class="codehilite"><pre><span></span><code>调度类优先级(高→低):

1. stop_sched_class     停机调度类
2. dl_sched_class       DEADLINE调度类  
3. rt_sched_class       实时调度类(FIFO/RR)
4. fair_sched_class     CFS公平调度类
5. idle_sched_class     空闲调度类

struct sched_class {
    void (*enqueue_task)();   // 入队
    void (*dequeue_task)();   // 出队
    void (*yield_task)();     // 让出CPU
    void (*check_preempt)();  // 抢占检查
    struct task_struct *(*pick_next_task)(); // 选择下一个
    void (*put_prev_task)();  // 放回前一个
    void (*set_next_task)();  // 设置下一个
    void (*task_tick)();      // 时钟中断
    void (*switched_to)();    // 切换到此类
    void (*prio_changed)();   // 优先级改变
};
</code></pre></div>

<h2 id="24">2.4 进程状态机与上下文切换</h2>
<h3 id="241">2.4.1 进程状态转换</h3>
<p>Linux进程的基本状态及转换：</p>
<div class="codehilite"><pre><span></span><code><span class="nl">进程状态定义</span><span class="p">:</span>
<span class="n">#define</span><span class="w"> </span><span class="n">TASK_RUNNING</span><span class="w">         </span><span class="mh">0x00</span>
<span class="n">#define</span><span class="w"> </span><span class="n">TASK_INTERRUPTIBLE</span><span class="w">   </span><span class="mh">0x01</span><span class="w">  </span>
<span class="n">#define</span><span class="w"> </span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="w"> </span><span class="mh">0x02</span>
<span class="n">#define</span><span class="w"> </span><span class="n">__TASK_STOPPED</span><span class="w">       </span><span class="mh">0x04</span>
<span class="n">#define</span><span class="w"> </span><span class="n">__TASK_TRACED</span><span class="w">        </span><span class="mh">0x08</span>
<span class="n">#define</span><span class="w"> </span><span class="n">TASK_IDLE</span><span class="w">            </span><span class="mh">0x80</span>
<span class="n">#define</span><span class="w"> </span><span class="n">TASK_NEW</span><span class="w">             </span><span class="mh">0x800</span>

<span class="nl">状态转换图</span><span class="p">:</span>
<span class="w">           </span><span class="n">fork</span><span class="p">()</span>
<span class="w">    </span><span class="o">[</span><span class="n">NEW</span><span class="o">]</span><span class="w"> </span><span class="o">-------&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">RUNNABLE</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;----</span>
<span class="w">      </span><span class="o">|</span><span class="w">               </span><span class="o">^</span><span class="w">  </span><span class="o">|</span><span class="w">         </span><span class="o">|</span>
<span class="w">      </span><span class="o">|</span><span class="w">            </span><span class="n">调度</span><span class="o">|</span><span class="w">  </span><span class="o">|</span><span class="n">阻塞</span><span class="w">     </span><span class="o">|</span><span class="n">唤醒</span>
<span class="w">      </span><span class="n">v</span><span class="w">               </span><span class="o">|</span><span class="w">  </span><span class="n">v</span><span class="w">         </span><span class="o">|</span>
<span class="w">   </span><span class="o">[</span><span class="n">RUNNING</span><span class="o">]</span><span class="w"> </span><span class="o">-------&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">SLEEP</span><span class="o">]</span><span class="w"> </span><span class="o">-----</span>
<span class="w">             </span><span class="n">时间片用完</span><span class="w">   </span><span class="o">^</span>
<span class="w">                         </span><span class="o">|</span>
<span class="w">                     </span><span class="n">I</span><span class="o">/</span><span class="n">O等待</span><span class="o">/</span><span class="n">锁等待</span>
</code></pre></div>

<p><strong>状态转换的原子性保证</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 设置状态并检查条件的原子操作</span>
<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">schedule</span><span class="p">();</span><span class="w">  </span><span class="c1">// 原子地检查并睡眠</span>
<span class="p">}</span>
<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
</code></pre></div>

<h3 id="242">2.4.2 上下文切换实现</h3>
<p>上下文切换是调度的核心操作，包含两个主要步骤：</p>
<div class="codehilite"><pre><span></span><code><span class="n">context_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="o">:</span>

<span class="mf">1.</span><span class="w"> </span><span class="n">切换地址空间</span><span class="p">(</span><span class="n">如果需要</span><span class="p">)</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
<span class="w">       </span><span class="n">switch_mm</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>

<span class="mf">2.</span><span class="w"> </span><span class="n">切换处理器状态</span>
<span class="w">   </span><span class="n">switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">)</span>
</code></pre></div>

<p><strong>switch_to的汇编实现(x86_64)</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nl">__switch_to:</span>
<span class="w">    </span><span class="c1">// 保存prev的寄存器到栈</span>
<span class="w">    </span><span class="nf">pushq</span><span class="w"> </span><span class="nv">%rbp</span>
<span class="w">    </span><span class="nf">pushq</span><span class="w"> </span><span class="nv">%rbx</span><span class="w">  </span>
<span class="w">    </span><span class="no">pushq</span><span class="w"> </span><span class="nv">%r12-r15</span>

<span class="w">    </span><span class="c1">// 切换栈指针</span>
<span class="w">    </span><span class="nf">movq</span><span class="w"> </span><span class="nv">%rsp</span><span class="p">,</span><span class="w"> </span><span class="no">TASK_threadsp</span><span class="p">(</span><span class="nv">%rdi</span><span class="p">)</span><span class="w">  </span><span class="c1">// 保存prev的rsp</span>
<span class="w">    </span><span class="nf">movq</span><span class="w"> </span><span class="no">TASK_threadsp</span><span class="p">(</span><span class="nv">%rsi</span><span class="p">),</span><span class="w"> </span><span class="nv">%rsp</span><span class="w">  </span><span class="c1">// 加载next的rsp</span>

<span class="w">    </span><span class="c1">// 恢复next的寄存器</span>
<span class="w">    </span><span class="nf">popq</span><span class="w"> </span><span class="nv">%r15-r12</span>
<span class="w">    </span><span class="nf">popq</span><span class="w"> </span><span class="nv">%rbx</span>
<span class="w">    </span><span class="nf">popq</span><span class="w"> </span><span class="nv">%rbp</span>

<span class="w">    </span><span class="c1">// 更新per-CPU的current指针</span>
<span class="w">    </span><span class="nf">movq</span><span class="w"> </span><span class="nv">%rsi</span><span class="p">,</span><span class="w"> </span><span class="no">PER_CPU_current</span>

<span class="w">    </span><span class="nf">retq</span><span class="w">  </span><span class="c1">// 返回到next的执行点</span>
</code></pre></div>

<h3 id="243-tlb">2.4.3 TLB刷新优化</h3>
<p>地址空间切换涉及TLB(Translation Lookaside Buffer)刷新：</p>
<div class="codehilite"><pre><span></span><code><span class="n">TLB刷新策略</span><span class="o">:</span>

<span class="mi">1</span><span class="o">.</span><span class="w"> </span><span class="err">完全刷新</span><span class="o">:</span><span class="w"> </span><span class="n">invlpg</span><span class="o">/</span><span class="n">flush_tlb_all</span><span class="o">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">开销大</span>
<span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="n">ASID</span><span class="o">/</span><span class="n">PCID</span><span class="o">:</span><span class="w"> </span><span class="err">进程地址空间标识符</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">避免刷新</span>
<span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="err">惰性</span><span class="n">TLB</span><span class="o">:</span><span class="w"> </span><span class="err">内核线程借用地址空间</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">延迟刷新</span>

<span class="err">惰性</span><span class="n">TLB模式</span><span class="o">:</span>
<span class="k">if</span><span class="w"> </span><span class="o">(!</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w">  </span><span class="c1">// 内核线程</span>
<span class="w">    </span><span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="o">;</span>
<span class="w">    </span><span class="err">原子增加引用计数</span>
<span class="w">    </span><span class="err">进入</span><span class="n">lazy</span><span class="w"> </span><span class="n">TLB模式</span>
<span class="o">}</span>
</code></pre></div>

<h3 id="244">2.4.4 性能优化技术</h3>
<ol>
<li><strong>per-CPU运行队列</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nt">每个CPU维护独立的运行队列</span><span class="err">，</span><span class="nt">减少锁竞争</span><span class="o">:</span>
<span class="nt">DEFINE_PER_CPU</span><span class="o">(</span><span class="nt">struct</span><span class="w"> </span><span class="nt">rq</span><span class="o">,</span><span class="w"> </span><span class="nt">runqueues</span><span class="o">);</span>

<span class="nt">负载均衡</span><span class="o">:</span>

<span class="nt">-</span><span class="w"> </span><span class="nt">定期均衡</span><span class="o">(</span><span class="nt">tick时</span><span class="o">)</span>
<span class="nt">-</span><span class="w"> </span><span class="nt">空闲均衡</span><span class="o">(</span><span class="nt">CPU空闲时</span><span class="o">)</span><span class="w">  </span>
<span class="nt">-</span><span class="w"> </span><span class="nt">新任务均衡</span><span class="o">(</span><span class="nt">fork时</span><span class="o">)</span>
<span class="nt">-</span><span class="w"> </span><span class="nt">exec均衡</span><span class="o">(</span><span class="nt">exec时</span><span class="o">)</span>
</code></pre></div>

<ol start="2">
<li><strong>调度域与NUMA感知</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nl">调度域层级</span><span class="p">:</span>
<span class="w">    </span><span class="o">[</span><span class="n">NUMA NODE 0</span><span class="o">]</span><span class="w">     </span><span class="o">[</span><span class="n">NUMA NODE 1</span><span class="o">]</span>
<span class="w">         </span><span class="o">|</span><span class="w">                 </span><span class="o">|</span>
<span class="w">    </span><span class="o">[</span><span class="n">PACKAGE 0</span><span class="o">]</span><span class="w">       </span><span class="o">[</span><span class="n">PACKAGE 1</span><span class="o">]</span><span class="w">  </span>
<span class="w">       </span><span class="o">/</span><span class="w">    </span><span class="err">\</span><span class="w">           </span><span class="o">/</span><span class="w">    </span><span class="err">\</span>
<span class="w">   </span><span class="o">[</span><span class="n">CORE0</span><span class="o">][</span><span class="n">CORE1</span><span class="o">]</span><span class="w">  </span><span class="o">[</span><span class="n">CORE2</span><span class="o">][</span><span class="n">CORE3</span><span class="o">]</span>
<span class="w">     </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">    </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">      </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">    </span><span class="o">/</span><span class="w"> </span><span class="err">\</span>
<span class="w">   </span><span class="n">SMT</span><span class="w"> </span><span class="n">SMT</span><span class="w"> </span><span class="n">SMT</span><span class="w"> </span><span class="n">SMT</span><span class="w">  </span><span class="n">SMT</span><span class="w"> </span><span class="n">SMT</span><span class="w"> </span><span class="n">SMT</span><span class="w"> </span><span class="n">SMT</span>
</code></pre></div>

<ol start="3">
<li><strong>快速路径优化</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 快速选择下一个任务</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">           </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 只有CFS任务，直接从红黑树选择</span>
<span class="w">    </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pick_next_task_fair</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="_1">本章小结</h2>
<p>本章深入探讨了Linux进程管理的核心机制。我们从task_struct结构体的演进开始，理解了进程描述符如何从简单的百行结构成长为包含进程所有信息的复杂数据结构。通过分析fork/vfork/clone三种进程创建机制，我们看到了Linux如何通过COW、地址空间共享等技术优化进程创建的性能。调度器的演进历程展示了Linux内核在追求公平性、响应性和吞吐量之间的平衡艺术——从O(1)调度器的位图技巧，到CFS的虚拟运行时间和红黑树，再到EEVDF的延迟保证。最后，我们剖析了上下文切换的底层实现，理解了CPU如何在纳秒级别完成进程切换。</p>
<p><strong>关键概念回顾</strong>：</p>
<ol>
<li><strong>task_struct</strong>: 进程的完整描述，包含身份、资源、状态等所有信息</li>
<li><strong>COW机制</strong>: 延迟内存复制，大幅降低fork开销</li>
<li><strong>虚拟运行时间</strong>: $vruntime = \frac{实际运行时间 \times NICE_0_LOAD}{进程权重}$</li>
<li><strong>红黑树</strong>: 保证O(log n)的入队复杂度和O(1)的最左节点访问</li>
<li><strong>上下文切换</strong>: 地址空间切换(switch_mm) + CPU状态切换(switch_to)</li>
</ol>
<p><strong>性能数据总结</strong>：</p>
<ul>
<li>fork延迟: 100-200μs (COW优化后)</li>
<li>上下文切换: 2-5μs (同地址空间) / 5-10μs (不同地址空间)</li>
<li>调度延迟: &lt;6ms (默认CFS配置)</li>
<li>TLB刷新: PCID可减少90%的刷新开销</li>
</ul>
<h2 id="_2">练习题</h2>
<h3 id="_3">基础题</h3>
<p><strong>习题2.1</strong> task_struct中的引用计数
分析task_struct中的usage字段，解释为什么需要引用计数，以及get_task_struct()和put_task_struct()的作用。</p>
<details>
<summary>答案</summary>
<p>引用计数用于防止task_struct被过早释放。当多个内核路径同时访问同一个task_struct时（如/proc文件系统、信号发送、调度器），需要确保结构体不会在使用过程中被释放。get_task_struct()增加引用计数，put_task_struct()减少引用计数，当计数为0时释放内存。这是内核中典型的引用计数内存管理模式。</p>
</details>
<p><strong>习题2.2</strong> COW的触发时机
列举三种会触发COW（写时复制）的场景，并解释每种场景下的页面复制过程。</p>
<details>
<summary>答案</summary>
<ol>
<li><strong>写私有映射页面</strong>: fork后子进程写父进程的数据段，触发缺页异常，分配新页并复制内容</li>
<li><strong>写共享库的数据段</strong>: 进程修改动态库的全局变量，触发COW创建进程私有副本</li>
<li><strong>写mmap的私有文件映射</strong>: MAP_PRIVATE映射的文件被修改时，创建匿名页面保存修改</li>
</ol>
<p>页面复制过程：缺页异常→检查页表项权限→分配新物理页→复制原页内容→更新页表项→刷新TLB</p>
</details>
<p><strong>习题2.3</strong> CFS的时间片计算
假设系统中有3个普通进程，nice值分别为-5、0、5，计算它们在一个调度周期内各自获得的时间片。（提示：nice值与权重的关系为weight = 1024 * 1.25^(-nice)）</p>
<details>
<summary>答案</summary>
<p>nice值对应的权重：</p>
<ul>
<li>nice -5: weight = 1024 * 1.25^5 ≈ 3121</li>
<li>nice 0: weight = 1024</li>
<li>nice 5: weight = 1024 * 1.25^(-5) ≈ 335</li>
</ul>
<p>总权重 = 3121 + 1024 + 335 = 4480</p>
<p>假设调度周期为18ms（3个任务 * 6ms）：</p>
<ul>
<li>nice -5进程: 18ms * 3121/4480 ≈ 12.5ms</li>
<li>nice 0进程: 18ms * 1024/4480 ≈ 4.1ms  </li>
<li>nice 5进程: 18ms * 335/4480 ≈ 1.4ms</li>
</ul>
</details>
<h3 id="_4">挑战题</h3>
<p><strong>习题2.4</strong> 调度器性能分析
设计一个实验来测量CFS调度器在不同负载下的调度延迟和公平性。需要考虑哪些指标？如何消除测量误差？</p>
<details>
<summary>提示</summary>
<p>考虑以下方面：</p>
<ul>
<li>使用schedstats和/proc/schedstat收集调度统计</li>
<li>测量指标：调度延迟分布、CPU时间分配比例、上下文切换频率</li>
<li>控制变量：CPU亲和性、cgroup隔离、实时优先级进程干扰</li>
<li>使用cyclictest等工具测量延迟</li>
</ul>
</details>
<p><strong>习题2.5</strong> 实现用户态调度器
使用clone()系统调用和共享内存，设计一个简单的用户态M:N线程调度器。需要解决哪些关键问题？</p>
<details>
<summary>提示</summary>
<p>关键问题：</p>
<ol>
<li>用户态上下文切换（setcontext/swapcontext）</li>
<li>内核线程与用户线程的映射管理</li>
<li>阻塞系统调用的处理（异步I/O或线程池）</li>
<li>信号处理的线程安全性</li>
<li>栈管理和栈溢出检测
参考：早期NPTL实现、Go的goroutine调度器</li>
</ol>
</details>
<p><strong>习题2.6</strong> NUMA感知调度优化
在NUMA系统上，进程应该优先在本地节点运行。分析Linux的NUMA平衡机制，并提出一种改进方案来减少跨节点内存访问。</p>
<details>
<summary>提示</summary>
<p>分析要点：</p>
<ul>
<li>numa_balancing的页面迁移机制</li>
<li>task_numa_placement()的节点选择算法</li>
<li>
<p>内存访问热度统计（NUMA hint faults）
改进方向：</p>
</li>
<li>
<p>预测性页面迁移</p>
</li>
<li>考虑内存带宽的负载均衡</li>
<li>进程组的协同迁移</li>
</ul>
</details>
<p><strong>习题2.7</strong> 实时调度器设计
Linux的SCHED_DEADLINE使用CBS(Constant Bandwidth Server)算法。解释CBS如何保证实时任务的带宽隔离，并分析其在多核系统上的迁移策略。</p>
<details>
<summary>提示</summary>
<p>CBS核心机制：</p>
<ul>
<li>运行时预算(runtime)和周期(period)</li>
<li>截止时间(deadline)的动态更新</li>
<li>带宽保证：runtime/period ≤ CPU利用率</li>
</ul>
<p>多核迁移考虑：</p>
<ul>
<li>push/pull操作的触发时机</li>
<li>最早截止时间优先(EDF)的全局调度</li>
<li>迁移开销vs截止时间错过的权衡</li>
</ul>
</details>
<p><strong>习题2.8</strong> 调度器能耗优化
现代处理器支持动态频率调节(DVFS)。分析Linux的schedutil governor如何根据调度器信息调节CPU频率，并讨论在大小核架构(如ARM big.LITTLE)上的优化策略。</p>
<details>
<summary>提示</summary>
<p>schedutil工作原理：</p>
<ul>
<li>基于运行队列利用率(util_avg)</li>
<li>频率 = util * max_freq / max_capacity</li>
<li>考虑实时任务和deadline任务的特殊需求</li>
</ul>
<p>大小核优化：</p>
<ul>
<li>任务迁移的能效比计算</li>
<li>EAS(Energy Aware Scheduling)框架</li>
<li>温度和功耗的动态平衡</li>
</ul>
</details>
<h2 id="_5">常见陷阱与错误</h2>
<h3 id="1">1. 进程创建陷阱</h3>
<p><strong>错误</strong>: vfork后使用return而非_exit</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误 - 破坏父进程栈帧</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vfork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 危险！</span>
<span class="p">}</span>

<span class="c1">// 正确</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vfork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 直接退出，不执行清理</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>错误</strong>: fork后的文件描述符竞争</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 父子进程共享文件偏移量</span>
<span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;file&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;child&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w">  </span><span class="c1">// 可能与父进程写入交错</span>
<span class="p">}</span>
<span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;parent&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
</code></pre></div>

<h3 id="2_1">2. 调度器相关问题</h3>
<p><strong>错误</strong>: 错误使用sched_yield()</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 忙等待 - CPU密集</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sched_yield</span><span class="p">();</span><span class="w">  </span><span class="c1">// 如果没有其他就绪任务，立即返回</span>
<span class="p">}</span>

<span class="c1">// 正确方式 - 使用条件变量或信号量</span>
<span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div>

<p><strong>错误</strong>: 实时进程优先级反转</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// RT任务等待普通任务持有的锁</span>
<span class="c1">// 解决方案：优先级继承协议或优先级天花板</span>
</code></pre></div>

<h3 id="3">3. 亲和性设置错误</h3>
<p><strong>错误</strong>: 过度限制CPU亲和性</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 将所有线程绑定到一个CPU - 性能灾难</span>
<span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
<span class="n">CPU_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
<span class="n">pthread_setaffinity_np</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">cpuset</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
</code></pre></div>

<h3 id="4-cgroup">4. cgroup配置错误</h3>
<p><strong>常见错误</strong>：</p>
<ul>
<li>cpu.shares设置不当导致饥饿</li>
<li>memory.limit_in_bytes过小触发OOM</li>
<li>忘记设置memory.swappiness导致过度交换</li>
</ul>
<h2 id="_6">最佳实践检查清单</h2>
<h3 id="_7">进程设计审查</h3>
<ul>
<li>[ ] <strong>进程模型选择</strong></li>
<li>[ ] 多进程 vs 多线程 vs 事件驱动</li>
<li>[ ] 考虑内存共享需求</li>
<li>
<p>[ ] 评估故障隔离要求</p>
</li>
<li>
<p>[ ] <strong>资源限制设置</strong></p>
</li>
<li>[ ] 设置合理的RLIMIT值</li>
<li>[ ] 配置cgroup资源限制</li>
<li>
<p>[ ] 实施OOM分数调整</p>
</li>
<li>
<p>[ ] <strong>亲和性优化</strong></p>
</li>
<li>[ ] NUMA节点亲和性</li>
<li>[ ] 中断亲和性与进程亲和性协调</li>
<li>[ ] 避免过度的CPU绑定</li>
</ul>
<h3 id="_8">调度优化审查</h3>
<ul>
<li>[ ] <strong>优先级设计</strong></li>
<li>[ ] 合理使用nice值</li>
<li>[ ] 谨慎使用实时优先级</li>
<li>
<p>[ ] 实施优先级继承机制</p>
</li>
<li>
<p>[ ] <strong>延迟敏感优化</strong></p>
</li>
<li>[ ] 识别延迟敏感路径</li>
<li>[ ] 减少锁持有时间</li>
<li>
<p>[ ] 使用SCHED_DEADLINE for硬实时需求</p>
</li>
<li>
<p>[ ] <strong>调度器参数调优</strong></p>
</li>
<li>[ ] 调整sched_latency_ns</li>
<li>[ ] 配置sched_migration_cost</li>
<li>[ ] 优化numa_balancing设置</li>
</ul>
<h3 id="_9">性能监控要点</h3>
<ul>
<li>[ ] <strong>调度统计监控</strong></li>
<li>[ ] 监控/proc/schedstat</li>
<li>[ ] 跟踪上下文切换率</li>
<li>
<p>[ ] 分析调度延迟分布</p>
</li>
<li>
<p>[ ] <strong>CPU利用率分析</strong></p>
</li>
<li>[ ] 区分用户态/内核态时间</li>
<li>[ ] 识别CPU空转原因</li>
<li>
<p>[ ] 检测负载不均衡</p>
</li>
<li>
<p>[ ] <strong>实时性验证</strong></p>
</li>
<li>[ ] 测量最坏情况延迟</li>
<li>[ ] 验证deadline满足率</li>
<li>[ ] 评估抢占延迟</li>
</ul>
<h3 id="_10">调试技巧总结</h3>
<ol>
<li><strong>使用ftrace跟踪调度事件</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nb">echo</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/events/sched/enable
cat<span class="w"> </span>/sys/kernel/debug/tracing/trace
</code></pre></div>

<ol start="2">
<li><strong>使用perf分析调度行为</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>perf<span class="w"> </span>sched<span class="w"> </span>record<span class="w"> </span>--<span class="w"> </span>./workload
perf<span class="w"> </span>sched<span class="w"> </span>latency
</code></pre></div>

<ol start="3">
<li><strong>实时监控调度器</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>watch<span class="w"> </span>-n<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="s1">&#39;cat /proc/sched_debug&#39;</span>
</code></pre></div>

<ol start="4">
<li><strong>分析特定进程的调度</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>cat<span class="w"> </span>/proc/<span class="o">[</span>pid<span class="o">]</span>/sched
cat<span class="w"> </span>/proc/<span class="o">[</span>pid<span class="o">]</span>/schedstat
</code></pre></div>
            </article>
            
            <nav class="page-nav"><a href="chapter1.html" class="nav-link prev">← 第1章：Linux 内核概述与发展史</a><a href="chapter3.html" class="nav-link next">第3章：内存管理架构 →</a></nav>
        </main>
    </div>
</body>
</html>