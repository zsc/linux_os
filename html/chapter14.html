<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第14章：实时Linux</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Linux 内核源代码深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：Linux 内核概述与发展史</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：进程管理与任务调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：内存管理架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：进程间通信机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：虚拟文件系统（VFS）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：具体文件系统实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：块设备层与I/O调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：设备驱动模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：网络协议栈</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：内核同步机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：并发编程模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：容器与命名空间</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：安全子系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：实时Linux</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：性能分析与调试</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：引导过程与初始化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="14linux">第14章：实时Linux</h1>
<h2 id="_1">本章学习目标</h2>
<p>实时系统要求任务在确定的时间约束内完成，这对传统 Linux 内核提出了严峻挑战。本章深入剖析 Linux 实时扩展的核心技术，从 PREEMPT_RT 补丁集到 SCHED_DEADLINE 调度器，从优先级继承机制到高精度定时器。通过学习本章，您将掌握如何将通用 Linux 转变为满足严格时间约束的实时操作系统，理解延迟的来源与优化技术，并能够设计和调试实时应用。</p>
<h2 id="141">14.1 实时系统基础概念</h2>
<h3 id="1411">14.1.1 实时性定义与分类</h3>
<p>实时系统的核心是<strong>可预测性</strong>而非单纯的快速响应。一个实时系统必须保证：</p>
<p>$$\forall t_i \in T: t_{response} \leq t_{deadline}$$
其中 $T$ 是任务集合，$t_{response}$ 是响应时间，$t_{deadline}$ 是截止时间。</p>
<p>根据对截止时间违反的容忍度，实时系统分为：</p>
<ol>
<li>
<p><strong>硬实时（Hard Real-time）</strong>：错过截止时间将导致灾难性后果
   - 例：飞机控制系统、心脏起搏器
   - 要求：最坏情况执行时间（WCET）必须可证明</p>
</li>
<li>
<p><strong>软实时（Soft Real-time）</strong>：偶尔错过截止时间可接受但会降低服务质量
   - 例：视频播放、VoIP 通话
   - 要求：统计意义上的延迟保证</p>
</li>
<li>
<p><strong>固实时（Firm Real-time）</strong>：错过截止时间的结果无用但不灾难
   - 例：工业控制显示系统
   - 要求：及时性与资源利用率平衡</p>
</li>
</ol>
<h3 id="1412-linux">14.1.2 Linux 内核延迟来源</h3>
<p>标准 Linux 内核的延迟主要来自：</p>
<div class="codehilite"><pre><span></span><code>中断延迟链：
    硬件中断 → 中断处理程序
         ↓
    软中断处理 → 任务调度
         ↓
    用户进程执行
</code></pre></div>

<p>具体延迟组成：</p>
<ol>
<li>
<p><strong>中断延迟</strong>（Interrupt Latency）
   - 中断禁用期间：临界区保护
   - 中断处理时间：ISR 执行
   - 公式：$L_{irq} = T_{disable} + T_{ISR}$</p>
</li>
<li>
<p><strong>调度延迟</strong>（Scheduling Latency）
   - 内核不可抢占区：自旋锁持有期
   - 调度器开销：任务选择算法
   - 公式：$L_{sched} = T_{preempt_disable} + T_{scheduler}$</p>
</li>
<li>
<p><strong>同步延迟</strong>（Synchronization Latency）
   - 优先级反转：低优先级任务持锁
   - 锁竞争：等待资源释放</p>
</li>
</ol>
<h3 id="1413">14.1.3 实时性演进历程</h3>
<p>Linux 实时性改进的里程碑：</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1991</span><span class="o">:</span><span class="w"> </span><span class="n">Linux</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">完全不可抢占</span>
<span class="w">  </span><span class="o">|</span>
<span class="mi">2001</span><span class="o">:</span><span class="w"> </span><span class="mf">2.4</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">引入低延迟补丁</span>
<span class="w">  </span><span class="o">|</span>
<span class="mi">2003</span><span class="o">:</span><span class="w"> </span><span class="mf">2.6</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">内核可抢占（</span><span class="n">CONFIG_PREEMPT</span><span class="err">）</span>
<span class="w">  </span><span class="o">|</span>
<span class="mi">2004</span><span class="o">:</span><span class="w"> </span><span class="n">PREEMPT_RT</span><span class="w"> </span><span class="err">项目启动（</span><span class="n">Ingo</span><span class="w"> </span><span class="n">Molnar</span><span class="err">）</span>
<span class="w">  </span><span class="o">|</span>
<span class="mi">2005</span><span class="o">:</span><span class="w"> </span><span class="err">高精度定时器（</span><span class="n">hrtimer</span><span class="err">）</span>
<span class="w">  </span><span class="o">|</span>
<span class="mi">2009</span><span class="o">:</span><span class="w"> </span><span class="n">SCHED_DEADLINE</span><span class="w"> </span><span class="err">调度类</span>
<span class="w">  </span><span class="o">|</span>
<span class="mi">2019</span><span class="o">:</span><span class="w"> </span><span class="mf">5.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">PREEMPT_RT</span><span class="w"> </span><span class="err">开始主线化</span>
<span class="w">  </span><span class="o">|</span>
<span class="mi">2023</span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span><span class="na">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">大部分</span><span class="w"> </span><span class="n">RT</span><span class="w"> </span><span class="err">特性已主线</span>
</code></pre></div>

<h2 id="142-preempt_rt">14.2 PREEMPT_RT 补丁集</h2>
<h3 id="1421">14.2.1 核心设计理念</h3>
<p>PREEMPT_RT 的目标是将 Linux 转变为完全可抢占的内核：</p>
<div class="codehilite"><pre><span></span><code>标准内核执行流：
    用户空间 → [可抢占]
         ↓
    系统调用 → [部分可抢占]
         ↓
    中断处理 → [不可抢占]

PREEMPT_RT 执行流：
    用户空间 → [可抢占]
         ↓
    系统调用 → [完全可抢占]
         ↓
    线程化中断 → [可抢占]
</code></pre></div>

<h3 id="1422">14.2.2 关键组件改造</h3>
<h4 id="_2">自旋锁转换为可睡眠锁</h4>
<p>标准内核的 spinlock 在 RT 中变为 rt_mutex：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 标准内核 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arch_spinlock_t</span><span class="w"> </span><span class="n">raw_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* PREEMPT_RT */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_mutex_base</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 可睡眠的互斥锁 */</span>
<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lockdep_map</span><span class="w"> </span><span class="n">dep_map</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</code></pre></div>

<p>这种转换的影响：</p>
<ul>
<li>临界区变为可抢占</li>
<li>持锁时可以睡眠</li>
<li>支持优先级继承</li>
</ul>
<h4 id="_3">中断线程化</h4>
<p>将中断处理程序转换为内核线程：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 中断线程化结构 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">irq_desc</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">irqaction</span><span class="w"> </span><span class="o">*</span><span class="n">action</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="kr">thread</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 中断线程 */</span>
<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">wait_for_threads</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">threads_active</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* 线程化中断处理流程 */</span>
<span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">handle_irq_event</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_desc</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* 唤醒中断线程 */</span>
<span class="w">        </span><span class="n">wake_up_process</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_WAKE_THREAD</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* 直接处理 */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">action</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="n">action</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="_4">软中断线程化</h4>
<p>软中断也被转换为 ksoftirqd 线程：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* RT 内核的软中断处理 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run_ksoftirqd</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">tsk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">ksoftirqd</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tsk</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TASK_RUNNING</span><span class="p">)</span>
<span class="w">        </span><span class="n">wake_up_process</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1423">14.2.3 抢占模型对比</h3>
<p>Linux 提供多种抢占模型：</p>
<p>| 模型 | CONFIG选项 | 特点 | 延迟 | 吞吐量 |</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>CONFIG选项</th>
<th>特点</th>
<th>延迟</th>
<th>吞吐量</th>
</tr>
</thead>
<tbody>
<tr>
<td>无抢占</td>
<td>PREEMPT_NONE</td>
<td>仅自愿调度点</td>
<td>高(~100ms)</td>
<td>最高</td>
</tr>
<tr>
<td>自愿抢占</td>
<td>PREEMPT_VOLUNTARY</td>
<td>增加抢占点</td>
<td>中(~10ms)</td>
<td>高</td>
</tr>
<tr>
<td>抢占</td>
<td>PREEMPT</td>
<td>内核可抢占</td>
<td>低(~1ms)</td>
<td>中</td>
</tr>
<tr>
<td>RT抢占</td>
<td>PREEMPT_RT</td>
<td>完全可抢占</td>
<td>极低(~50μs)</td>
<td>较低</td>
</tr>
</tbody>
</table>
<h2 id="143">14.3 优先级继承与优先级天花板</h2>
<h3 id="1431">14.3.1 优先级反转问题</h3>
<p>优先级反转发生在高优先级任务等待低优先级任务持有的资源时：</p>
<div class="codehilite"><pre><span></span><code>时间轴展示：
T0: L(低优先级)获取锁 mutex_A
T1: H(高优先级)尝试获取 mutex_A，阻塞
T2: M(中优先级)就绪，抢占 L
T3: M 执行...
T4: M 完成，L 继续
T5: L 释放 mutex_A
T6: H 获得 mutex_A 并执行

问题：H 被 M 间接阻塞，违反优先级语义
</code></pre></div>

<h3 id="1432-pi">14.3.2 优先级继承协议（PI）</h3>
<p>PI 协议通过临时提升持锁任务的优先级解决反转：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* rt_mutex 优先级继承实现 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rt_mutex_waiter</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_node</span><span class="w"> </span><span class="n">tree_node</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 红黑树节点 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 等待任务 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_mutex_base</span><span class="w"> </span><span class="o">*</span><span class="n">lock</span><span class="p">;</span><span class="w">   </span><span class="cm">/* 等待的锁 */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">prio</span><span class="p">;</span><span class="w">                      </span><span class="cm">/* 等待者优先级 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">deadline</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* 截止时间 */</span>
<span class="p">};</span>

<span class="cm">/* 优先级继承链 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">task_blocks_on_rt_mutex</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_mutex_base</span><span class="w"> </span><span class="o">*</span><span class="n">lock</span><span class="p">,</span>
<span class="w">                                   </span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_mutex_waiter</span><span class="w"> </span><span class="o">*</span><span class="n">waiter</span><span class="p">,</span>
<span class="w">                                   </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 将等待者加入等待队列 */</span>
<span class="w">    </span><span class="n">rt_mutex_enqueue</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">waiter</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 继承优先级 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* 提升持锁者优先级 */</span>
<span class="w">        </span><span class="n">rt_mutex_adjust_prio_chain</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>优先级继承的传递性：</p>
<div class="codehilite"><pre><span></span><code>PI链传递：
T1(prio=10) → blocks on L1 held by →
T2(prio=30) → blocks on L2 held by →
T3(prio=50) → 继承 prio=10

结果：T3 临时运行在 prio=10
</code></pre></div>

<h3 id="1433-pc">14.3.3 优先级天花板协议（PC）</h3>
<p>PC 协议预先将锁的优先级设为可能访问它的最高优先级任务：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 优先级天花板实现伪代码 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">prio_ceiling_mutex</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_mutex</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ceiling_priority</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 天花板优先级 */</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">pc_mutex_lock</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">prio_ceiling_mutex</span><span class="w"> </span><span class="o">*</span><span class="n">pcm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">old_prio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 立即提升到天花板优先级 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">ceiling_priority</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">ceiling_priority</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/* 重新入队调度器 */</span>
<span class="w">        </span><span class="n">requeue_task_rt</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">rt_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_prio</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>PI vs PC 对比：</p>
<p>| 特性 | 优先级继承(PI) | 优先级天花板(PC) |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>优先级继承(PI)</th>
<th>优先级天花板(PC)</th>
</tr>
</thead>
<tbody>
<tr>
<td>优先级调整时机</td>
<td>发生阻塞时</td>
<td>获取锁时</td>
</tr>
<tr>
<td>开销</td>
<td>动态，链式传递</td>
<td>静态，固定</td>
</tr>
<tr>
<td>死锁预防</td>
<td>不能</td>
<td>可以</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>Linux支持</td>
<td>完整支持</td>
<td>部分支持</td>
</tr>
</tbody>
</table>
<h2 id="144-hrtimer">14.4 高精度定时器（hrtimer）</h2>
<h3 id="1441">14.4.1 传统定时器的局限</h3>
<p>Linux 传统定时器基于 jiffies，精度受 HZ 限制：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 传统定时器精度 */</span>
<span class="n">HZ</span><span class="o">=</span><span class="mi">100</span><span class="o">:</span><span class="w">  </span><span class="n">精度</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="n">ms</span>
<span class="n">HZ</span><span class="o">=</span><span class="mi">1000</span><span class="o">:</span><span class="w"> </span><span class="n">精度</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="n">ms</span>

<span class="cm">/* jiffies 定时器问题 */</span>

<span class="mf">1.</span><span class="w"> </span><span class="n">精度不足</span><span class="err">：</span><span class="n">最小粒度受</span><span class="w"> </span><span class="n">HZ</span><span class="w"> </span><span class="n">限制</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">级联开销</span><span class="err">：</span><span class="n">时间轮级联操作</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">同步问题</span><span class="err">：</span><span class="n">所有定时器在</span><span class="w"> </span><span class="n">tick</span><span class="w"> </span><span class="n">边界触发</span>
</code></pre></div>

<h3 id="1442-hrtimer">14.4.2 hrtimer 架构设计</h3>
<p>高精度定时器使用红黑树组织，支持纳秒级精度：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* hrtimer 数据结构 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">timerqueue_node</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 红黑树节点 */</span>
<span class="w">    </span><span class="n">ktime_t</span><span class="w"> </span><span class="n">_softexpires</span><span class="p">;</span><span class="w">         </span><span class="cm">/* 软过期时间 */</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">hrtimer_restart</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer_clock_base</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="n">is_rel</span><span class="p">;</span><span class="w">                    </span><span class="cm">/* 相对/绝对定时器 */</span>
<span class="p">};</span>

<span class="cm">/* 时钟基础 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer_clock_base</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer_cpu_base</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_base</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clockid_t</span><span class="w"> </span><span class="n">clockid</span><span class="p">;</span><span class="w">            </span><span class="cm">/* CLOCK_MONOTONIC/REALTIME */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">timerqueue_head</span><span class="w"> </span><span class="n">active</span><span class="p">;</span><span class="w"> </span><span class="cm">/* 红黑树根 */</span>
<span class="w">    </span><span class="n">ktime_t</span><span class="w"> </span><span class="n">resolution</span><span class="p">;</span><span class="w">           </span><span class="cm">/* 时钟分辨率 */</span>
<span class="w">    </span><span class="n">ktime_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_time</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span><span class="w">    </span><span class="cm">/* 获取当前时间 */</span>
<span class="w">    </span><span class="n">ktime_t</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w">              </span><span class="cm">/* 时间偏移 */</span>
<span class="p">};</span>

<span class="cp">### 14.4.3 时钟源与时钟事件设备</span>

<span class="n">Linux</span><span class="w"> </span><span class="n">时间子系统分离了时钟源</span><span class="err">（</span><span class="n">clocksource</span><span class="err">）</span><span class="n">和时钟事件设备</span><span class="err">（</span><span class="n">clock_event_device</span><span class="err">）：</span>

<span class="err">```</span><span class="n">c</span>
<span class="cm">/* 时钟源：提供时间读取 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">clocksource</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">clocksource</span><span class="w"> </span><span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">mult</span><span class="p">;</span><span class="w">                    </span><span class="cm">/* 频率转换乘数 */</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* 频率转换移位 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">max_idle_ns</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">            </span><span class="cm">/* TSC, HPET, ACPI_PM */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rating</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* 优先级评分 */</span>
<span class="p">};</span>

<span class="cm">/* 时钟事件设备：产生定时中断 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">clock_event_device</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">event_handler</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">clock_event_device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">set_next_event</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">evt</span><span class="p">,</span>
<span class="w">                         </span><span class="k">struct</span><span class="w"> </span><span class="nc">clock_event_device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">set_state_oneshot</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">clock_event_device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">set_state_periodic</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">clock_event_device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">features</span><span class="p">;</span><span class="w">       </span><span class="cm">/* ONESHOT, PERIODIC */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">max_delta_ns</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">min_delta_ns</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>时钟源优先级（x86）：</p>
<div class="codehilite"><pre><span></span><code>Rating  时钟源         精度        特点
400     TSC           ~1ns        CPU时间戳计数器
250     HPET          ~100ns      高精度事件定时器  
200     ACPI_PM       ~300ns      ACPI电源管理定时器
100     PIT           ~1μs        可编程间隔定时器
</code></pre></div>

<h3 id="1444-hrtimer">14.4.4 hrtimer 操作实现</h3>
<p>定时器的启动与到期处理：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 启动高精度定时器 */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">hrtimer_start</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer</span><span class="w"> </span><span class="o">*</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="n">ktime_t</span><span class="w"> </span><span class="n">tim</span><span class="p">,</span>
<span class="w">                  </span><span class="k">enum</span><span class="w"> </span><span class="n">hrtimer_mode</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer_clock_base</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>

<span class="w">    </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 计算绝对过期时间 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">HRTIMER_MODE_REL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ktime_add_safe</span><span class="p">(</span><span class="n">tim</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tim</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 插入红黑树 */</span>
<span class="w">    </span><span class="n">enqueue_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 编程硬件定时器 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">.</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">hrtimer_reprogram</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">unlock_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 定时器到期处理 */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">hrtimer_interrupt</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">clock_event_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer_cpu_base</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hrtimer_bases</span><span class="p">);</span>
<span class="w">    </span><span class="n">ktime_t</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ktime_get</span><span class="p">();</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">now</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="n">__remove_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">);</span>
<span class="w">        </span><span class="n">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* 执行回调 */</span>
<span class="w">        </span><span class="n">restart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">restart</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">HRTIMER_RESTART</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1445-no_hz">14.4.5 动态时钟（NO_HZ）</h3>
<p>NO_HZ 模式在系统空闲时停止周期性时钟中断：</p>
<div class="codehilite"><pre><span></span><code>传统 HZ 模式：
|tick|tick|tick|tick|tick|tick|  每 1/HZ 秒中断
     浪费功耗

NO_HZ_IDLE 模式：
|tick|------idle------|tick|     空闲时无中断
          省电

NO_HZ_FULL 模式：
|tick|---userspace----|tick|     用户态运行时无中断
       降低延迟抖动
</code></pre></div>

<h2 id="145">14.5 实时调度类</h2>
<h3 id="1451-sched_fifo">14.5.1 SCHED_FIFO：先进先出调度</h3>
<p>SCHED_FIFO 是最简单的实时调度策略：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* SCHED_FIFO 运行队列 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rt_prio_array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_RT_PRIO</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="cm">/* 优先级位图 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="n">MAX_RT_PRIO</span><span class="p">];</span><span class="w">    </span><span class="cm">/* 每个优先级的任务队列 */</span>
<span class="p">};</span>

<span class="cm">/* 选择下一个任务 - O(1) 复杂度 */</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">pick_next_rt_entity</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_rq</span><span class="w"> </span><span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_prio_array</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 找到最高优先级 */</span>
<span class="w">    </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sched_find_first_bit</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAX_RT_PRIO</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 返回队首任务 */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
<span class="w">                           </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="p">,</span><span class="w"> </span><span class="n">rt_list_entry</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>SCHED_FIFO 特性：</p>
<ul>
<li>无时间片，运行直到主动让出</li>
<li>同优先级任务 FIFO 排队</li>
<li>优先级范围：1-99（99最高）</li>
</ul>
<h3 id="1452-sched_rr">14.5.2 SCHED_RR：轮转调度</h3>
<p>SCHED_RR 在 FIFO 基础上增加时间片：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* RR 时间片管理 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">task_tick_rt</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">queued</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_rt_entity</span><span class="w"> </span><span class="o">*</span><span class="n">rt_se</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SCHED_RR</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">--</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">time_slice</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 时间片用完，重置并重新入队 */</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">time_slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sched_rr_timeslice</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 移到队尾 */</span>
<span class="w">    </span><span class="n">requeue_task_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 设置重新调度标志 */</span>
<span class="w">    </span><span class="n">set_tsk_need_resched</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>默认 RR 时间片：100ms（可通过 /proc/sys/kernel/sched_rr_timeslice_ms 调整）</p>
<h3 id="1453-sched_deadlineedf">14.5.3 SCHED_DEADLINE：EDF 调度</h3>
<p>SCHED_DEADLINE 实现最早截止时间优先（EDF）算法：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* DEADLINE 任务参数 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sched_dl_entity</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_node</span><span class="w"> </span><span class="n">rb_node</span><span class="p">;</span><span class="w">      </span><span class="cm">/* 红黑树节点 */</span>

<span class="w">    </span><span class="cm">/* 三个关键参数 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">dl_runtime</span><span class="p">;</span><span class="w">              </span><span class="cm">/* 最大运行时间 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">dl_deadline</span><span class="p">;</span><span class="w">             </span><span class="cm">/* 相对截止时间 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">dl_period</span><span class="p">;</span><span class="w">               </span><span class="cm">/* 周期 */</span>

<span class="w">    </span><span class="cm">/* 运行时状态 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">deadline</span><span class="p">;</span><span class="w">                </span><span class="cm">/* 绝对截止时间 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">runtime</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* 剩余运行时间 */</span>

<span class="w">    </span><span class="cm">/* CBS (Constant Bandwidth Server) */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">dl_bw</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* 带宽 = runtime/period */</span>
<span class="p">};</span>
</code></pre></div>

<p>EDF 调度算法核心：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 选择最早截止时间的任务 */</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_dl_entity</span><span class="w"> </span><span class="o">*</span><span class="n">pick_next_dl_entity</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dl_rq</span><span class="w"> </span><span class="o">*</span><span class="n">dl_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_node</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rb_first_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dl_rq</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rb_entry</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_dl_entity</span><span class="p">,</span><span class="w"> </span><span class="n">rb_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 准入控制 - 保证可调度性 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dl_overflow</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">policy</span><span class="p">,</span>
<span class="w">                      </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_attr</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_period</span><span class="p">;</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">runtime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_runtime</span><span class="p">;</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">new_bw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">runtime</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">period</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 检查 CPU 利用率上界 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dl_rq</span><span class="o">-&gt;</span><span class="n">total_bw</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">new_bw</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">dl_rq</span><span class="o">-&gt;</span><span class="n">max_bw</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 拒绝任务 */</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>可调度性分析（单处理器）：
$$U = \sum_{i=1}^{n} \frac{C_i}{T_i} \leq 1$$</p>
<p>其中 $C_i$ 是任务 $i$ 的计算时间，$T_i$ 是周期。</p>
<h3 id="1454">14.5.4 调度类优先级</h3>
<p>Linux 调度类的优先级顺序：</p>
<div class="codehilite"><pre><span></span><code><span class="err">调度类优先级（从高到低）：</span>

<span class="mf">1.</span><span class="w"> </span><span class="n">SCHED_DEADLINE</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">EDF实时调度</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">SCHED_FIFO</span><span class="w">      </span><span class="o">-</span><span class="w"> </span><span class="err">固定优先级实时</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">SCHED_RR</span><span class="w">        </span><span class="o">-</span><span class="w"> </span><span class="err">轮转实时</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">SCHED_NORMAL</span><span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">CFS公平调度</span>
<span class="mf">5.</span><span class="w"> </span><span class="n">SCHED_BATCH</span><span class="w">     </span><span class="o">-</span><span class="w"> </span><span class="err">批处理</span>
<span class="mf">6.</span><span class="w"> </span><span class="n">SCHED_IDLE</span><span class="w">      </span><span class="o">-</span><span class="w"> </span><span class="err">空闲</span>

<span class="err">选择逻辑：</span>
<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
<span class="w">        </span><span class="kr">return</span><span class="w"> </span><span class="n">task</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="146">14.6 延迟分析与优化</h2>
<h3 id="1461">14.6.1 延迟测量工具</h3>
<p>Linux 提供多种延迟追踪机制：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># cyclictest - RT 延迟测试标准工具</span>
cyclictest<span class="w"> </span>-p<span class="w"> </span><span class="m">99</span><span class="w"> </span>-m<span class="w"> </span>-n<span class="w"> </span>-l<span class="w"> </span><span class="m">100000</span><span class="w"> </span>-h<span class="w"> </span><span class="m">1000</span>

<span class="c1"># ftrace 延迟追踪器</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;irqsoff&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/current_tracer
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;preemptoff&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/current_tracer
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;wakeup_rt&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/current_tracer

<span class="c1"># hwlat_detector - 硬件/固件延迟检测</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;hwlat&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/current_tracer
</code></pre></div>

<h3 id="1462">14.6.2 中断延迟优化</h3>
<p>减少中断延迟的技术：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 1. 中断合并（NAPI） */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">napi_poll</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">napi_struct</span><span class="w"> </span><span class="o">*</span><span class="n">napi</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">work_done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 批量处理包，减少中断频率 */</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">work_done</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">budget</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">process_packet</span><span class="p">())</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="n">work_done</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">work_done</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">budget</span><span class="p">)</span>
<span class="w">        </span><span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 2. 中断亲和性设置 */</span>
<span class="n">echo</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">irq</span><span class="o">/</span><span class="mi">24</span><span class="o">/</span><span class="n">smp_affinity</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">绑定到</span><span class="w"> </span><span class="n">CPU1</span>

<span class="cm">/* 3. 中断线程优先级调整 */</span>
<span class="n">chrt</span><span class="w"> </span><span class="o">-</span><span class="n">f</span><span class="w"> </span><span class="o">-</span><span class="n">p</span><span class="w"> </span><span class="mi">99</span><span class="w"> </span><span class="n">$</span><span class="p">(</span><span class="n">pidof</span><span class="w"> </span><span class="n">irq</span><span class="o">/</span><span class="mi">24</span><span class="o">-</span><span class="n">eth0</span><span class="p">)</span>
</code></pre></div>

<h3 id="1463">14.6.3 调度延迟优化</h3>
<p>降低调度延迟的方法：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 1. 减少抢占禁用区 */</span>
<span class="c1">// 不好的做法</span>
<span class="n">preempt_disable</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">preempt_enable</span><span class="p">();</span>

<span class="c1">// 改进做法</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">preempt_disable</span><span class="p">();</span>
<span class="w">    </span><span class="n">do_something</span><span class="p">();</span>
<span class="w">    </span><span class="n">preempt_enable</span><span class="p">();</span>
<span class="w">    </span><span class="n">cond_resched</span><span class="p">();</span><span class="w">  </span><span class="cm">/* 自愿调度点 */</span>
<span class="p">}</span>

<span class="cm">/* 2. 使用 local_lock 替代 preempt_disable */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">local_lock</span><span class="p">,</span><span class="w"> </span><span class="n">my_lock</span><span class="p">);</span>

<span class="n">local_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_lock</span><span class="p">);</span>
<span class="cm">/* 临界区 - RT 内核中可抢占 */</span>
<span class="n">local_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_lock</span><span class="p">);</span>
</code></pre></div>

<h3 id="1464-wcet">14.6.4 最坏情况执行时间（WCET）</h3>
<p>WCET 分析对硬实时系统至关重要：</p>
<div class="codehilite"><pre><span></span><code>WCET 组成：
├── 任务执行时间
│   ├── 基本块执行
│   └── 缓存效应
├── 内核开销
│   ├── 系统调用
│   └── 上下文切换
└── 干扰时间
    ├── 中断处理
    └── 高优先级抢占

总 WCET = max(执行路径) + max(内核开销) + Σ(干扰)
</code></pre></div>

<h2 id="147">14.7 实时系统集成技术</h2>
<h3 id="1471-cpu-isolation">14.7.1 CPU 隔离（Isolation）</h3>
<p>将 CPU 专用于实时任务，避免干扰：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 内核启动参数</span>
<span class="nv">isolcpus</span><span class="o">=</span><span class="m">2</span>,3<span class="w"> </span><span class="nv">nohz_full</span><span class="o">=</span><span class="m">2</span>,3<span class="w"> </span><span class="nv">rcu_nocbs</span><span class="o">=</span><span class="m">2</span>,3

<span class="c1"># 运行时绑定</span>
taskset<span class="w"> </span>-c<span class="w"> </span><span class="m">2</span><span class="w"> </span>./realtime_app
</code></pre></div>

<p>CPU 隔离效果：</p>
<ul>
<li>无调度器负载均衡</li>
<li>无 RCU 回调</li>
<li>无定时器中断（NO_HZ_FULL）</li>
</ul>
<h3 id="1472">14.7.2 内存锁定</h3>
<p>防止页面换出导致的不确定延迟：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 锁定所有内存页 */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mlockall</span><span class="p">(</span><span class="n">MCL_CURRENT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MCL_FUTURE</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mlockall failed&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 预分配堆栈 */</span>
<span class="kt">void</span><span class="w"> </span><span class="n">stack_prefault</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">dummy</span><span class="p">[</span><span class="n">MAX_STACK_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_STACK_SIZE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1473">14.7.3 实时应用模板</h3>
<p>标准实时应用初始化流程：</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">setup_realtime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_param</span><span class="w"> </span><span class="n">param</span><span class="p">;</span>
<span class="w">    </span><span class="kt">cpu_set_t</span><span class="w"> </span><span class="n">cpuset</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 1. 设置实时调度策略 */</span>
<span class="w">    </span><span class="n">param</span><span class="p">.</span><span class="n">sched_priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">99</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sched_setscheduler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">SCHED_FIFO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;sched_setscheduler&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 2. 绑定 CPU */</span>
<span class="w">    </span><span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
<span class="w">    </span><span class="n">CPU_SET</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sched_setaffinity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">cpuset</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;sched_setaffinity&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 3. 锁定内存 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mlockall</span><span class="p">(</span><span class="n">MCL_CURRENT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MCL_FUTURE</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mlockall&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 4. 预热缓存 */</span>
<span class="w">    </span><span class="n">stack_prefault</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="_5">本章小结</h2>
<p>本章深入探讨了 Linux 实时扩展的核心技术。从 PREEMPT_RT 补丁集的完全可抢占内核设计，到优先级继承协议解决优先级反转问题，再到高精度定时器和 SCHED_DEADLINE 调度器的实现，我们系统地分析了将通用 Linux 转变为实时操作系统的关键机制。</p>
<p><strong>核心要点回顾</strong>：</p>
<ol>
<li><strong>PREEMPT_RT 三大改造</strong>：自旋锁睡眠化、中断线程化、软中断线程化</li>
<li><strong>优先级继承链</strong>：动态提升持锁任务优先级，防止优先级反转</li>
<li><strong>高精度定时器</strong>：纳秒级精度，红黑树组织，支持 NO_HZ 模式</li>
<li><strong>实时调度类层次</strong>：DEADLINE &gt; FIFO &gt; RR &gt; NORMAL</li>
<li><strong>延迟优化技术</strong>：CPU 隔离、内存锁定、中断亲和性</li>
</ol>
<p><strong>关键公式总结</strong>：</p>
<ul>
<li>EDF 可调度性：$U = \sum \frac{C_i}{T_i} \leq 1$</li>
<li>响应时间：$R_i = C_i + \sum_{j \in hp(i)} \lceil \frac{R_i}{T_j} \rceil C_j$</li>
<li>优先级继承：$prio_{effective} = \min(prio_{nominal}, prio_{waiters})$</li>
</ul>
<h2 id="_6">练习题</h2>
<h3 id="_7">基础题</h3>
<ol>
<li><strong>PREEMPT_RT 机制理解</strong>
分析以下代码在标准内核和 RT 内核中的行为差异：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="cm">/* 睡眠 10ms */</span>
<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div>

<details>
<summary>答案</summary>
<p>标准内核：编译错误或内核崩溃。spin_lock 持有时不能睡眠，因为会导致死锁。</p>
<p>RT 内核：正常执行。spin_lock 在 RT 中是可睡眠的 rt_mutex，允许持锁睡眠并支持优先级继承。</p>
<p>关键差异：RT 内核将自旋锁转换为互斥锁，实现完全可抢占。</p>
</details>
<ol start="2">
<li><strong>优先级反转场景分析</strong>
三个任务 L(优先级=10)、M(优先级=50)、H(优先级=90) 共享互斥锁 mutex_A。如果 L 先获得锁，然后 H 请求锁，最后 M 就绪，描述任务执行顺序。</li>
</ol>
<details>
<summary>答案</summary>
<p>无优先级继承：</p>
<ol>
<li>L 持锁运行</li>
<li>H 请求锁，阻塞</li>
<li>M 就绪，抢占 L</li>
<li>M 执行完成</li>
<li>L 继续，释放锁</li>
<li>H 获得锁执行</li>
</ol>
<p>有优先级继承：</p>
<ol>
<li>L 持锁运行</li>
<li>H 请求锁，L 继承优先级 90</li>
<li>M 就绪但优先级低于 L(90)</li>
<li>L 以优先级 90 执行，释放锁</li>
<li>H 获得锁执行</li>
<li>M 最后执行</li>
</ol>
<p>PI 避免了中优先级任务延迟高优先级任务。</p>
</details>
<ol start="3">
<li><strong>hrtimer 精度计算</strong>
系统使用 TSC 作为时钟源（频率 2.4GHz），计算理论最高定时精度。</li>
</ol>
<details>
<summary>答案</summary>
<p>TSC 周期 = 1 / 2.4GHz = 0.417ns</p>
<p>理论精度 = TSC 周期 = 0.417ns</p>
<p>实际精度受限于：</p>
<ul>
<li>中断延迟（~1μs）</li>
<li>调度延迟（~10μs）</li>
<li>时钟事件设备编程开销（~100ns）</li>
</ul>
<p>典型实际精度：1-10μs</p>
</details>
<ol start="4">
<li><strong>SCHED_DEADLINE 准入控制</strong>
系统有两个 DEADLINE 任务：</li>
</ol>
<ul>
<li>T1: runtime=2ms, period=10ms</li>
<li>T2: runtime=3ms, period=15ms
问：能否再加入 T3: runtime=4ms, period=20ms？</li>
</ul>
<details>
<summary>答案</summary>
<p>计算 CPU 利用率：</p>
<ul>
<li>U1 = 2/10 = 0.2</li>
<li>U2 = 3/15 = 0.2</li>
<li>U3 = 4/20 = 0.2</li>
</ul>
<p>总利用率 = 0.2 + 0.2 + 0.2 = 0.6 &lt; 1</p>
<p>答：可以加入 T3。系统总利用率 60%，满足 EDF 可调度条件。</p>
<p>注意：多核系统中每个 CPU 独立计算利用率。</p>
</details>
<h3 id="_8">挑战题</h3>
<ol start="5">
<li><strong>实时调度器设计</strong>
设计一个混合调度器，同时支持周期任务和零星任务，要求：</li>
</ol>
<ul>
<li>周期任务使用 EDF</li>
<li>零星任务使用固定优先级</li>
<li>保证两类任务的隔离</li>
</ul>
<p><em>提示：考虑使用服务器（server）机制</em></p>
<details>
<summary>答案</summary>
<p>混合调度器架构：</p>
<ol>
<li>
<p><strong>CBS (Constant Bandwidth Server) 用于零星任务</strong>
   - 为零星任务预留带宽
   - 转换为周期性预算补充</p>
</li>
<li>
<p><strong>层次化调度</strong></p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code>根调度器（EDF）
├── 周期任务1
├── 周期任务2
└── CBS服务器
    ├── 零星任务1（优先级）
    └── 零星任务2（优先级）
</code></pre></div>

<ol start="3">
<li>
<p><strong>准入控制</strong>
   - 周期任务：Σ(Ci/Ti) ≤ α
   - CBS预算：Qs/Ts ≤ 1-α
   - α 是周期任务预留比例</p>
</li>
<li>
<p><strong>实现要点</strong>
   - CBS 作为 EDF 任务参与调度
   - CBS 内部使用优先级队列
   - 预算耗尽时 CBS 暂停</p>
</li>
</ol>
</details>
<ol start="6">
<li><strong>延迟抖动分析</strong>
实时任务每 10ms 执行一次，测量到延迟分布：</li>
</ol>
<ul>
<li>99%: &lt; 50μs</li>
<li>0.9%: 50-100μs  </li>
<li>0.1%: &gt; 1ms</li>
</ul>
<p>分析可能的原因和优化方案。</p>
<details>
<summary>答案</summary>
<p><strong>延迟尖峰原因分析</strong>：</p>
<ol>
<li>
<p><strong>SMI (System Management Interrupt)</strong>
   - 检测：hwlat_detector
   - 解决：BIOS 设置禁用 SMI</p>
</li>
<li>
<p><strong>CPU 频率调节</strong>
   - 检测：/sys/devices/system/cpu/cpu*/cpufreq/
   - 解决：performance governor</p>
</li>
<li>
<p><strong>内存页错误</strong>
   - 检测：缺页统计
   - 解决：mlockall() + 预分配</p>
</li>
<li>
<p><strong>缓存未命中</strong>
   - 检测：perf stat -e cache-misses
   - 解决：缓存预热，NUMA 绑定</p>
</li>
<li>
<p><strong>中断风暴</strong>
   - 检测：/proc/interrupts
   - 解决：中断合并，NAPI</p>
</li>
</ol>
<p><strong>优化方案</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 1. CPU 配置</span>
<span class="nb">echo</span><span class="w"> </span>performance<span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
<span class="nb">echo</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/system/cpu/cpu2/online<span class="w">  </span><span class="c1"># 隔离 CPU</span>

<span class="c1"># 2. 中断绑定</span>
<span class="nb">echo</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>&gt;<span class="w"> </span>/proc/irq/default_smp_affinity

<span class="c1"># 3. 内核参数</span>
<span class="nv">nohz_full</span><span class="o">=</span><span class="m">2</span><span class="w"> </span><span class="nv">rcu_nocbs</span><span class="o">=</span><span class="m">2</span><span class="w"> </span><span class="nv">isolcpus</span><span class="o">=</span><span class="m">2</span>

<span class="c1"># 4. 应用优化</span>

-<span class="w"> </span>内存预分配
-<span class="w"> </span>缓存预热循环
-<span class="w"> </span>避免系统调用
</code></pre></div>

</details>
<ol start="7">
<li><strong>实时补丁移植</strong>
将 PREEMPT_RT 补丁移植到嵌入式 ARM 平台，需要考虑哪些架构相关问题？</li>
</ol>
<details>
<summary>答案</summary>
<p><strong>ARM 架构特殊考虑</strong>：</p>
<ol>
<li>
<p><strong>中断控制器差异</strong>
   - GIC vs NVIC
   - 中断优先级位数
   - FIQ vs IRQ 处理</p>
</li>
<li>
<p><strong>原子操作实现</strong>
   - LDREX/STREX 指令
   - 内存屏障差异（DMB/DSB/ISB）
   - Thumb vs ARM 模式</p>
</li>
<li>
<p><strong>定时器架构</strong>
   - Generic Timer vs SysTick
   - 时钟源精度（32.768kHz vs MHz）</p>
</li>
<li>
<p><strong>缓存架构</strong>
   - 缓存行大小（32B vs 64B）
   - 缓存一致性协议</p>
</li>
<li>
<p><strong>移植步骤</strong></p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">架构相关代码</span><span class="err">（</span><span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="err">）</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">上下文切换</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">中断入口</span><span class="o">/</span><span class="n">出口</span>

<span class="mf">2.</span><span class="w"> </span><span class="n">平台驱动</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">定时器驱动</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">中断控制器</span>

<span class="mf">3.</span><span class="w"> </span><span class="n">配置选项</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">Kconfig</span><span class="w"> </span><span class="n">依赖</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">默认配置</span>

<span class="mf">4.</span><span class="w"> </span><span class="n">测试验证</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">cyclictest</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">stress</span><span class="o">-</span><span class="n">ng</span>
</code></pre></div>

<ol start="6">
<li><strong>常见问题</strong>
   - FPU 上下文保存
   - Thumb-2 代码优化
   - 能耗管理冲突</li>
</ol>
</details>
<ol start="8">
<li><strong>形式化验证</strong>
使用模型检查工具验证优先级继承协议的正确性，建立什么样的模型？</li>
</ol>
<details>
<summary>答案</summary>
<p><strong>UPPAAL 时间自动机模型</strong>：</p>
<ol>
<li><strong>任务自动机</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>状态：Ready, Running, Blocked
时钟：exec_time, deadline
迁移：

<span class="k">-</span> Ready → Running [guard: highest_prio]
<span class="k">-</span> Running → Blocked [sync: lock_request]
<span class="k">-</span> Blocked → Ready [sync: lock_release]
</code></pre></div>

<ol start="2">
<li><strong>互斥锁自动机</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>状态：Free, Locked
变量：owner, wait_queue
迁移：

<span class="k">-</span> Free → Locked [sync: lock_request]
<span class="k">-</span> Locked → Free [sync: lock_release]
</code></pre></div>

<ol start="3">
<li><strong>验证属性（CTL）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 无死锁</span>
<span class="nx">A</span><span class="p">[]</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">deadlock</span>

<span class="c1">// 优先级反转bounded</span>
<span class="nx">A</span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nx">Task_H</span><span class="p">.</span><span class="nx">Blocked</span><span class="w"> </span><span class="nx">imply</span><span class="w"> </span>
<span class="w">     </span><span class="nx">Task_H</span><span class="p">.</span><span class="nx">wait_time</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">MAX_INVERSION</span><span class="p">)</span>

<span class="c1">// 互斥性</span>
<span class="nx">A</span><span class="p">[]</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="p">(</span><span class="nx">Task1</span><span class="p">.</span><span class="nx">cs</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">Task2</span><span class="p">.</span><span class="nx">cs</span><span class="p">)</span>

<span class="c1">// 实时性</span>
<span class="nx">A</span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nx">Task</span><span class="p">.</span><span class="nx">exec_time</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">Task</span><span class="p">.</span><span class="nx">deadline</span><span class="p">)</span>
</code></pre></div>

<ol start="4">
<li><strong>模型参数</strong>
   - 任务数：3-5
   - 优先级：离散值
   - 执行时间：区间
   - 临界区：非确定选择</li>
</ol>
<p>验证可发现死锁、无界优先级反转等问题。</p>
</details>
<h2 id="_9">常见陷阱与错误</h2>
<h3 id="1-rt">1. RT 内核不等于硬实时</h3>
<p><strong>陷阱</strong>：认为使用 PREEMPT_RT 就能保证硬实时</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误想法：装了 RT 内核就是硬实时系统</span>
</code></pre></div>

<p><strong>正解</strong>：RT 内核只是降低延迟，硬实时需要：</p>
<ul>
<li>WCET 分析</li>
<li>资源预留</li>
<li>错误隔离</li>
<li>认证标准（DO-178C、IEC 61508）</li>
</ul>
<h3 id="2">2. 优先级设置错误</h3>
<p><strong>陷阱</strong>：随意设置实时优先级</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 危险：最高优先级可能饿死系统任务</span>
<span class="n">param</span><span class="p">.</span><span class="n">sched_priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">99</span><span class="p">;</span>
<span class="n">sched_setscheduler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">SCHED_FIFO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
</code></pre></div>

<p><strong>正解</strong>：预留优先级空间：</p>
<ul>
<li>99: 紧急中断线程</li>
<li>90-98: 关键系统服务</li>
<li>50-89: 实时应用</li>
<li>1-49: 软实时任务</li>
</ul>
<h3 id="3">3. 忽视内存延迟</h3>
<p><strong>陷阱</strong>：只关注 CPU 调度</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 页错误导致毫秒级延迟</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">LARGE_SIZE</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">LARGE_SIZE</span><span class="p">);</span><span class="w">  </span><span class="c1">// 触发缺页</span>
</code></pre></div>

<p><strong>正解</strong>：完整内存管理：</p>
<div class="codehilite"><pre><span></span><code><span class="n">mlockall</span><span class="p">(</span><span class="n">MCL_CURRENT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MCL_FUTURE</span><span class="p">);</span>
<span class="c1">// 预分配并预触碰</span>
<span class="n">posix_memalign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</code></pre></div>

<h3 id="4">4. 中断处理不当</h3>
<p><strong>陷阱</strong>：实时任务被中断风暴影响</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 网卡中断影响实时性</span>
cat<span class="w"> </span>/proc/interrupts<span class="w">  </span><span class="c1"># 每秒数万中断</span>
</code></pre></div>

<p><strong>正解</strong>：中断管理策略：</p>
<ul>
<li>中断亲和性绑定</li>
<li>NAPI 轮询模式</li>
<li>中断合并（ethtool -C）</li>
<li>中断线程化优先级调整</li>
</ul>
<h3 id="5">5. 调试工具使用不当</h3>
<p><strong>陷阱</strong>：使用 printk 调试实时代码</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// printk 可能导致数百微秒延迟</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Enter critical section</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</code></pre></div>

<p><strong>正解</strong>：使用无锁追踪：</p>
<ul>
<li>ftrace 事件</li>
<li>循环缓冲区</li>
<li>LTTng/SystemTap</li>
</ul>
<h2 id="_10">最佳实践检查清单</h2>
<h3 id="_11">系统配置</h3>
<ul>
<li>[ ] 内核编译选项</li>
<li>CONFIG_PREEMPT_RT 启用</li>
<li>CONFIG_DEBUG_PREEMPT 调试期启用</li>
<li>CONFIG_NO_HZ_FULL 配置</li>
<li>[ ] 启动参数设置</li>
<li>isolcpus 隔离 RT CPU</li>
<li>nohz_full 禁用时钟中断</li>
<li>rcu_nocbs 移除 RCU 回调</li>
<li>[ ] BIOS/UEFI 配置</li>
<li>禁用 SMI</li>
<li>禁用 CPU 频率调节</li>
<li>禁用 C-states</li>
</ul>
<h3 id="_12">应用设计</h3>
<ul>
<li>[ ] 实时任务初始化</li>
<li>调度策略设置（FIFO/RR/DEADLINE）</li>
<li>CPU 亲和性绑定</li>
<li>内存锁定（mlockall）</li>
<li>栈预分配</li>
<li>[ ] 资源管理</li>
<li>避免动态内存分配</li>
<li>使用内存池</li>
<li>预分配所有资源</li>
<li>[ ] 同步机制</li>
<li>优先使用 rt_mutex</li>
<li>避免优先级反转</li>
<li>最小化临界区</li>
</ul>
<h3 id="_13">性能监控</h3>
<ul>
<li>[ ] 延迟测量</li>
<li>cyclictest 基准测试</li>
<li>应用内延迟统计</li>
<li>最坏情况记录</li>
<li>[ ] 系统追踪</li>
<li>ftrace 配置</li>
<li>perf 事件监控</li>
<li>eBPF 探针部署</li>
<li>[ ] 资源监控</li>
<li>CPU 利用率 &lt; 70%</li>
<li>内存锁定量检查</li>
<li>中断频率监控</li>
</ul>
<h3 id="_14">测试验证</h3>
<ul>
<li>[ ] 功能测试</li>
<li>所有实时约束满足</li>
<li>降级模式正确</li>
<li>错误恢复机制</li>
<li>[ ] 压力测试</li>
<li>CPU 压力（stress-ng）</li>
<li>内存压力</li>
<li>I/O 压力</li>
<li>组合压力场景</li>
<li>[ ] 长期稳定性</li>
<li>72 小时连续运行</li>
<li>内存泄漏检查</li>
<li>优先级继承链检查</li>
</ul>
<h3 id="_15">文档规范</h3>
<ul>
<li>[ ] 设计文档</li>
<li>任务模型定义</li>
<li>时序图</li>
<li>WCET 分析</li>
<li>[ ] 配置文档</li>
<li>内核配置</li>
<li>系统调优参数</li>
<li>应用配置</li>
<li>[ ] 运维手册</li>
<li>监控指标</li>
<li>故障诊断流程</li>
<li>性能调优指南
```</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter13.html" class="nav-link prev">← 第13章：安全子系统</a><a href="chapter15.html" class="nav-link next">第15章：性能分析与调试 →</a></nav>
        </main>
    </div>
</body>
</html>