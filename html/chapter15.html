<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第15章：性能分析与调试</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Linux 内核源代码深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：Linux 内核概述与发展史</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：进程管理与任务调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：内存管理架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：进程间通信机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：虚拟文件系统（VFS）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：具体文件系统实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：块设备层与I/O调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：设备驱动模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：网络协议栈</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：内核同步机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：并发编程模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：容器与命名空间</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：安全子系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：实时Linux</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：性能分析与调试</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：引导过程与初始化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="15">第15章：性能分析与调试</h1>
<p>在现代 Linux 系统中，性能分析和调试是内核开发与系统优化的核心技能。本章深入探讨 Linux 内核提供的各种观测、分析和调试机制，从传统的 ftrace 到革命性的 eBPF，从静态跟踪点到动态探针，从崩溃转储到实时调试。我们将学习如何使用这些强大的工具来诊断性能瓶颈、追踪系统行为、定位内核错误，并最终实现系统的性能优化。</p>
<h2 id="_1">学习目标</h2>
<p>完成本章学习后，您将能够：</p>
<ol>
<li><strong>掌握内核跟踪机制</strong>：理解 ftrace、kprobes、tracepoints 的原理与使用</li>
<li><strong>精通性能分析工具</strong>：熟练使用 perf、火焰图等工具进行性能剖析</li>
<li><strong>掌握内核调试技术</strong>：使用 KGDB、crash、kdump 调试内核问题</li>
<li><strong>运用动态追踪技术</strong>：编写 eBPF/bpftrace 程序进行系统观测</li>
<li><strong>性能优化实践</strong>：识别性能瓶颈并实施针对性优化</li>
</ol>
<h2 id="_2">章节大纲</h2>
<h2 id="151">15.1 内核跟踪机制</h2>
<p>Linux 内核跟踪机制提供了观测内核行为的窗口，让我们能够在不修改内核代码的情况下，深入了解系统的运行状态。从 2.6.27 版本引入 ftrace 开始，Linux 的可观测性得到了质的飞跃。</p>
<h3 id="1511-ftrace">15.1.1 ftrace 框架</h3>
<p>ftrace（function tracer）是 Linux 内核的官方跟踪框架，由 Steven Rostedt 开发。它不仅可以跟踪函数调用，还集成了各种跟踪器，成为内核调试和性能分析的瑞士军刀。</p>
<p><strong>架构设计</strong></p>
<p>ftrace 基于编译时插桩和运行时修改实现：</p>
<div class="codehilite"><pre><span></span><code><span class="c">    用户空间接口 (/sys/kernel/debug/tracing/)</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    | Trace Buffer |  </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> 环形缓冲区（per</span><span class="nb">-</span><span class="c">CPU）</span>
<span class="c">    </span><span class="nb">+------+------+</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    |   Tracers   |  </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> function</span><span class="nt">,</span><span class="c"> function_graph</span><span class="nt">,</span><span class="c"> wakeup</span><span class="nt">,</span><span class="c"> irqsoff</span>
<span class="c">    </span><span class="nb">+------+------+</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    | Trace Events |  </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> 静态跟踪点</span>
<span class="c">    </span><span class="nb">+------+------+</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    |   Ftrace    |  </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> 核心框架</span>
<span class="c">    |   Core      |</span>
<span class="c">    </span><span class="nb">+------+------+</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    | Mcount/Fentry| </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> 函数入口钩子</span>
<span class="c">    </span><span class="nb">+--------------+</span>
</code></pre></div>

<p><strong>函数跟踪原理</strong></p>
<p>GCC 编译器的 <code>-pg</code> 选项会在每个函数入口插入 mcount 调用（新版本使用 fentry）：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 原始函数 */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">do_something</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* function body */</span>
<span class="p">}</span>

<span class="cm">/* 编译后（概念性表示） */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">do_something</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mcount</span><span class="p">();</span><span class="w">  </span><span class="cm">/* 或 __fentry__() */</span>
<span class="w">    </span><span class="cm">/* function body */</span>
<span class="p">}</span>
</code></pre></div>

<p>ftrace 在运行时通过动态修改这些调用点来启用/禁用跟踪：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* kernel/trace/ftrace.c 简化版 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ftrace_modify_code</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">old_code</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">new_code</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">replaced</span><span class="p">[</span><span class="n">MCOUNT_INSN_SIZE</span><span class="p">];</span>

<span class="w">    </span><span class="cm">/* 使用 text_poke 或类似机制修改代码 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">probe_kernel_read</span><span class="p">(</span><span class="n">replaced</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="n">MCOUNT_INSN_SIZE</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">replaced</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">old_code</span><span class="p">,</span><span class="w"> </span><span class="n">MCOUNT_INSN_SIZE</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 原子性地替换指令 */</span>
<span class="w">    </span><span class="n">text_poke_bp</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_code</span><span class="p">,</span><span class="w"> </span><span class="n">MCOUNT_INSN_SIZE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>使用示例</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 启用函数跟踪</span>
<span class="nb">echo</span><span class="w"> </span><span class="k">function</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/current_tracer
<span class="nb">echo</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/tracing_on

<span class="c1"># 设置函数过滤</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;tcp_*&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/set_ftrace_filter

<span class="c1"># 查看跟踪结果</span>
cat<span class="w"> </span>/sys/kernel/debug/tracing/trace

<span class="c1"># 函数调用图跟踪</span>
<span class="nb">echo</span><span class="w"> </span>function_graph<span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/current_tracer
</code></pre></div>

<h3 id="1512-kprobes">15.1.2 kprobes 动态探针</h3>
<p>kprobes 是 Linux 内核的动态探测机制，允许在几乎任意内核代码位置设置探针，无需重新编译内核。它通过替换指令、使用断点或跳转指令来实现。</p>
<p><strong>kprobes 家族</strong></p>
<ol>
<li><strong>kprobes</strong>：在指定地址设置探针</li>
<li><strong>kretprobes</strong>：在函数返回时触发</li>
<li><strong>jprobes</strong>：已废弃，被 kprobes 取代</li>
</ol>
<p><strong>实现机制</strong></p>
<p>kprobes 的核心是指令替换和异常处理：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 简化的 kprobe 结构 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">kprobe</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hlist_node</span><span class="w"> </span><span class="n">hlist</span><span class="p">;</span>
<span class="w">    </span><span class="n">kprobe_opcode_t</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">;</span><span class="w">        </span><span class="cm">/* 探测点地址 */</span>
<span class="w">    </span><span class="n">kprobe_pre_handler_t</span><span class="w"> </span><span class="n">pre_handler</span><span class="p">;</span>
<span class="w">    </span><span class="n">kprobe_post_handler_t</span><span class="w"> </span><span class="n">post_handler</span><span class="p">;</span>
<span class="w">    </span><span class="n">kprobe_opcode_t</span><span class="w"> </span><span class="n">opcode</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 保存的原始指令 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">arch_specific_insn</span><span class="w"> </span><span class="n">ainsn</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* 注册 kprobe 的核心流程 */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">register_kprobe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kprobe</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* 1. 解析符号地址 */</span>
<span class="w">    </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kprobe_addr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 2. 准备探测点 */</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepare_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 3. 插入断点指令 (x86: int3) */</span>
<span class="w">    </span><span class="n">arch_arm_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 4. 添加到哈希表 */</span>
<span class="w">    </span><span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">hash</span><span class="p">]);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>断点处理流程</strong></p>
<div class="codehilite"><pre><span></span><code>    执行到探测点
         |
         v
    触发 int3 异常
         |
         v
    do_int3() 处理器
         |
         v
    kprobe_int3_handler()
         |
    +----+----+
    |         |
    v         v
pre_handler  单步执行原指令
    |         |
    v         v
post_handler 返回正常执行
</code></pre></div>

<p><strong>使用示例</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 内核模块中使用 kprobes */</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kprobe</span><span class="w"> </span><span class="n">kp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">symbol_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;tcp_sendmsg&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">handler_pre</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kprobe</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;tcp_sendmsg: sock=%p, len=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">,</span><span class="w"> </span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">si</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">kprobe_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">kp</span><span class="p">.</span><span class="n">pre_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handler_pre</span><span class="p">;</span>
<span class="w">    </span><span class="n">register_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kp</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1513-tracepoints">15.1.3 tracepoints 静态跟踪点</h3>
<p>tracepoints 是内核中预定义的静态跟踪点，相比动态探针具有更高的稳定性和更低的开销。</p>
<p><strong>定义跟踪点</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* include/trace/events/sched.h */</span>
<span class="n">TRACE_EVENT</span><span class="p">(</span><span class="n">sched_switch</span><span class="p">,</span>
<span class="w">    </span><span class="n">TP_PROTO</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">),</span>
<span class="w">    </span><span class="n">TP_ARGS</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">),</span>

<span class="w">    </span><span class="n">TP_STRUCT__entry</span><span class="p">(</span>
<span class="w">        </span><span class="n">__array</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">prev_comm</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_COMM_LEN</span><span class="p">)</span>
<span class="w">        </span><span class="n">__field</span><span class="p">(</span><span class="kt">pid_t</span><span class="p">,</span><span class="w"> </span><span class="n">prev_pid</span><span class="p">)</span>
<span class="w">        </span><span class="n">__field</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">prev_prio</span><span class="p">)</span>
<span class="w">        </span><span class="n">__array</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">next_comm</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_COMM_LEN</span><span class="p">)</span>
<span class="w">        </span><span class="n">__field</span><span class="p">(</span><span class="kt">pid_t</span><span class="p">,</span><span class="w"> </span><span class="n">next_pid</span><span class="p">)</span>
<span class="w">        </span><span class="n">__field</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">next_prio</span><span class="p">)</span>
<span class="w">    </span><span class="p">),</span>

<span class="w">    </span><span class="n">TP_fast_assign</span><span class="p">(</span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">prev_comm</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_COMM_LEN</span><span class="p">);</span>
<span class="w">        </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">prev_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="w">        </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">prev_prio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">next_comm</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_COMM_LEN</span><span class="p">);</span>
<span class="w">        </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">next_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="w">        </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">next_prio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="w">    </span><span class="p">),</span>

<span class="w">    </span><span class="n">TP_printk</span><span class="p">(</span><span class="s">&quot;prev_comm=%s prev_pid=%d prev_prio=%d ==&gt; &quot;</span>
<span class="w">              </span><span class="s">&quot;next_comm=%s next_pid=%d next_prio=%d&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">prev_comm</span><span class="p">,</span><span class="w"> </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">prev_pid</span><span class="p">,</span><span class="w"> </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">prev_prio</span><span class="p">,</span>
<span class="w">              </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">next_comm</span><span class="p">,</span><span class="w"> </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">next_pid</span><span class="p">,</span><span class="w"> </span><span class="n">__entry</span><span class="o">-&gt;</span><span class="n">next_prio</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>

<p><strong>跟踪点实现</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 跟踪点的静态调用优化 */</span>
<span class="cp">#define DEFINE_TRACE(name)                              \</span>
<span class="cp">    struct tracepoint __tracepoint_##name = {           \</span>
<span class="cp">        .name = #name,                                  \</span>
<span class="cp">        .key = STATIC_KEY_INIT_FALSE,                   \</span>
<span class="cp">        .funcs = NULL,                                  \</span>
<span class="cp">    };                                                   \</span>
<span class="cp">                                                        \</span>
<span class="cp">    static inline void trace_##name(proto)              \</span>
<span class="cp">    {                                                    \</span>
<span class="cp">        if (static_key_false(&amp;__tracepoint_##name.key)) \</span>
<span class="cp">            __DO_TRACE(&amp;__tracepoint_##name, args);     \</span>
<span class="cp">    }</span>
</code></pre></div>

<h3 id="1514">15.1.4 跟踪事件子系统</h3>
<p>跟踪事件子系统统一了各种跟踪机制的接口，提供了标准化的事件定义和过滤机制。</p>
<p><strong>事件过滤器</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 设置过滤条件</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;prev_prio &lt; 100&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/events/sched/sched_switch/filter

<span class="c1"># 复合条件</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;irq == 1 &amp;&amp; ret &gt;= 0&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/tracing/events/irq/irq_handler_exit/filter
</code></pre></div>

<p><strong>触发器机制</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 当满足条件时触发快照</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;snapshot if bytes_req &gt; 4096&#39;</span><span class="w"> </span>&gt;<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>/sys/kernel/debug/tracing/events/kmem/kmalloc/trigger

<span class="c1"># 触发栈追踪</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;stacktrace&#39;</span><span class="w"> </span>&gt;<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>/sys/kernel/debug/tracing/events/sched/sched_switch/trigger
</code></pre></div>

<h2 id="152">15.2 性能计数器</h2>
<p>Linux 性能计数器子系统（perf_events）提供了统一的接口来访问硬件性能计数器和软件事件，是现代性能分析的基石。</p>
<h3 id="1521-perf-events">15.2.1 perf events 架构</h3>
<p>perf_events 子系统由 Thomas Gleixner、Ingo Molnar 和 Arnaldo Carvalho de Melo 等人开发，从 2.6.31 版本开始成为内核的核心组件。</p>
<p><strong>系统架构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="err">用户空间工具</span><span class="w"> </span><span class="p">(</span><span class="n">perf</span><span class="p">,</span><span class="w"> </span><span class="n">pmu</span><span class="o">-</span><span class="n">tools</span><span class="p">)</span>
<span class="w">              </span><span class="o">|</span>
<span class="w">    </span><span class="o">+=========</span><span class="n">v</span><span class="o">=========+</span>
<span class="w">    </span><span class="o">|</span><span class="w">   </span><span class="err">系统调用接口</span><span class="w">    </span><span class="o">|</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">perf_event_open</span><span class="p">()</span>
<span class="w">    </span><span class="o">+===================+</span>
<span class="w">              </span><span class="o">|</span>
<span class="w">    </span><span class="o">+---------</span><span class="n">v</span><span class="o">---------+</span>
<span class="w">    </span><span class="o">|</span><span class="w">  </span><span class="n">perf_event</span><span class="w"> </span><span class="err">核心</span><span class="w">  </span><span class="o">|</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="err">事件管理、调度、采样</span>
<span class="w">    </span><span class="o">+-------------------+</span>
<span class="w">         </span><span class="o">/</span><span class="w">    </span><span class="o">|</span><span class="w">    </span>\
<span class="w">        </span><span class="o">/</span><span class="w">     </span><span class="o">|</span><span class="w">     </span>\
<span class="w">       </span><span class="n">v</span><span class="w">      </span><span class="n">v</span><span class="w">      </span><span class="n">v</span>
<span class="w">    </span><span class="o">+-----+</span><span class="w"> </span><span class="o">+-----+</span><span class="w"> </span><span class="o">+-----+</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">CPU</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SW</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="n">Trace</span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">PMU</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="n">Event</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="n">Point</span><span class="o">|</span>
<span class="w">    </span><span class="o">+-----+</span><span class="w"> </span><span class="o">+-----+</span><span class="w"> </span><span class="o">+-----+</span>
</code></pre></div>

<p><strong>核心数据结构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* include/linux/perf_event.h */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w">        </span><span class="n">event_entry</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w">       </span><span class="o">*</span><span class="n">group_leader</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pmu</span><span class="w">              </span><span class="o">*</span><span class="n">pmu</span><span class="p">;</span><span class="w">           </span><span class="cm">/* 性能监控单元 */</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">perf_event_state</span><span class="w">   </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic64_t</span><span class="w">              </span><span class="n">count</span><span class="p">;</span><span class="w">          </span><span class="cm">/* 事件计数 */</span>
<span class="w">    </span><span class="n">atomic64_t</span><span class="w">              </span><span class="n">child_count</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event_attr</span><span class="w">  </span><span class="n">attr</span><span class="p">;</span><span class="w">           </span><span class="cm">/* 用户配置 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w">                     </span><span class="n">hw_event</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 硬件事件配置 */</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_sample_data</span><span class="w"> </span><span class="n">sample_data</span><span class="p">;</span><span class="w">    </span><span class="cm">/* 采样数据 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ring_buffer</span><span class="w">      </span><span class="o">*</span><span class="n">rb</span><span class="p">;</span><span class="w">            </span><span class="cm">/* 环形缓冲区 */</span>

<span class="w">    </span><span class="cm">/* 回调函数 */</span>
<span class="w">    </span><span class="n">perf_overflow_handler_t</span><span class="w"> </span><span class="n">overflow_handler</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event_context</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* 性能监控单元抽象 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pmu</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w">        </span><span class="n">entry</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">              </span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">                     </span><span class="n">type</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* PMU 操作接口 */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pmu_enable</span><span class="p">)</span><span class="w">      </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pmu</span><span class="w"> </span><span class="o">*</span><span class="n">pmu</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pmu_disable</span><span class="p">)</span><span class="w">     </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pmu</span><span class="w"> </span><span class="o">*</span><span class="n">pmu</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">event_init</span><span class="p">)</span><span class="w">      </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">)</span><span class="w">             </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">del</span><span class="p">)</span><span class="w">             </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)</span><span class="w">           </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)</span><span class="w">            </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span><span class="w">            </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="1522-pmu">15.2.2 硬件性能监控单元（PMU）</h3>
<p>现代处理器提供专门的硬件计数器来统计各种微架构事件，如缓存命中/未命中、分支预测、指令执行等。</p>
<p><strong>Intel PMU 架构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* arch/x86/events/intel/core.c */</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">event_constraint</span><span class="w"> </span><span class="n">intel_core_event_constraints</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">INTEL_EVENT_CONSTRAINT</span><span class="p">(</span><span class="mh">0x11</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2</span><span class="p">),</span><span class="w">  </span><span class="cm">/* FP_ASSIST */</span>
<span class="w">    </span><span class="n">INTEL_EVENT_CONSTRAINT</span><span class="p">(</span><span class="mh">0x12</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2</span><span class="p">),</span><span class="w">  </span><span class="cm">/* MUL */</span>
<span class="w">    </span><span class="n">INTEL_EVENT_CONSTRAINT</span><span class="p">(</span><span class="mh">0x13</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2</span><span class="p">),</span><span class="w">  </span><span class="cm">/* DIV */</span>
<span class="w">    </span><span class="n">INTEL_EVENT_CONSTRAINT</span><span class="p">(</span><span class="mh">0x14</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span><span class="p">),</span><span class="w">  </span><span class="cm">/* CYCLES_DIV_BUSY */</span>
<span class="w">    </span><span class="n">INTEL_EVENT_CONSTRAINT</span><span class="p">(</span><span class="mh">0x19</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2</span><span class="p">),</span><span class="w">  </span><span class="cm">/* DELAYED_BYPASS */</span>
<span class="p">};</span>

<span class="cm">/* 通用性能计数器配置 */</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_EVENT    0x000000FFULL</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_UMASK    0x0000FF00ULL</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_USR       (1ULL &lt;&lt; 16)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_OS        (1ULL &lt;&lt; 17)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_EDGE      (1ULL &lt;&lt; 18)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_INT       (1ULL &lt;&lt; 20)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_ENABLE    (1ULL &lt;&lt; 22)</span>
</code></pre></div>

<p><strong>硬件事件映射</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 通用硬件事件到具体 CPU 事件的映射 */</span>
<span class="k">static</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="nf">intel_pmu_event_map</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">hw_event</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">hw_event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PERF_COUNT_HW_CPU_CYCLES</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mh">0x003c</span><span class="p">;</span><span class="w">  </span><span class="cm">/* UNHALTED_CORE_CYCLES */</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PERF_COUNT_HW_INSTRUCTIONS</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mh">0x00c0</span><span class="p">;</span><span class="w">  </span><span class="cm">/* INST_RETIRED.ANY_P */</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PERF_COUNT_HW_CACHE_REFERENCES</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mh">0x4f2e</span><span class="p">;</span><span class="w">  </span><span class="cm">/* LLC Reference */</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PERF_COUNT_HW_CACHE_MISSES</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mh">0x412e</span><span class="p">;</span><span class="w">  </span><span class="cm">/* LLC Misses */</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PERF_COUNT_HW_BRANCH_INSTRUCTIONS</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mh">0x00c4</span><span class="p">;</span><span class="w">  </span><span class="cm">/* BR_INST_RETIRED.ALL_BRANCHES */</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PERF_COUNT_HW_BRANCH_MISSES</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mh">0x00c5</span><span class="p">;</span><span class="w">  </span><span class="cm">/* BR_MISP_RETIRED.ALL_BRANCHES */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>PMU 中断处理</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 性能计数器溢出中断处理 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">intel_pmu_handle_irq</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpu_hw_events</span><span class="w"> </span><span class="o">*</span><span class="n">cpuc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_hw_events</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">bit</span><span class="p">,</span><span class="w"> </span><span class="n">loops</span><span class="p">;</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 读取溢出状态 */</span>
<span class="w">    </span><span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_CORE_PERF_GLOBAL_STATUS</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">);</span>

<span class="w">    </span><span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">X86_PMC_IDX_MAX</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">bit</span><span class="p">];</span>

<span class="w">        </span><span class="cm">/* 处理溢出 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">intel_pmu_save_and_restart</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* 生成采样数据 */</span>
<span class="w">        </span><span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* 调用溢出处理器 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">perf_event_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">regs</span><span class="p">))</span>
<span class="w">            </span><span class="n">x86_pmu_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 清除溢出状态 */</span>
<span class="w">    </span><span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_CORE_PERF_GLOBAL_OVF_CTRL</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1523">15.2.3 软件事件与跟踪点</h3>
<p>除了硬件计数器，perf_events 还支持纯软件事件和跟踪点事件。</p>
<p><strong>软件事件类型</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="n">perf_sw_ids</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_CPU_CLOCK</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_TASK_CLOCK</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_PAGE_FAULTS</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_CONTEXT_SWITCHES</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_CPU_MIGRATIONS</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_PAGE_FAULTS_MIN</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_PAGE_FAULTS_MAJ</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_ALIGNMENT_FAULTS</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">    </span><span class="n">PERF_COUNT_SW_EMULATION_FAULTS</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* 软件事件触发 */</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">perf_sw_event</span><span class="p">(</span><span class="n">u32</span><span class="w"> </span><span class="n">event_id</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">static_key_false</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_swevent_enabled</span><span class="p">[</span><span class="n">event_id</span><span class="p">]))</span>
<span class="w">        </span><span class="n">__perf_sw_event</span><span class="p">(</span><span class="n">event_id</span><span class="p">,</span><span class="w"> </span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>跟踪点集成</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 将跟踪点事件连接到 perf */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">perf_trace_event_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">trace_event_call</span><span class="w"> </span><span class="o">*</span><span class="n">tp_event</span><span class="p">;</span>

<span class="w">    </span><span class="n">tp_event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event</span><span class="o">-&gt;</span><span class="n">tp_event</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tp_event</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 注册跟踪点处理器 */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">perf_trace_event_reg</span><span class="p">(</span><span class="n">tp_event</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1524">15.2.4 性能数据采集与分析</h3>
<p><strong>采样机制</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 周期性采样配置 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">perf_event_attr</span><span class="w"> </span><span class="n">attr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">type</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">PERF_TYPE_HARDWARE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">config</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">PERF_COUNT_HW_CPU_CYCLES</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">sample_period</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 每 100000 个周期采样一次 */</span>
<span class="w">    </span><span class="p">.</span><span class="n">sample_type</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">PERF_SAMPLE_IP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PERF_SAMPLE_TID</span><span class="w"> </span><span class="o">|</span>
<span class="w">                      </span><span class="n">PERF_SAMPLE_TIME</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PERF_SAMPLE_CALLCHAIN</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">exclude_kernel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">exclude_user</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>环形缓冲区管理</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* kernel/events/ring_buffer.c */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ring_buffer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w">                </span><span class="n">poll</span><span class="p">;</span>
<span class="w">    </span><span class="n">local_t</span><span class="w">                 </span><span class="n">head</span><span class="p">;</span><span class="w">          </span><span class="cm">/* 写入位置 */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">           </span><span class="n">nest</span><span class="p">;</span>
<span class="w">    </span><span class="n">local_t</span><span class="w">                 </span><span class="n">events</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">           </span><span class="n">wakeup_stamp</span><span class="p">;</span>
<span class="w">    </span><span class="n">local_t</span><span class="w">                 </span><span class="n">lost</span><span class="p">;</span>

<span class="w">    </span><span class="kt">long</span><span class="w">                    </span><span class="n">watermark</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w">                    </span><span class="n">aux_watermark</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event_mmap_page</span><span class="w"> </span><span class="o">*</span><span class="n">user_page</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 用户映射页 */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">                    </span><span class="o">*</span><span class="n">data_pages</span><span class="p">[];</span><span class="w">    </span><span class="cm">/* 数据页数组 */</span>
<span class="p">};</span>

<span class="cm">/* 写入采样数据 */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">perf_output_sample</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_output_handle</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                        </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event_header</span><span class="w"> </span><span class="o">*</span><span class="n">header</span><span class="p">,</span>
<span class="w">                        </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_sample_data</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span>
<span class="w">                        </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* 写入采样头 */</span>
<span class="w">    </span><span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">header</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 写入 IP */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sample_type</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PERF_SAMPLE_IP</span><span class="p">)</span>
<span class="w">        </span><span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 写入 TID */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sample_type</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PERF_SAMPLE_TID</span><span class="p">)</span>
<span class="w">        </span><span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">tid_entry</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 写入调用栈 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sample_type</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PERF_SAMPLE_CALLCHAIN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>
<span class="w">        </span><span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
<span class="w">        </span><span class="n">perf_output_copy</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="o">-&gt;</span><span class="n">ips</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>使用 perf 工具</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># CPU 性能分析</span>
perf<span class="w"> </span>record<span class="w"> </span>-F<span class="w"> </span><span class="m">99</span><span class="w"> </span>-a<span class="w"> </span>-g<span class="w"> </span>--<span class="w"> </span>sleep<span class="w"> </span><span class="m">10</span>
perf<span class="w"> </span>report

<span class="c1"># 缓存分析</span>
perf<span class="w"> </span>stat<span class="w"> </span>-e<span class="w"> </span>cache-references,cache-misses<span class="w"> </span>./program

<span class="c1"># 调度延迟分析</span>
perf<span class="w"> </span>sched<span class="w"> </span>record<span class="w"> </span>sleep<span class="w"> </span><span class="m">10</span>
perf<span class="w"> </span>sched<span class="w"> </span>latency

<span class="c1"># 锁竞争分析</span>
perf<span class="w"> </span>lock<span class="w"> </span>record<span class="w"> </span>./program
perf<span class="w"> </span>lock<span class="w"> </span>report
</code></pre></div>

<h2 id="153">15.3 内核调试技术</h2>
<p>内核调试是系统开发中最具挑战性的任务之一。与用户空间程序不同，内核运行在特权级别，一个错误就可能导致系统崩溃。Linux 提供了从源码级调试到崩溃分析的完整工具链。</p>
<h3 id="1531-kgdb">15.3.1 KGDB 内核调试器</h3>
<p>KGDB 是 Linux 内核的源码级调试器，通过串口或网络连接远程 GDB，实现对运行中内核的调试。它由 Jason Wessel 维护，从 2.6.26 版本开始进入主线。</p>
<p><strong>架构设计</strong></p>
<p>KGDB 采用客户端-服务器架构，内核作为调试存根（stub），外部 GDB 作为调试器：</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="err">开发机器</span><span class="w">                     </span><span class="err">目标机器</span>
<span class="w">    </span><span class="o">+-------+</span><span class="w">                   </span><span class="o">+--------+</span>
<span class="w">    </span><span class="o">|</span><span class="w">  </span><span class="n">GDB</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;---</span><span class="w"> </span><span class="err">串口</span><span class="o">/</span><span class="err">网络</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">KGDB</span><span class="w">  </span><span class="o">|</span>
<span class="w">    </span><span class="o">+-------+</span><span class="w">                   </span><span class="o">|</span><span class="w"> </span><span class="n">Kernel</span><span class="w"> </span><span class="o">|</span>
<span class="w">        </span><span class="o">|</span><span class="w">                       </span><span class="o">+--------+</span>
<span class="w">        </span><span class="n">v</span><span class="w">                           </span><span class="o">|</span>
<span class="w">    </span><span class="err">源码符号</span><span class="w">                     </span><span class="err">断点</span><span class="o">/</span><span class="err">单步</span>
</code></pre></div>

<p><strong>核心组件</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* kernel/debug/debug_core.c */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">kgdb_state</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w">                     </span><span class="n">cpu</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">                     </span><span class="n">pass_exception</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">           </span><span class="n">threadid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w">                    </span><span class="n">kgdb_usethreadid</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w">          </span><span class="o">*</span><span class="n">linux_regs</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w">                </span><span class="o">*</span><span class="n">send_ready</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* KGDB 架构接口 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">kgdb_arch</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">           </span><span class="n">gdb_bpt_instr</span><span class="p">[</span><span class="n">BREAK_INSTR_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">           </span><span class="n">flags</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">set_breakpoint</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">saved_instr</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">remove_breakpoint</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">bundle</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">set_hw_breakpoint</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">kgdb_bptype</span><span class="w"> </span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">remove_hw_breakpoint</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">kgdb_bptype</span><span class="w"> </span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">disable_hw_break</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">correct_hw_break</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">enable_nmi</span><span class="p">)(</span><span class="kt">bool</span><span class="w"> </span><span class="n">on</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>断点实现机制</strong></p>
<p>KGDB 支持软件断点和硬件断点：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 软件断点：替换指令为 int3 (x86) */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">kgdb_arch_set_breakpoint</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kgdb_bkpt</span><span class="w"> </span><span class="o">*</span><span class="n">bpt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">opc</span><span class="p">[</span><span class="n">BREAK_INSTR_SIZE</span><span class="p">];</span>

<span class="w">    </span><span class="cm">/* 保存原始指令 */</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">probe_kernel_read</span><span class="p">(</span><span class="n">opc</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">bpt</span><span class="o">-&gt;</span><span class="n">bpt_addr</span><span class="p">,</span><span class="w"> </span><span class="n">BREAK_INSTR_SIZE</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">bpt</span><span class="o">-&gt;</span><span class="n">saved_instr</span><span class="p">,</span><span class="w"> </span><span class="n">opc</span><span class="p">,</span><span class="w"> </span><span class="n">BREAK_INSTR_SIZE</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 写入断点指令 */</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">probe_kernel_write</span><span class="p">((</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">bpt</span><span class="o">-&gt;</span><span class="n">bpt_addr</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="n">arch_kgdb_ops</span><span class="p">.</span><span class="n">gdb_bpt_instr</span><span class="p">,</span><span class="w"> </span><span class="n">BREAK_INSTR_SIZE</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 硬件断点：使用 CPU 调试寄存器 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hw_break_reserve_slot</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">breakno</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">perf_event</span><span class="w"> </span><span class="o">**</span><span class="n">pevent</span><span class="p">;</span>

<span class="w">    </span><span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pevent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">breakinfo</span><span class="p">[</span><span class="n">breakno</span><span class="p">].</span><span class="n">pev</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">);</span>
<span class="w">        </span><span class="o">*</span><span class="n">pevent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">register_wide_hw_breakpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">pevent</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">pevent</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>异常处理流程</strong></p>
<p>当触发断点或收到调试信号时，KGDB 接管系统：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 进入 KGDB 的核心函数 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">kgdb_cpu_enter</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kgdb_state</span><span class="w"> </span><span class="o">*</span><span class="n">ks</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">int</span><span class="w"> </span><span class="n">exception_state</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw_smp_processor_id</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* 1. 停止其他 CPU */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">kgdb_single_step</span><span class="p">)</span>
<span class="w">        </span><span class="n">kgdb_roundup_cpus</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 2. 禁用中断 */</span>
<span class="w">    </span><span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 3. 进入调试循环 */</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* 等待 GDB 命令 */</span>
<span class="w">        </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gdb_serial_stub</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DBG_PASS_EVENT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* 继续执行 */</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* 处理命令 */</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">gdb_cmd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">:</span><span class="w">  </span><span class="cm">/* continue */</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;s&#39;</span><span class="p">:</span><span class="w">  </span><span class="cm">/* single step */</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 4. 恢复执行 */</span>
<span class="w">    </span><span class="n">kgdb_restore_cpus</span><span class="p">();</span>
<span class="w">    </span><span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>使用配置</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 内核配置</span>
<span class="nv">CONFIG_KGDB</span><span class="o">=</span>y
<span class="nv">CONFIG_KGDB_SERIAL_CONSOLE</span><span class="o">=</span>y
<span class="nv">CONFIG_KGDB_KDB</span><span class="o">=</span>y

<span class="c1"># 启动参数</span>
<span class="nv">kgdboc</span><span class="o">=</span>ttyS0,115200<span class="w"> </span>kgdbwait

<span class="c1"># GDB 连接</span>
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>target<span class="w"> </span>remote<span class="w"> </span>/dev/ttyS0
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>debug<span class="w"> </span>remote<span class="w"> </span><span class="m">1</span>
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span><span class="k">break</span><span class="w"> </span>sys_open
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span><span class="k">continue</span>
</code></pre></div>

<h3 id="1532-crash">15.3.2 crash 工具与内核转储</h3>
<p>crash 是 Red Hat 开发的内核崩溃分析工具，由 Dave Anderson 维护。它可以分析运行中的系统或崩溃转储文件（vmcore）。</p>
<p><strong>工作原理</strong></p>
<p>crash 通过解析内核符号表和数据结构，提供类似 GDB 的调试接口：</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="n">vmcore</span><span class="o">/</span><span class="n">live</span><span class="w"> </span><span class="n">system</span>
<span class="w">           </span><span class="o">|</span>
<span class="w">    </span><span class="o">+------</span><span class="n">v</span><span class="o">------+</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">crash</span><span class="w"> </span><span class="k">tool</span><span class="w">  </span><span class="o">|</span>
<span class="w">    </span><span class="o">+-------------+</span>
<span class="w">           </span><span class="o">|</span>
<span class="w">    </span><span class="err">解析内核结构</span>
<span class="w">           </span><span class="o">|</span>
<span class="w">    </span><span class="o">+------</span><span class="n">v</span><span class="o">------+</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="err">符号表</span><span class="w">      </span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">debuginfo</span><span class="w">   </span><span class="o">|</span>
<span class="w">    </span><span class="o">+-------------+</span>
</code></pre></div>

<p><strong>核心功能实现</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* crash 内部数据结构解析 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">task_context</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">task</span><span class="p">;</span><span class="w">           </span><span class="cm">/* task_struct 地址 */</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">thread_info</span><span class="p">;</span><span class="w">    </span><span class="cm">/* thread_info 地址 */</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">processor</span><span class="p">;</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">ptask</span><span class="p">;</span><span class="w">          </span><span class="cm">/* 父进程 */</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">mm_struct</span><span class="p">;</span><span class="w">      </span><span class="cm">/* 内存描述符 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_context</span><span class="w"> </span><span class="o">*</span><span class="n">tc_next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* 读取内核内存 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">readmem</span><span class="p">(</span><span class="n">ulonglong</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">memtype</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span>
<span class="w">                   </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ulong</span><span class="w"> </span><span class="n">error_handle</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">memtype</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">KVADDR</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* 内核虚拟地址 */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">read_kdump</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PHYSADDR</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* 物理地址 */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">read_physmem</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">FILEADDR</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* 文件偏移 */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">read_vmcore</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>常用命令实现</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* bt - 显示调用栈 */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">cmd_bt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bt_info</span><span class="w"> </span><span class="n">bt_info</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">bt</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_context</span><span class="w"> </span><span class="o">*</span><span class="n">tc</span><span class="p">;</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 获取当前任务上下文 */</span>
<span class="w">    </span><span class="n">tc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CURRENT_CONTEXT</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* 初始化栈帧信息 */</span>
<span class="w">    </span><span class="n">bt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bt_info</span><span class="p">;</span>
<span class="w">    </span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
<span class="w">    </span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">stackbase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GET_STACKBASE</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 展开调用栈 */</span>
<span class="w">    </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">thread_info</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">OFFSET</span><span class="p">(</span><span class="n">thread_info_cpu_context</span><span class="p">);</span>
<span class="w">    </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GET_PC</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">stackbase</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* 解析栈帧 */</span>
<span class="w">        </span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GET_FRAME_POINTER</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="w">        </span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">closest_symbol</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;#%d [%016lx] %s at %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">                </span><span class="n">level</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">ip</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* 下一帧 */</span>
<span class="w">        </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame</span><span class="p">;</span>
<span class="w">        </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GET_RETURN_ADDRESS</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>使用示例</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 分析 vmcore</span>
crash<span class="w"> </span>/usr/lib/debug/lib/modules/<span class="k">$(</span>uname<span class="w"> </span>-r<span class="k">)</span>/vmlinux<span class="w"> </span>/var/crash/vmcore

<span class="c1"># 常用命令</span>
crash&gt;<span class="w"> </span>sys<span class="w">          </span><span class="c1"># 系统信息</span>
crash&gt;<span class="w"> </span>bt<span class="w">           </span><span class="c1"># 当前任务调用栈</span>
crash&gt;<span class="w"> </span>ps<span class="w">           </span><span class="c1"># 进程列表</span>
crash&gt;<span class="w"> </span>log<span class="w">          </span><span class="c1"># 内核日志</span>
crash&gt;<span class="w"> </span>dis<span class="w"> </span>-l<span class="w"> </span>function_name<span class="w">  </span><span class="c1"># 反汇编</span>
crash&gt;<span class="w"> </span>struct<span class="w"> </span>task_struct<span class="w"> </span>ffff88007c8a0000<span class="w">  </span><span class="c1"># 查看数据结构</span>
crash&gt;<span class="w"> </span>foreach<span class="w"> </span>bt<span class="w">   </span><span class="c1"># 所有任务的调用栈</span>
</code></pre></div>

<h3 id="1533-kdump">15.3.3 kdump 机制</h3>
<p>kdump 是 Linux 的内核崩溃转储机制，使用 kexec 在系统崩溃时启动第二个内核来收集转储。</p>
<p><strong>工作流程</strong></p>
<div class="codehilite"><pre><span></span><code>    生产内核崩溃
         |
         v
    触发 panic()
         |
         v
    machine_kexec()
         |
         v
    加载捕获内核
         |
         v
    捕获内核启动
         |
         v
    收集 vmcore
         |
         v
    保存到磁盘
</code></pre></div>

<p><strong>实现机制</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* kernel/kexec_core.c */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__crash_kexec</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* 已经有 CPU 在处理 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">kexec_crash_image</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="n">fixed_regs</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* 保存崩溃时的寄存器 */</span>
<span class="w">            </span><span class="n">crash_setup_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fixed_regs</span><span class="p">,</span><span class="w"> </span><span class="n">regs</span><span class="p">);</span>
<span class="w">            </span><span class="n">crash_save_vmcoreinfo</span><span class="p">();</span>

<span class="w">            </span><span class="cm">/* 关闭其他 CPU */</span>
<span class="w">            </span><span class="n">machine_crash_shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fixed_regs</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* 跳转到捕获内核 */</span>
<span class="w">            </span><span class="n">machine_kexec</span><span class="p">(</span><span class="n">kexec_crash_image</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 保留内存区域 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">reserve_crashkernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">crash_size</span><span class="p">,</span><span class="w"> </span><span class="n">crash_base</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 解析 crashkernel= 参数 */</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_crashkernel</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">,</span><span class="w"> </span><span class="n">memblock_phys_mem_size</span><span class="p">(),</span>
<span class="w">                           </span><span class="o">&amp;</span><span class="n">crash_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">crash_base</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 预留内存 */</span>
<span class="w">    </span><span class="n">memblock_reserve</span><span class="p">(</span><span class="n">crash_base</span><span class="p">,</span><span class="w"> </span><span class="n">crash_size</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 设置全局变量 */</span>
<span class="w">    </span><span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crash_base</span><span class="p">;</span>
<span class="w">    </span><span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crash_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">crash_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>vmcore 生成</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* fs/proc/vmcore.c */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">vmcore_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 解析 ELF 头 */</span>
<span class="w">    </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_crash_elf_headers</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 创建 /proc/vmcore */</span>
<span class="w">    </span><span class="n">proc_vmcore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;vmcore&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">S_IRUSR</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proc_vmcore_operations</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 读取 vmcore */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">read_vmcore</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buflen</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="n">fpos</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* 读取 ELF 头 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fpos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">elfcorebuf_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tsz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">elfcorebuf_sz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">*</span><span class="n">fpos</span><span class="p">,</span><span class="w"> </span><span class="n">buflen</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">elfcorebuf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">fpos</span><span class="p">,</span><span class="w"> </span><span class="n">tsz</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 读取程序段 */</span>
<span class="w">    </span><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vmcore_list</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fpos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">tsz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">fpos</span><span class="p">,</span><span class="w"> </span><span class="n">buflen</span><span class="p">);</span>
<span class="w">            </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fpos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* 拷贝物理内存 */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_oldmem_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">tsz</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">))</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>配置使用</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 安装 kdump 工具</span>
yum<span class="w"> </span>install<span class="w"> </span>kexec-tools

<span class="c1"># 配置预留内存</span>
<span class="c1"># /etc/default/grub</span>
<span class="nv">GRUB_CMDLINE_LINUX</span><span class="o">=</span><span class="s2">&quot;crashkernel=256M&quot;</span>

<span class="c1"># 启动 kdump 服务</span>
systemctl<span class="w"> </span><span class="nb">enable</span><span class="w"> </span>kdump
systemctl<span class="w"> </span>start<span class="w"> </span>kdump

<span class="c1"># 测试崩溃</span>
<span class="nb">echo</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>&gt;<span class="w"> </span>/proc/sys/kernel/sysrq
<span class="nb">echo</span><span class="w"> </span>c<span class="w"> </span>&gt;<span class="w"> </span>/proc/sysrq-trigger
</code></pre></div>

<h3 id="1534-pr_debug">15.3.4 动态打印与 pr_debug</h3>
<p>动态调试（dynamic debug）允许在运行时控制调试信息的输出，无需重新编译内核。</p>
<p><strong>实现原理</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* include/linux/dynamic_debug.h */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">_ddebug</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">modname</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">function</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineno</span><span class="o">:</span><span class="mi">18</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cm">/* pr_debug 宏展开 */</span>
<span class="cp">#define pr_debug(fmt, ...)                                      \</span>
<span class="cp">    dynamic_pr_debug(fmt, ##__VA_ARGS__)</span>

<span class="cp">#define dynamic_pr_debug(fmt, ...)                              \</span>
<span class="cp">do {                                                            \</span>
<span class="cp">    DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);             \</span>
<span class="cp">    if (DYNAMIC_DEBUG_BRANCH(descriptor))                       \</span>
<span class="cp">        __dynamic_pr_debug(&amp;descriptor, pr_fmt(fmt),           \</span>
<span class="cp">                          ##__VA_ARGS__);                       \</span>
<span class="cp">} while (0)</span>
</code></pre></div>

<p><strong>控制接口</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* lib/dynamic_debug.c */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ddebug_proc_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="n">offp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">words</span><span class="p">[</span><span class="n">MAXWORDS</span><span class="p">];</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ddebug_query</span><span class="w"> </span><span class="n">query</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 解析控制命令 */</span>
<span class="w">    </span><span class="n">nwords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ddebug_tokenize</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">,</span><span class="w"> </span><span class="n">words</span><span class="p">,</span><span class="w"> </span><span class="n">MAXWORDS</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 解析查询条件 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ddebug_parse_query</span><span class="p">(</span><span class="n">words</span><span class="p">,</span><span class="w"> </span><span class="n">nwords</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 应用修改 */</span>
<span class="w">    </span><span class="n">nfound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ddebug_change</span><span class="p">(</span><span class="o">&amp;</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 修改调试标志 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ddebug_change</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ddebug_query</span><span class="w"> </span><span class="o">*</span><span class="n">query</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ddebug_table</span><span class="w"> </span><span class="o">*</span><span class="n">dt</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">_ddebug</span><span class="w"> </span><span class="o">*</span><span class="n">dp</span><span class="p">;</span>

<span class="w">    </span><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ddebug_tables</span><span class="p">,</span><span class="w"> </span><span class="n">link</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">ddebugs</span><span class="p">;</span><span class="w"> </span><span class="n">dp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">ddebugs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">num_ddebugs</span><span class="p">;</span><span class="w"> </span><span class="n">dp</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* 匹配查询条件 */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">match_wildcard</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">))</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">match_wildcard</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">))</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">match_wildcard</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">))</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/* 更新标志 */</span>
<span class="w">            </span><span class="n">newflags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">newflags</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newflags</span><span class="p">;</span>
<span class="w">                </span><span class="n">matched</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">matched</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>使用方法</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 启用特定文件的调试</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;file tcp_input.c +p&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/dynamic_debug/control

<span class="c1"># 启用特定函数</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;func tcp_receive_skb +p&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/dynamic_debug/control

<span class="c1"># 启用模块调试</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;module e1000e +p&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/dynamic_debug/control

<span class="c1"># 查看当前设置</span>
cat<span class="w"> </span>/sys/kernel/debug/dynamic_debug/control

<span class="c1"># 带条件的调试</span>
<span class="nb">echo</span><span class="w"> </span><span class="s1">&#39;file drivers/net/* line 1-200 +p&#39;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/kernel/debug/dynamic_debug/control
</code></pre></div>

<h2 id="154">15.4 动态追踪工具</h2>
<p>动态追踪技术让我们能够在生产环境中安全地观测系统行为，无需停机或重新编译。从 SystemTap 到 eBPF 的演进，标志着 Linux 可观测性的革命性进步。</p>
<h3 id="1541-systemtap">15.4.1 SystemTap 框架</h3>
<p>SystemTap 是 Red Hat 开发的动态追踪系统，通过将高级脚本语言编译成内核模块来实现系统追踪。尽管现在 eBPF 更受欢迎，但 SystemTap 仍在许多企业环境中使用。</p>
<p><strong>架构概览</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c">    SystemTap 脚本 (</span><span class="nt">.</span><span class="c">stp)</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    |   stap 编译器|  </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> 语法分析、语义检查</span>
<span class="c">    </span><span class="nb">+------+------+</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    | C 代码生成   |  </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> 生成内核模块源码</span>
<span class="c">    </span><span class="nb">+------+------+</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    |  gcc 编译    |  </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> 编译成 </span><span class="nt">.</span><span class="c">ko 模块</span>
<span class="c">    </span><span class="nb">+------+------+</span>
<span class="c">           |</span>
<span class="c">    </span><span class="nb">+------</span><span class="c">v</span><span class="nb">------+</span>
<span class="c">    | staprun 加载 |  </span><span class="nv">&lt;</span><span class="nb">-</span><span class="c"> 插入内核执行</span>
<span class="c">    </span><span class="nb">+------+------+</span>
<span class="c">           |</span>
<span class="c">    运行时数据收集</span>
</code></pre></div>

<p><strong>脚本语言特性</strong></p>
<div class="codehilite"><pre><span></span><code><span class="o">/*</span><span class="w"> </span><span class="n">SystemTap</span><span class="w"> </span>脚本示例<span class="w"> </span><span class="o">*/</span>
<span class="k">global</span><span class="w"> </span><span class="n">reads</span>

<span class="n">probe</span><span class="w"> </span><span class="n">vfs</span><span class="p">.</span><span class="nb">read</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">reads</span><span class="p">[</span><span class="n">execname</span><span class="p">(),</span><span class="w"> </span><span class="n">pid</span><span class="p">()]</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="no">$</span><span class="n">count</span>
<span class="p">}</span>

<span class="n">probe</span><span class="w"> </span><span class="nb">timer</span><span class="p">.</span><span class="n">s</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">printf</span><span class="p">(</span><span class="s">&quot;Top processes reading:\n&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">foreach</span><span class="w"> </span><span class="p">([</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">]</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">reads</span><span class="o">-</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">printf</span><span class="p">(</span><span class="s">&quot;%s[%d]: %d bytes\n&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">               </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="p">@</span><span class="nb">sum</span><span class="p">(</span><span class="n">reads</span><span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">]))</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nb">delete</span><span class="w"> </span><span class="n">reads</span>
<span class="p">}</span>

<span class="o">/*</span><span class="w"> </span>探针语法<span class="w"> </span><span class="o">*/</span>
<span class="n">probe</span><span class="w"> </span><span class="nb">kernel</span><span class="p">.</span><span class="k">function</span><span class="p">(</span><span class="s">&quot;tcp_sendmsg&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">printf</span><span class="p">(</span><span class="s">&quot;TCP send from %s: %d bytes\n&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">           </span><span class="n">execname</span><span class="p">(),</span><span class="w"> </span><span class="no">$</span><span class="nb">size</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">probe</span><span class="w"> </span><span class="nb">kernel</span><span class="p">.</span><span class="k">function</span><span class="p">(</span><span class="s">&quot;tcp_sendmsg&quot;</span><span class="p">).</span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="no">$</span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="nb">printf</span><span class="p">(</span><span class="s">&quot;TCP send failed: %d\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="no">$</span><span class="k">return</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>运行时实现</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* runtime/transport/transport.c */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">_stp_transport_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* 创建 relayfs 通道 */</span>
<span class="w">    </span><span class="n">_stp_relay_data</span><span class="p">.</span><span class="n">rchan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">relay_open</span><span class="p">(</span><span class="s">&quot;trace&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                       </span><span class="n">_stp_get_module_dir</span><span class="p">(),</span>
<span class="w">                                       </span><span class="n">_stp_bufsize</span><span class="p">,</span>
<span class="w">                                       </span><span class="n">n_subbufs</span><span class="p">,</span>
<span class="w">                                       </span><span class="o">&amp;</span><span class="n">_stp_relay_callbacks</span><span class="p">,</span>
<span class="w">                                       </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 注册探针 */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">_stp_num_probes</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">stap_probe</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_stp_probes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">register_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kprobe</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 探针处理器模板 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">probe_NNNN</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kprobe</span><span class="w"> </span><span class="o">*</span><span class="n">inst</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">context</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">contexts</span><span class="p">,</span><span class="w"> </span><span class="n">smp_processor_id</span><span class="p">());</span>

<span class="w">    </span><span class="cm">/* 获取上下文 */</span>
<span class="w">    </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regs</span><span class="p">;</span>
<span class="w">    </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inst</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 执行用户脚本逻辑 */</span>
<span class="w">    </span><span class="n">probe_NNNN_enter</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 输出数据 */</span>
<span class="w">    </span><span class="n">_stp_print_flush</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1542-ebpf">15.4.2 eBPF 架构与原理</h3>
<p>eBPF（extended Berkeley Packet Filter）是 Linux 内核的革命性技术，提供了安全、高效的内核可编程能力。由 Alexei Starovoitov 主导开发，已成为云原生可观测性的基石。</p>
<p><strong>eBPF 架构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span>用户空间<span class="w">                     </span>内核空间
<span class="w">    </span><span class="o">+--------+</span><span class="w">                </span><span class="o">+------------+</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">eBPF</span><span class="w">   </span><span class="o">|</span><span class="w">                </span><span class="o">|</span><span class="w"> </span><span class="n">eBPF</span><span class="w"> </span>程序<span class="w">  </span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span>程序<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="nf">bpf</span><span class="p">()</span><span class="w"> </span><span class="o">--&gt;</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="p">(</span>字节码<span class="p">)</span><span class="w">   </span><span class="o">|</span>
<span class="w">    </span><span class="o">+--------+</span><span class="w">                </span><span class="o">+-----+------+</span>
<span class="w">                                   </span><span class="o">|</span>
<span class="w">                              </span><span class="o">+----</span><span class="n">v</span><span class="o">-----+</span>
<span class="w">                              </span><span class="o">|</span><span class="w"> </span><span class="n">Verifier</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span>安全验证
<span class="w">                              </span><span class="o">+----+-----+</span>
<span class="w">                                   </span><span class="o">|</span>
<span class="w">                              </span><span class="o">+----</span><span class="n">v</span><span class="o">-----+</span>
<span class="w">                              </span><span class="o">|</span><span class="w"> </span><span class="n">JIT</span><span class="w"> </span>编译<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span>编译成机器码
<span class="w">                              </span><span class="o">+----+-----+</span>
<span class="w">                                   </span><span class="o">|</span>
<span class="w">                              </span><span class="o">+----</span><span class="n">v</span><span class="o">-----+</span>
<span class="w">                              </span><span class="o">|</span><span class="w"> </span>执行引擎<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span>在钩子点执行
<span class="w">                              </span><span class="o">+----------+</span>
</code></pre></div>

<p><strong>eBPF 指令集</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* include/uapi/linux/bpf.h */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpf_insn</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">    </span><span class="n">code</span><span class="p">;</span><span class="w">    </span><span class="cm">/* 操作码 */</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">    </span><span class="n">dst_reg</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 目标寄存器 */</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">    </span><span class="n">src_reg</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 源寄存器 */</span>
<span class="w">    </span><span class="n">__s16</span><span class="w">   </span><span class="n">off</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 偏移 */</span>
<span class="w">    </span><span class="n">__s32</span><span class="w">   </span><span class="n">imm</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 立即数 */</span>
<span class="p">};</span>

<span class="cm">/* eBPF 寄存器 */</span>
<span class="cp">#define BPF_REG_0   0   </span><span class="cm">/* 返回值 */</span>
<span class="cp">#define BPF_REG_1   1   </span><span class="cm">/* 参数 1 */</span>
<span class="cp">#define BPF_REG_2   2   </span><span class="cm">/* 参数 2 */</span>
<span class="cp">#define BPF_REG_3   3   </span><span class="cm">/* 参数 3 */</span>
<span class="cp">#define BPF_REG_4   4   </span><span class="cm">/* 参数 4 */</span>
<span class="cp">#define BPF_REG_5   5   </span><span class="cm">/* 参数 5 */</span>
<span class="cp">#define BPF_REG_6   6   </span><span class="cm">/* callee saved */</span>
<span class="cp">#define BPF_REG_7   7   </span><span class="cm">/* callee saved */</span>
<span class="cp">#define BPF_REG_8   8   </span><span class="cm">/* callee saved */</span>
<span class="cp">#define BPF_REG_9   9   </span><span class="cm">/* callee saved */</span>
<span class="cp">#define BPF_REG_10  10  </span><span class="cm">/* 栈指针 */</span>

<span class="cm">/* 指令示例 */</span>
<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_6</span><span class="p">,</span><span class="w"> </span><span class="n">BPF_REG_1</span><span class="p">),</span><span class="w">     </span><span class="cm">/* r6 = r1 */</span>
<span class="n">BPF_LD_ABS</span><span class="p">(</span><span class="n">BPF_B</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_HLEN</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">         </span><span class="cm">/* 加载字节 */</span>
<span class="n">BPF_JMP_IMM</span><span class="p">(</span><span class="n">BPF_JEQ</span><span class="p">,</span><span class="w"> </span><span class="n">BPF_REG_0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="cm">/* if r0 == 0x80 jump */</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">             </span><span class="cm">/* r0 = 0 */</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span><span class="w">                          </span><span class="cm">/* return r0 */</span>
</code></pre></div>

<p><strong>验证器（Verifier）</strong></p>
<p>eBPF 验证器确保程序安全性，防止内核崩溃：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* kernel/bpf/verifier.c */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">do_check</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_verifier_env</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_insn</span><span class="w"> </span><span class="o">*</span><span class="n">insns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">insnsi</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_verifier_state</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">insn_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 遍历所有可能的执行路径 */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">insn_cnt</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_insn</span><span class="w"> </span><span class="o">*</span><span class="n">insn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">u8</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BPF_CLASS</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* 检查内存访问 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">class</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BPF_LDX</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BPF_STX</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">check_mem_access</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">insn_idx</span><span class="p">,</span><span class="w"> </span><span class="n">regno</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">value_regno</span><span class="p">,</span><span class="w"> </span><span class="n">strict_alignment</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* 检查函数调用 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">code</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">BPF_JMP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BPF_CALL</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">check_helper_call</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">imm</span><span class="p">,</span><span class="w"> </span><span class="n">insn_idx</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* 检查跳转 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BPF_CLASS</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BPF_JMP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">check_cond_jmp_op</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">insn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">insn_idx</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 确保程序有返回 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">curframe</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">verbose</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;program didn&#39;t return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 检查内存访问安全性 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">check_mem_access</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_verifier_env</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">insn_idx</span><span class="p">,</span>
<span class="w">                           </span><span class="n">u32</span><span class="w"> </span><span class="n">regno</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bpf_size</span><span class="p">,</span>
<span class="w">                           </span><span class="k">enum</span><span class="w"> </span><span class="n">bpf_access_type</span><span class="w"> </span><span class="n">t</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">int</span><span class="w"> </span><span class="n">value_regno</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">strict_alignment</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_reg_state</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur_regs</span><span class="p">(</span><span class="n">env</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_reg_state</span><span class="w"> </span><span class="o">*</span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">regno</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 检查指针类型 */</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PTR_TO_MAP_VALUE</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* 检查 map 访问边界 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check_map_access</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">regno</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PTR_TO_CTX</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* 检查上下文访问 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check_ctx_access</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">insn_idx</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">reg_type</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PTR_TO_STACK</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* 检查栈访问 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check_stack_boundary</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">regno</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">access_type</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>JIT 编译器</strong></p>
<p>将 eBPF 字节码编译成本地机器码：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* arch/x86/net/bpf_jit_comp.c */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">do_jit</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_prog</span><span class="w"> </span><span class="o">*</span><span class="n">bpf_prog</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addrs</span><span class="p">,</span><span class="w"> </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">image</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">oldproglen</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">jit_context</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_insn</span><span class="w"> </span><span class="o">*</span><span class="n">insn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_prog</span><span class="o">-&gt;</span><span class="n">insnsi</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">insn_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_prog</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">insn_cnt</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">insn</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">s32</span><span class="w"> </span><span class="n">imm32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">imm</span><span class="p">;</span>
<span class="w">        </span><span class="n">u32</span><span class="w"> </span><span class="n">dst_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">dst_reg</span><span class="p">;</span>
<span class="w">        </span><span class="n">u32</span><span class="w"> </span><span class="n">src_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">src_reg</span><span class="p">;</span>
<span class="w">        </span><span class="n">u8</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">b3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">s64</span><span class="w"> </span><span class="n">jmp_offset</span><span class="p">;</span>
<span class="w">        </span><span class="n">u8</span><span class="w"> </span><span class="n">jmp_cond</span><span class="p">;</span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* ALU 操作 */</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">BPF_ALU64</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">BPF_ADD</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">BPF_X</span><span class="p">:</span>
<span class="w">            </span><span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="n">add_2reg</span><span class="p">(</span><span class="mh">0xC0</span><span class="p">,</span><span class="w"> </span><span class="n">dst_reg</span><span class="p">,</span><span class="w"> </span><span class="n">src_reg</span><span class="p">));</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* 内存加载 */</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">BPF_LDX</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">BPF_MEM</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">BPF_DW</span><span class="p">:</span>
<span class="w">            </span><span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span><span class="w"> </span><span class="mh">0x8B</span><span class="p">,</span><span class="w"> </span><span class="n">add_2reg</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="n">dst_reg</span><span class="p">,</span><span class="w"> </span><span class="n">src_reg</span><span class="p">));</span>
<span class="w">            </span><span class="n">EMIT1</span><span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* 函数调用 */</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">BPF_JMP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">BPF_CALL</span><span class="p">:</span>
<span class="w">            </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">__bpf_call_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">imm32</span><span class="p">;</span>
<span class="w">            </span><span class="n">jmp_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">prog</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">            </span><span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xE8</span><span class="p">,</span><span class="w"> </span><span class="n">jmp_offset</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* 条件跳转 */</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">BPF_JMP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">BPF_JEQ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">BPF_X</span><span class="p">:</span>
<span class="w">            </span><span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span><span class="w"> </span><span class="mh">0x39</span><span class="p">,</span><span class="w"> </span><span class="n">add_2reg</span><span class="p">(</span><span class="mh">0xC0</span><span class="p">,</span><span class="w"> </span><span class="n">dst_reg</span><span class="p">,</span><span class="w"> </span><span class="n">src_reg</span><span class="p">));</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">emit_cond_jmp</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>eBPF Maps</strong></p>
<p>Maps 是 eBPF 程序与用户空间通信的关键机制：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* kernel/bpf/hashtab.c */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpf_htab</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_map</span><span class="w"> </span><span class="n">map</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bucket</span><span class="w"> </span><span class="o">*</span><span class="n">buckets</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">elems</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">n_buckets</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">elem_size</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">lockdep_key</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* 查找元素 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">htab_map_lookup_elem</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_map</span><span class="w"> </span><span class="o">*</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_htab</span><span class="w"> </span><span class="o">*</span><span class="n">htab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_htab</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hlist_nulls_head</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">htab_elem</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">key_size</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 计算哈希值 */</span>
<span class="w">    </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htab_map_hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">key_size</span><span class="p">,</span><span class="w"> </span><span class="n">htab</span><span class="o">-&gt;</span><span class="n">hashrnd</span><span class="p">);</span>
<span class="w">    </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">select_bucket</span><span class="p">(</span><span class="n">htab</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 查找链表 */</span>
<span class="w">    </span><span class="n">hlist_nulls_for_each_entry_rcu</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">hash_node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">key_size</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">round_up</span><span class="p">(</span><span class="n">key_size</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1543-bpftrace">15.4.3 bpftrace 高级追踪</h3>
<p>bpftrace 是 Brendan Gregg 和 Alastair Robertson 开发的高级追踪语言，提供了类似 DTrace 的简洁语法。</p>
<p><strong>语言特性</strong></p>
<div class="codehilite"><pre><span></span><code><span class="err">#!</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">env</span><span class="w"> </span><span class="n">bpftrace</span>

<span class="cm">/* 追踪系统调用延迟 */</span>
<span class="nl">tracepoint</span><span class="p">:</span><span class="nl">raw_syscalls</span><span class="p">:</span><span class="n">sys_enter</span>
<span class="err">{</span>
<span class="w">    </span><span class="nv">@start</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsecs</span><span class="p">;</span>
<span class="err">}</span>

<span class="nl">tracepoint</span><span class="p">:</span><span class="nl">raw_syscalls</span><span class="p">:</span><span class="n">sys_exit</span>
<span class="o">/</span><span class="nv">@start</span><span class="o">[</span><span class="n">tid</span><span class="o">]/</span>
<span class="err">{</span>
<span class="w">    </span><span class="nv">@ns</span><span class="o">[</span><span class="n">comm</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hist</span><span class="p">((</span><span class="n">nsecs</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">@start</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
<span class="w">    </span><span class="k">delete</span><span class="p">(</span><span class="nv">@start</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="p">);</span>
<span class="err">}</span>

<span class="cm">/* 追踪 TCP 重传 */</span>
<span class="nl">kprobe</span><span class="p">:</span><span class="n">tcp_retransmit_skb</span>
<span class="err">{</span>
<span class="w">    </span><span class="nv">@retrans</span><span class="o">[</span><span class="n">comm, pid</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">count</span><span class="p">();</span>
<span class="err">}</span>

<span class="cm">/* 追踪块 I/O 延迟 */</span>
<span class="nl">kprobe</span><span class="p">:</span><span class="n">blk_account_io_start</span>
<span class="err">{</span>
<span class="w">    </span><span class="nv">@iotime</span><span class="o">[</span><span class="n">arg0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsecs</span><span class="p">;</span>
<span class="err">}</span>

<span class="nl">kprobe</span><span class="p">:</span><span class="n">blk_account_io_done</span>
<span class="o">/</span><span class="nv">@iotime</span><span class="o">[</span><span class="n">arg0</span><span class="o">]/</span>
<span class="err">{</span>
<span class="w">    </span><span class="nv">@usecs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hist</span><span class="p">((</span><span class="n">nsecs</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">@iotime</span><span class="o">[</span><span class="n">arg0</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
<span class="w">    </span><span class="k">delete</span><span class="p">(</span><span class="nv">@iotime</span><span class="o">[</span><span class="n">arg0</span><span class="o">]</span><span class="p">);</span>
<span class="err">}</span>

<span class="k">END</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">clear</span><span class="p">(</span><span class="nv">@iotime</span><span class="p">);</span>
<span class="w">    </span><span class="n">clear</span><span class="p">(</span><span class="nv">@start</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div>

<p><strong>内部实现</strong></p>
<p>bpftrace 将高级语言编译成 eBPF 字节码：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* AST 到 LLVM IR 的转换 */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">CodegenLLVM::visit</span><span class="p">(</span><span class="n">Call</span><span class="w"> </span><span class="o">&amp;</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">call</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;count&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 生成计数器更新代码</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">map_lookup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b_</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(</span><span class="n">lookup_func</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                        </span><span class="p">{</span><span class="n">map_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">key_ptr</span><span class="p">});</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b_</span><span class="p">.</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">map_lookup</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">incremented</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b_</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                        </span><span class="n">b_</span><span class="p">.</span><span class="n">getInt64</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="w">        </span><span class="n">b_</span><span class="p">.</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">incremented</span><span class="p">,</span><span class="w"> </span><span class="n">map_lookup</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">call</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;hist&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 生成直方图更新代码</span>
<span class="w">        </span><span class="n">generate_histogram_update</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="1544">15.4.4 性能优化案例</h3>
<p><strong>案例1：追踪内存分配热点</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* eBPF C 程序 */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;uapi/linux/ptrace.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/mm.h&gt;</span>

<span class="n">BPF_HASH</span><span class="p">(</span><span class="n">allocs</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="p">);</span>
<span class="n">BPF_STACK_TRACE</span><span class="p">(</span><span class="n">stack_traces</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">trace_kmalloc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_get_current_pid_tgid</span><span class="p">();</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">stackid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack_traces</span><span class="p">.</span><span class="n">get_stackid</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">alloc_info</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">    </span><span class="n">info</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="n">info</span><span class="p">.</span><span class="n">stackid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stackid</span><span class="p">;</span>
<span class="w">    </span><span class="n">info</span><span class="p">.</span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_ktime_get_ns</span><span class="p">();</span>

<span class="w">    </span><span class="n">allocs</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>案例2：网络延迟分析</strong></p>
<div class="codehilite"><pre><span></span><code><span class="err">#!</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">env</span><span class="w"> </span><span class="n">bpftrace</span>

<span class="cm">/* TCP 连接延迟分析 */</span>
<span class="nl">kprobe</span><span class="p">:</span><span class="n">tcp_v4_connect</span>
<span class="err">{</span>
<span class="w">    </span><span class="nv">@start</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsecs</span><span class="p">;</span>
<span class="w">    </span><span class="nv">@daddr</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">struct</span><span class="w"> </span><span class="n">sockaddr_in</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">arg1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
<span class="err">}</span>

<span class="nl">kretprobe</span><span class="p">:</span><span class="n">tcp_v4_connect</span>
<span class="o">/</span><span class="nv">@start</span><span class="o">[</span><span class="n">tid</span><span class="o">]/</span>
<span class="err">{</span>
<span class="w">    </span><span class="err">$</span><span class="n">lat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">nsecs</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">@start</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>
<span class="w">    </span><span class="nv">@conn_lat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hist</span><span class="p">(</span><span class="err">$</span><span class="n">lat</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="err">$</span><span class="n">lat</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000000</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="n">秒</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="ss">&quot;Slow connection to %s: %d us\n&quot;</span><span class="p">,</span>
<span class="w">               </span><span class="n">ntop</span><span class="p">(</span><span class="nv">@daddr</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="p">),</span><span class="w"> </span><span class="err">$</span><span class="n">lat</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="k">delete</span><span class="p">(</span><span class="nv">@start</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="p">);</span>
<span class="w">    </span><span class="k">delete</span><span class="p">(</span><span class="nv">@daddr</span><span class="o">[</span><span class="n">tid</span><span class="o">]</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div>

<p><strong>案例3：文件系统性能瓶颈</strong></p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 追踪 ext4 写入延迟 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">data_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">ts</span><span class="p">;</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">delta</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">comm</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">filename</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">BPF_PERF_OUTPUT</span><span class="p">(</span><span class="n">events</span><span class="p">);</span>
<span class="n">BPF_HASH</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">trace_ext4_write_begin</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_get_current_pid_tgid</span><span class="p">();</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_ktime_get_ns</span><span class="p">();</span>
<span class="w">    </span><span class="n">start</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">trace_ext4_write_end</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_get_current_pid_tgid</span><span class="p">();</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="o">*</span><span class="n">tsp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tsp</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">data_t</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">    </span><span class="n">data</span><span class="p">.</span><span class="n">ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_ktime_get_ns</span><span class="p">();</span>
<span class="w">    </span><span class="n">data</span><span class="p">.</span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">ts</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">tsp</span><span class="p">;</span>
<span class="w">    </span><span class="n">data</span><span class="p">.</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">    </span><span class="n">bpf_get_current_comm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">comm</span><span class="p">));</span>

<span class="w">    </span><span class="n">events</span><span class="p">.</span><span class="n">perf_submit</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
<span class="w">    </span><span class="n">start</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="155">15.5 可视化分析工具</h3>
<ul>
<li>15.5.1 火焰图生成与分析</li>
<li>15.5.2 延迟热图</li>
<li>15.5.3 调用图与依赖分析</li>
<li>15.5.4 实时性能监控</li>
</ul>
<h3 id="_3">本章小结</h3>
<h3 id="_4">练习题</h3>
<h3 id="_5">常见陷阱与错误</h3>
<h3 id="_6">最佳实践检查清单</h3>
<hr />
            </article>
            
            <nav class="page-nav"><a href="chapter14.html" class="nav-link prev">← 第14章：实时Linux</a><a href="chapter16.html" class="nav-link next">第16章：引导过程与初始化 →</a></nav>
        </main>
    </div>
</body>
</html>