<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第6章：具体文件系统实现</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Linux 内核源代码深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：Linux 内核概述与发展史</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：进程管理与任务调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：内存管理架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：进程间通信机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：虚拟文件系统（VFS）</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：具体文件系统实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：块设备层与I/O调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：设备驱动模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：网络协议栈</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：内核同步机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：并发编程模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：容器与命名空间</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：安全子系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：实时Linux</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：性能分析与调试</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：引导过程与初始化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="6">第6章：具体文件系统实现</h1>
<h2 id="_1">章节大纲</h2>
<h3 id="61-ext234">6.1 开篇与 ext2/3/4 演进</h3>
<ul>
<li>ext 文件系统家族历史</li>
<li>ext2 基础架构：超级块、块组、inode表</li>
<li>ext3 日志机制引入</li>
<li>ext4 现代化改进：extent、延迟分配、多块分配</li>
</ul>
<h3 id="62">6.2 日志文件系统原理</h3>
<ul>
<li>日志机制设计动机</li>
<li>JBD/JBD2 日志层实现</li>
<li>三种日志模式：journal、ordered、writeback</li>
<li>崩溃恢复与一致性保证</li>
</ul>
<h3 id="63-btrfsxfs">6.3 现代文件系统：Btrfs、XFS</h3>
<ul>
<li>XFS：高性能与可扩展性</li>
<li>Btrfs：写时复制与高级特性</li>
<li>ZFS 影响与设计理念</li>
<li>性能特征对比</li>
</ul>
<h3 id="64">6.4 特殊文件系统</h3>
<ul>
<li>proc：进程信息与内核接口</li>
<li>sysfs：设备模型导出</li>
<li>debugfs：内核调试接口</li>
<li>tmpfs/ramfs：内存文件系统</li>
</ul>
<h3 id="65">6.5 本章小结</h3>
<ul>
<li>关键数据结构总结</li>
<li>算法复杂度分析</li>
<li>选型决策指南</li>
</ul>
<h3 id="66-8">6.6 练习题（8道）</h3>
<ul>
<li>基础题：文件系统结构理解</li>
<li>进阶题：性能分析与优化</li>
<li>挑战题：设计权衡与实现</li>
</ul>
<h3 id="67">6.7 常见陷阱与错误</h3>
<ul>
<li>文件系统损坏与修复</li>
<li>性能问题诊断</li>
<li>容量规划失误</li>
</ul>
<h3 id="68">6.8 最佳实践检查清单</h3>
<ul>
<li>文件系统选择准则</li>
<li>调优参数配置</li>
<li>监控与维护要点</li>
</ul>
<hr />
<h2 id="61-ext234_1">6.1 ext2/3/4 文件系统演进与实现</h2>
<p>本章深入探讨 Linux 中各种文件系统的具体实现，从经典的 ext 系列到现代的 Btrfs、XFS，再到特殊用途的 proc、sysfs 等伪文件系统。通过理解这些实现细节，我们将掌握文件系统设计的核心权衡：性能、可靠性、功能特性之间的平衡。每种文件系统都是特定需求下的产物，理解它们的设计决策对于系统架构师至关重要。</p>
<h3 id="611-ext">6.1.1 ext 文件系统家族历史</h3>
<p>ext（extended filesystem）家族是 Linux 最重要的文件系统演进脉络。从 1992 年 Rémy Card 开发的 ext 开始，历经 ext2（1993）、ext3（2001）、ext4（2008），每一代都在前代基础上解决关键问题：</p>
<div class="codehilite"><pre><span></span><code>时间线：
1992: ext  - 替代 MINIX FS，支持 2GB 文件
1993: ext2 - 成为 Linux 标准文件系统，引入块组概念
2001: ext3 - 增加日志功能，提供崩溃一致性
2008: ext4 - 支持更大容量，引入 extent、延迟分配等现代特性
</code></pre></div>

<p><strong>历史故事</strong>：ext2 的设计深受 BSD FFS（Fast File System）影响，特别是块组（block group）概念。Theodore Ts'o 在 1994 年接手维护后，ext2 成为 Linux 事实标准。而 ext3 的开发则是由 Stephen Tweedie 主导，他提出的 JBD（Journaling Block Device）层成为 Linux 日志文件系统的基础。</p>
<h3 id="612-ext2">6.1.2 ext2 基础架构</h3>
<p>ext2 确立了 ext 家族的基本布局，理解它是掌握后续版本的关键：</p>
<h4 id="_2">磁盘布局</h4>
<div class="codehilite"><pre><span></span><code><span class="nb">+------------------+</span>
<span class="c">| 引导块 (1KB)      |  </span><span class="nb">-</span><span class="c"> 保留给引导加载器</span>
<span class="nb">+------------------+</span>
<span class="c">| 块组 0           |  ┐</span>
<span class="c">|   超级块         |  │</span>
<span class="c">|   组描述符表      |  │</span>
<span class="c">|   数据块位图      |  │  块组结构</span>
<span class="c">|   inode 位图     |  │  (重复 N 次)</span>
<span class="c">|   inode 表       |  │</span>
<span class="c">|   数据块         |  │</span>
<span class="nb">+------------------+</span><span class="c">  ┘</span>
<span class="c">| 块组 1           |</span>
<span class="c">|   </span><span class="nt">...</span><span class="c">            |</span>
<span class="nb">+------------------+</span>
<span class="c">| </span><span class="nt">...</span><span class="c">              |</span>
<span class="nb">+------------------+</span>
<span class="c">| 块组 N</span><span class="nb">-</span><span class="c">1         |</span>
<span class="nb">+------------------+</span>
</code></pre></div>

<h4 id="_3">核心数据结构</h4>
<p><strong>超级块（Super Block）</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ext2_super_block</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_inodes_count</span><span class="p">;</span><span class="w">       </span><span class="cm">/* inode 总数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_blocks_count</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 块总数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_r_blocks_count</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 保留块数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_free_blocks_count</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 空闲块数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_free_inodes_count</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 空闲 inode 数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_first_data_block</span><span class="p">;</span><span class="w">   </span><span class="cm">/* 第一个数据块号 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_log_block_size</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 块大小 = 1024 &lt;&lt; s_log_block_size */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_blocks_per_group</span><span class="p">;</span><span class="w">   </span><span class="cm">/* 每组块数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_inodes_per_group</span><span class="p">;</span><span class="w">   </span><span class="cm">/* 每组 inode 数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_mtime</span><span class="p">;</span><span class="w">              </span><span class="cm">/* 挂载时间 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">s_wtime</span><span class="p">;</span><span class="w">              </span><span class="cm">/* 写入时间 */</span>
<span class="w">    </span><span class="n">__le16</span><span class="w">  </span><span class="n">s_magic</span><span class="p">;</span><span class="w">              </span><span class="cm">/* 魔数 0xEF53 */</span>
<span class="w">    </span><span class="n">__le16</span><span class="w">  </span><span class="n">s_state</span><span class="p">;</span><span class="w">              </span><span class="cm">/* 文件系统状态 */</span>
<span class="w">    </span><span class="cm">/* ... 更多字段 ... */</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>inode 结构</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ext2_inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__le16</span><span class="w">  </span><span class="n">i_mode</span><span class="p">;</span><span class="w">        </span><span class="cm">/* 文件模式 */</span>
<span class="w">    </span><span class="n">__le16</span><span class="w">  </span><span class="n">i_uid</span><span class="p">;</span><span class="w">         </span><span class="cm">/* 用户 ID */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">i_size</span><span class="p">;</span><span class="w">        </span><span class="cm">/* 文件大小（字节）*/</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">i_atime</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 访问时间 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">i_ctime</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 创建时间 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">i_mtime</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 修改时间 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">i_dtime</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 删除时间 */</span>
<span class="w">    </span><span class="n">__le16</span><span class="w">  </span><span class="n">i_gid</span><span class="p">;</span><span class="w">         </span><span class="cm">/* 组 ID */</span>
<span class="w">    </span><span class="n">__le16</span><span class="w">  </span><span class="n">i_links_count</span><span class="p">;</span><span class="w"> </span><span class="cm">/* 硬链接数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">i_blocks</span><span class="p">;</span><span class="w">      </span><span class="cm">/* 512 字节块数 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">i_block</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span><span class="w">   </span><span class="cm">/* 数据块指针 */</span>
<span class="w">    </span><span class="cm">/* i_block[0-11]: 直接块</span>
<span class="cm">       i_block[12]: 一级间接块</span>
<span class="cm">       i_block[13]: 二级间接块  </span>
<span class="cm">       i_block[14]: 三级间接块 */</span>
<span class="p">};</span>
</code></pre></div>

<h4 id="_4">块组设计哲学</h4>
<p>块组（Block Group）是 ext2 的核心创新，其设计目标是：</p>
<ol>
<li><strong>局部性优化</strong>：相关数据放在同一块组，减少磁头移动</li>
<li><strong>并行化</strong>：不同块组可以并行操作</li>
<li><strong>故障隔离</strong>：单个块组损坏不影响整个文件系统</li>
</ol>
<p>块分配算法遵循以下策略：</p>
<ul>
<li>目录：在父目录所在块组或负载最轻的块组创建</li>
<li>文件：优先在父目录所在块组分配</li>
<li>大文件：跨块组分配时保持连续性</li>
</ul>
<h3 id="613-ext3">6.1.3 ext3 日志机制引入</h3>
<p>ext3 最重要的贡献是引入日志，解决了 ext2 的崩溃一致性问题：</p>
<h4 id="jbd">JBD 层架构</h4>
<div class="codehilite"><pre><span></span><code>     应用程序
         ↓
    VFS 层接口
         ↓
    ext3 文件系统
         ↓
    JBD 日志层  ← 事务管理
         ↓
    块设备层
</code></pre></div>

<h4 id="_5">日志事务流程</h4>
<div class="codehilite"><pre><span></span><code>事务生命周期：
T_RUNNING → T_LOCKED → T_FLUSH → T_COMMIT → T_FINISHED

1. T_RUNNING：收集修改操作
2. T_LOCKED：停止接受新操作
3. T_FLUSH：写入日志区
4. T_COMMIT：提交事务
5. T_FINISHED：可以回收日志空间
</code></pre></div>

<h4 id="_6">三种日志模式对比</h4>
<p>| 模式 | 日志内容 | 性能 | 一致性保证 |</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>日志内容</th>
<th>性能</th>
<th>一致性保证</th>
</tr>
</thead>
<tbody>
<tr>
<td>journal</td>
<td>元数据+数据</td>
<td>最慢</td>
<td>最强</td>
</tr>
<tr>
<td>ordered</td>
<td>仅元数据，数据先写</td>
<td>中等</td>
<td>较强</td>
</tr>
<tr>
<td>writeback</td>
<td>仅元数据</td>
<td>最快</td>
<td>仅元数据一致</td>
</tr>
</tbody>
</table>
<p>默认使用 ordered 模式，平衡了性能和一致性。</p>
<h3 id="614-ext4">6.1.4 ext4 现代化改进</h3>
<p>ext4 在 2008 年成为默认文件系统，引入多项关键改进：</p>
<h4 id="extent">Extent 树替代块映射</h4>
<p>传统块映射的问题：</p>
<ul>
<li>大文件需要多级间接块</li>
<li>碎片化严重时性能下降</li>
<li>元数据开销大</li>
</ul>
<p>Extent 解决方案：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ext4_extent</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">ee_block</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 逻辑块号 */</span>
<span class="w">    </span><span class="n">__le16</span><span class="w">  </span><span class="n">ee_len</span><span class="p">;</span><span class="w">       </span><span class="cm">/* extent 长度 */</span>
<span class="w">    </span><span class="n">__le16</span><span class="w">  </span><span class="n">ee_start_hi</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 物理块号高 16 位 */</span>
<span class="w">    </span><span class="n">__le32</span><span class="w">  </span><span class="n">ee_start_lo</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 物理块号低 32 位 */</span>
<span class="p">};</span>

<span class="cm">/* Extent 树示例：</span>
<span class="cm">   一个 100MB 连续文件只需要一个 extent 记录</span>
<span class="cm">   而块映射需要 25600 个块指针 */</span>
</code></pre></div>

<h4 id="delayed-allocation">延迟分配（Delayed Allocation）</h4>
<div class="codehilite"><pre><span></span><code>传统分配：
write() → 立即分配块 → 写入页缓存 → 后台刷新

延迟分配：
write() → 写入页缓存 → 后台刷新时分配块

优势：

1. 更好的块分配决策（知道实际大小）
2. 减少碎片
3. 避免短生命文件的块分配
4. 提高小文件写入性能
</code></pre></div>

<h4 id="multiblock-allocation">多块分配（Multiblock Allocation）</h4>
<p>使用 mballoc（Multiblock Allocator）：</p>
<ul>
<li><strong>伙伴系统</strong>：管理空闲块</li>
<li><strong>预分配</strong>：为文件预留连续空间</li>
<li><strong>局部性组</strong>：相关文件放在一起</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 预分配策略 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ext4_prealloc_space</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">pa_inode_list</span><span class="p">;</span><span class="w">  </span><span class="cm">/* inode 预分配链表 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">pa_group_list</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 块组预分配链表 */</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_node</span><span class="w"> </span><span class="n">pa_node</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 用于 inode 预分配 */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">pa_tmp_list</span><span class="p">;</span><span class="cm">/* 临时链表 */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">pa_lock</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">pa_count</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">pa_deleted</span><span class="p">;</span>
<span class="w">    </span><span class="n">ext4_fsblk_t</span><span class="w"> </span><span class="n">pa_pstart</span><span class="p">;</span><span class="w">          </span><span class="cm">/* 物理起始块 */</span>
<span class="w">    </span><span class="n">ext4_lblk_t</span><span class="w"> </span><span class="n">pa_lstart</span><span class="p">;</span><span class="w">           </span><span class="cm">/* 逻辑起始块 */</span>
<span class="w">    </span><span class="n">ext4_grpblk_t</span><span class="w"> </span><span class="n">pa_len</span><span class="p">;</span><span class="w">            </span><span class="cm">/* 长度 */</span>
<span class="w">    </span><span class="n">ext4_grpblk_t</span><span class="w"> </span><span class="n">pa_free</span><span class="p">;</span><span class="w">           </span><span class="cm">/* 剩余空闲块 */</span>
<span class="p">};</span>
</code></pre></div>

<h4 id="_7">其他重要特性</h4>
<ol>
<li>
<p><strong>更大的文件系统支持</strong>：
   - 最大卷：1 EB（ext3：32 TB）
   - 最大文件：16 TB（ext3：2 TB）</p>
</li>
<li>
<p><strong>快速 fsck</strong>：
   - 未使用的 inode 表部分不检查
   - inode 表初始化可延迟到使用时</p>
</li>
<li>
<p><strong>纳秒级时间戳</strong>：
   - 支持纳秒精度
   - 额外的创建时间字段</p>
</li>
<li>
<p><strong>持久预分配</strong>：
   - fallocate() 系统调用支持
   - 数据库等应用可预留空间</p>
</li>
</ol>
<h3 id="615-ext4">6.1.5 ext4 内核实现分析</h3>
<p>让我们深入内核代码，理解 ext4 的关键操作：</p>
<h4 id="inode">inode 操作实现</h4>
<div class="codehilite"><pre><span></span><code><span class="cm">/* fs/ext4/inode.c */</span>
<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode_operations</span><span class="w"> </span><span class="n">ext4_file_inode_operations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">setattr</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_setattr</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">getattr</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_getattr</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">listxattr</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_listxattr</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">get_acl</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_get_acl</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">set_acl</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_set_acl</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">fiemap</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_fiemap</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* 文件写入路径 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ext4_write_begin</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="k">struct</span><span class="w"> </span><span class="nc">address_space</span><span class="w"> </span><span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
<span class="w">                            </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span>
<span class="w">                            </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">**</span><span class="n">pagep</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">needed_blocks</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 1. 计算需要的块数 */</span>
<span class="w">    </span><span class="n">needed_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 2. 开始日志事务 */</span>
<span class="w">    </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="n">EXT4_HT_WRITE_PAGE</span><span class="p">,</span><span class="w"> </span><span class="n">needed_blocks</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 3. 准备写入页 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ext4_should_dioread_nolock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_write_begin_inline</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span><span class="w"> </span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                      </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">pagep</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">ext4_get_block</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 4. 延迟分配处理 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
<span class="w">                                     </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                     </span><span class="n">do_journal_get_write_access</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="extent_1">Extent 操作</h4>
<div class="codehilite"><pre><span></span><code><span class="cm">/* fs/ext4/extents.c */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">ext4_ext_map_blocks</span><span class="p">(</span><span class="n">handle_t</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span>
<span class="w">                        </span><span class="k">struct</span><span class="w"> </span><span class="nc">ext4_map_blocks</span><span class="w"> </span><span class="o">*</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ext4_ext_path</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ext4_extent</span><span class="w"> </span><span class="n">newex</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ex</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 1. 查找 extent */</span>
<span class="w">    </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_find_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 2. 检查是否命中缓存 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ext4_lblk_t</span><span class="w"> </span><span class="n">ee_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
<span class="w">        </span><span class="n">ext4_fsblk_t</span><span class="w"> </span><span class="n">ee_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ee_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in_range</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span><span class="w"> </span><span class="n">ee_block</span><span class="p">,</span><span class="w"> </span><span class="n">ee_len</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* 命中：直接映射 */</span>
<span class="w">            </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ee_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ee_block</span><span class="p">;</span>
<span class="w">            </span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ee_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ee_block</span><span class="p">);</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 3. 未命中：分配新块 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">EXT4_GET_BLOCKS_CREATE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">newex</span><span class="p">.</span><span class="n">ee_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
<span class="w">        </span><span class="n">cluster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_ext_map_clusters</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* 4. 插入新 extent */</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_ext_insert_extent</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">newex</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="nl">out</span><span class="p">:</span>
<span class="w">    </span><span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="62_1">6.2 日志文件系统原理</h2>
<p>日志文件系统是现代文件系统的核心特性，它解决了传统文件系统最大的痛点：崩溃一致性。在 ext2 时代，系统崩溃后的 fsck 可能需要数小时，而日志机制将恢复时间缩短到秒级。本节深入剖析日志机制的设计原理和实现细节。</p>
<h3 id="621">6.2.1 为什么需要日志</h3>
<h4 id="_8">崩溃一致性问题</h4>
<p>考虑一个简单的文件创建操作，涉及多个元数据更新：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">分配</span><span class="w"> </span><span class="n">inode</span><span class="err">，</span><span class="n">更新</span><span class="w"> </span><span class="n">inode</span><span class="w"> </span><span class="n">位图</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">初始化</span><span class="w"> </span><span class="n">inode</span><span class="w"> </span><span class="n">结构</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">在父目录中创建目录项</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">更新父目录的修改时间</span>
<span class="mf">5.</span><span class="w"> </span><span class="n">更新超级块的计数器</span>
</code></pre></div>

<p>如果在步骤 3 之后崩溃，会出现：</p>
<ul>
<li>inode 已分配但无法访问（孤儿 inode）</li>
<li>空间泄漏</li>
<li>文件系统不一致</li>
</ul>
<h4 id="_9">传统解决方案的问题</h4>
<p><strong>同步元数据更新</strong>：</p>
<ul>
<li>每次操作都同步写磁盘</li>
<li>性能极差（10-100 倍慢）</li>
<li>仍无法保证原子性</li>
</ul>
<p><strong>软更新（Soft Updates）</strong>：</p>
<ul>
<li>BSD 的解决方案</li>
<li>复杂的依赖跟踪</li>
<li>实现困难，仍需要后台 fsck</li>
</ul>
<h3 id="622">6.2.2 日志机制核心概念</h3>
<h4 id="write-ahead-logging-wal">Write-Ahead Logging (WAL)</h4>
<p>日志的核心思想来自数据库的 WAL：</p>
<div class="codehilite"><pre><span></span><code>原理：先写日志，后写数据

1. 将要执行的操作写入日志
2. 确保日志落盘
3. 执行实际的数据/元数据更新
4. 标记日志项完成
</code></pre></div>

<h4 id="transaction">事务（Transaction）</h4>
<p>将相关的修改组织成事务，保证原子性：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* JBD2 事务结构 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">transaction_s</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">journal_t</span><span class="w"> </span><span class="o">*</span><span class="n">t_journal</span><span class="p">;</span><span class="w">           </span><span class="cm">/* 所属日志 */</span>
<span class="w">    </span><span class="n">tid_t</span><span class="w"> </span><span class="n">t_tid</span><span class="p">;</span><span class="w">                    </span><span class="cm">/* 事务 ID */</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">T_RUNNING</span><span class="p">,</span><span class="w">                  </span><span class="cm">/* 接受新的修改 */</span>
<span class="w">        </span><span class="n">T_LOCKED</span><span class="p">,</span><span class="w">                   </span><span class="cm">/* 不再接受修改，准备提交 */</span>
<span class="w">        </span><span class="n">T_FLUSH</span><span class="p">,</span><span class="w">                    </span><span class="cm">/* 正在写入日志 */</span>
<span class="w">        </span><span class="n">T_COMMIT</span><span class="p">,</span><span class="w">                   </span><span class="cm">/* 提交中 */</span>
<span class="w">        </span><span class="n">T_COMMIT_DFLUSH</span><span class="p">,</span><span class="w">           </span><span class="cm">/* 提交后刷盘 */</span>
<span class="w">        </span><span class="n">T_COMMIT_JFLUSH</span><span class="p">,</span><span class="w">           </span><span class="cm">/* 日志刷盘 */</span>
<span class="w">        </span><span class="n">T_FINISHED</span><span class="w">                  </span><span class="cm">/* 完成，可回收 */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">t_state</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">journal_head</span><span class="w"> </span><span class="o">*</span><span class="n">t_buffers</span><span class="p">;</span><span class="w">        </span><span class="cm">/* 缓冲区链表 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">journal_head</span><span class="w"> </span><span class="o">*</span><span class="n">t_forget</span><span class="p">;</span><span class="w">         </span><span class="cm">/* 需要忘记的缓冲区 */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">journal_head</span><span class="w"> </span><span class="o">*</span><span class="n">t_checkpoint_list</span><span class="p">;</span><span class="cm">/* 检查点链表 */</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t_expires</span><span class="p">;</span><span class="w">               </span><span class="cm">/* 超时时间 */</span>
<span class="w">    </span><span class="n">ktime_t</span><span class="w"> </span><span class="n">t_start_time</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* 开始时间 */</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">t_updates</span><span class="p">;</span><span class="w">                    </span><span class="cm">/* 活跃更新数 */</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">t_outstanding_credits</span><span class="p">;</span><span class="w">        </span><span class="cm">/* 使用的日志空间 */</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="623-jbd2">6.2.3 JBD2 架构详解</h3>
<p>JBD2（Journaling Block Device 2）是 ext4 和 OCFS2 使用的日志层：</p>
<h4 id="_10">日志布局</h4>
<div class="codehilite"><pre><span></span><code><span class="c">日志区域（循环缓冲区）：</span>
<span class="nb">+------------+------------+------------+------------+</span>
<span class="c">| 超级块     | 描述符块   | 数据/元数据 | 提交块     |</span>
<span class="nb">+------------+------------+------------+------------+</span>
<span class="c">     ↑                                         ↑</span>
<span class="c">   head                                      tail</span>
<span class="c">   (最旧的未检查点事务)                    (最新提交位置)</span>
</code></pre></div>

<h4 id="_11">日志超级块</h4>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 日志超级块 */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">journal_superblock_s</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* 静态信息 */</span>
<span class="w">    </span><span class="n">journal_header_t</span><span class="w"> </span><span class="n">s_header</span><span class="p">;</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_blocksize</span><span class="p">;</span><span class="w">            </span><span class="cm">/* 日志块大小 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_maxlen</span><span class="p">;</span><span class="w">               </span><span class="cm">/* 日志区总块数 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_first</span><span class="p">;</span><span class="w">                </span><span class="cm">/* 第一个日志块 */</span>

<span class="w">    </span><span class="cm">/* 动态信息 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_sequence</span><span class="p">;</span><span class="w">             </span><span class="cm">/* 第一个提交 ID */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_start</span><span class="p">;</span><span class="w">                </span><span class="cm">/* 第一个日志块的块号 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_errno</span><span class="p">;</span><span class="w">                </span><span class="cm">/* 错误码 */</span>

<span class="w">    </span><span class="cm">/* 特性标志 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_feature_compat</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 兼容特性 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_feature_incompat</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 不兼容特性 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_feature_ro_compat</span><span class="p">;</span><span class="w">    </span><span class="cm">/* 只读兼容特性 */</span>

<span class="w">    </span><span class="cm">/* 校验和 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">s_checksum</span><span class="p">;</span><span class="w">             </span><span class="cm">/* CRC32C 校验和 */</span>
<span class="p">}</span><span class="w"> </span><span class="n">journal_superblock_t</span><span class="p">;</span>
</code></pre></div>

<h4 id="_12">日志记录类型</h4>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 日志块标签 */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">journal_block_tag_s</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">t_blocknr</span><span class="p">;</span><span class="w">              </span><span class="cm">/* 磁盘块号 */</span>
<span class="w">    </span><span class="n">__be16</span><span class="w"> </span><span class="n">t_checksum</span><span class="p">;</span><span class="w">             </span><span class="cm">/* 块校验和 */</span>
<span class="w">    </span><span class="n">__be16</span><span class="w"> </span><span class="n">t_flags</span><span class="p">;</span><span class="w">                </span><span class="cm">/* 标志 */</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">t_blocknr_high</span><span class="p">;</span><span class="w">         </span><span class="cm">/* 块号高 32 位 */</span>
<span class="p">}</span><span class="w"> </span><span class="n">journal_block_tag_t</span><span class="p">;</span>

<span class="cp">#define JBD2_FLAG_ESCAPE    1      </span><span class="cm">/* 块内容需要转义 */</span>
<span class="cp">#define JBD2_FLAG_SAME_UUID 2      </span><span class="cm">/* UUID 相同 */</span>
<span class="cp">#define JBD2_FLAG_DELETED   4      </span><span class="cm">/* 块已删除 */</span>
<span class="cp">#define JBD2_FLAG_LAST_TAG  8      </span><span class="cm">/* 最后一个标签 */</span>
</code></pre></div>

<h3 id="624">6.2.4 三种日志模式深度分析</h3>
<h4 id="journal">Journal 模式（数据日志）</h4>
<div class="codehilite"><pre><span></span><code>操作流程：

1. 元数据 + 数据 → 日志
2. 日志落盘
3. 元数据 + 数据 → 最终位置
4. 提交事务

优点：

- 最强的一致性保证
- 数据和元数据都不会丢失

缺点：

- 所有数据写两次（日志 + 最终位置）
- 性能开销大
- 日志空间需求高

适用场景：

- 关键数据，不容许任何丢失
- 小文件为主的工作负载
</code></pre></div>

<h4 id="ordered">Ordered 模式（默认）</h4>
<div class="codehilite"><pre><span></span><code>操作流程：

1. 数据 → 最终位置
2. 数据落盘
3. 元数据 → 日志
4. 日志落盘
5. 元数据 → 最终位置
6. 提交事务

优点：

<span class="k">-</span> 平衡性能和一致性
<span class="k">-</span> 防止垃圾数据暴露
<span class="k">-</span> 日志空间需求小

缺点：

<span class="k">-</span> 数据写入成为瓶颈
<span class="k">-</span> 大文件写入延迟事务提交

实现要点：

<span class="k">-</span> 使用 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT
<span class="k">-</span> 数据块写入使用 bio 批量提交
</code></pre></div>

<h4 id="writeback">Writeback 模式</h4>
<div class="codehilite"><pre><span></span><code>操作流程：

1. 元数据 → 日志
2. 日志落盘
3. 元数据 → 最终位置
4. 数据异步写入（不保证顺序）

优点：

- 最佳性能
- 最小日志开销

缺点：

- 可能暴露垃圾数据
- 崩溃后文件内容不确定

适用场景：

- 临时文件
- 可重新生成的数据
- 性能优先的场景
</code></pre></div>

<h3 id="625">6.2.5 日志恢复机制</h3>
<h4 id="_13">恢复流程</h4>
<div class="codehilite"><pre><span></span><code><span class="cm">/* fs/jbd2/recovery.c */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">jbd2_journal_recover</span><span class="p">(</span><span class="n">journal_t</span><span class="w"> </span><span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">err2</span><span class="p">;</span>
<span class="w">    </span><span class="n">journal_superblock_t</span><span class="w"> </span><span class="o">*</span><span class="n">sb</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">recovery_info</span><span class="w"> </span><span class="n">info</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 1. 读取日志超级块 */</span>
<span class="w">    </span><span class="n">sb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 2. 扫描日志，找到有效事务范围 */</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_one_pass</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">PASS_SCAN</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 3. 重放日志（REDO） */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_one_pass</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">PASS_REVOKE</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_one_pass</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">PASS_REPLAY</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 4. 清理日志区域 */</span>
<span class="w">    </span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">end_transaction</span><span class="p">;</span>
<span class="w">    </span><span class="n">jbd2_journal_clear_revoke</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 5. 同步文件系统 */</span>
<span class="w">    </span><span class="n">sync_blockdev</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="_14">检查点机制</h4>
<p>检查点（Checkpoint）将内存中的脏数据写入磁盘，释放日志空间：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 检查点处理 */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">jbd2_log_do_checkpoint</span><span class="p">(</span><span class="n">journal_t</span><span class="w"> </span><span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">transaction_t</span><span class="w"> </span><span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">journal_head</span><span class="w"> </span><span class="o">*</span><span class="n">jh</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_head</span><span class="w"> </span><span class="o">*</span><span class="n">bh</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 获取最旧的未检查点事务 */</span>
<span class="w">    </span><span class="n">transaction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">transaction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">jh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span><span class="p">;</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">bh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* 写入脏缓冲区 */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="w">                </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
<span class="w">                </span><span class="n">ll_rw_block</span><span class="p">(</span><span class="n">REQ_OP_WRITE</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
<span class="w">                </span><span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="w">                </span><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* 等待 I/O 完成 */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="w">                </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
<span class="w">                </span><span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="w">                </span><span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="w">                </span><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* 从检查点链表移除 */</span>
<span class="w">            </span><span class="n">__jbd2_journal_remove_checkpoint</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
<span class="w">            </span><span class="n">jh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_jh</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* 移动到下一个事务 */</span>
<span class="w">        </span><span class="n">transaction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="626">6.2.6 性能优化技术</h3>
<h4 id="batching">批量提交（Batching）</h4>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 批量提交优化 */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">jbd2_journal_commit_transaction</span><span class="p">(</span><span class="n">journal_t</span><span class="w"> </span><span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">transaction_t</span><span class="w"> </span><span class="o">*</span><span class="n">commit_transaction</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_head</span><span class="w"> </span><span class="o">**</span><span class="n">wbuf</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">bufs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 收集所有需要写入的缓冲区 */</span>
<span class="w">    </span><span class="n">wbuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wbuf</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">MAX_WRITEBACK_PAGES</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_NOFS</span><span class="p">);</span>

<span class="w">    </span><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span><span class="p">,</span><span class="w"> </span><span class="n">b_tnext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">wbuf</span><span class="p">[</span><span class="n">bufs</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bufs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_WRITEBACK_PAGES</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* 批量提交 */</span>
<span class="w">            </span><span class="n">ll_rw_block</span><span class="p">(</span><span class="n">REQ_OP_WRITE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">REQ_SYNC</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span><span class="p">,</span><span class="w"> </span><span class="n">wbuf</span><span class="p">);</span>
<span class="w">            </span><span class="n">bufs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 提交剩余的缓冲区 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bufs</span><span class="p">)</span>
<span class="w">        </span><span class="n">ll_rw_block</span><span class="p">(</span><span class="n">REQ_OP_WRITE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">REQ_SYNC</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span><span class="p">,</span><span class="w"> </span><span class="n">wbuf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="_15">并行日志写入</h4>
<p>JBD2 支持多个 CPU 并行准备日志记录：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 并行日志准备 */</span>
<span class="n">handle_t</span><span class="w"> </span><span class="o">*</span><span class="nf">jbd2__journal_start</span><span class="p">(</span><span class="n">journal_t</span><span class="w"> </span><span class="o">*</span><span class="n">journal</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nblocks</span><span class="p">,</span><span class="w"> </span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">handle_t</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">transaction_t</span><span class="w"> </span><span class="o">*</span><span class="n">transaction</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 每个 CPU 独立的 handle */</span>
<span class="w">    </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_handle</span><span class="p">(</span><span class="n">nblocks</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 获取当前运行事务 */</span>
<span class="w">    </span><span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="w">    </span><span class="n">transaction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 原子地增加引用计数 */</span>
<span class="w">    </span><span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 预留日志空间 */</span>
<span class="w">    </span><span class="n">atomic_sub</span><span class="p">(</span><span class="n">nblocks</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span><span class="p">);</span>

<span class="w">    </span><span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

<span class="w">    </span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transaction</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="fast-commit">快速提交（Fast Commit）</h4>
<p>ext4 引入的快速提交机制，用于加速 fsync：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 快速提交实现 */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">ext4_fc_commit</span><span class="p">(</span><span class="n">journal_t</span><span class="w"> </span><span class="o">*</span><span class="n">journal</span><span class="p">,</span><span class="w"> </span><span class="n">tid_t</span><span class="w"> </span><span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ext4_fc_commit_info</span><span class="w"> </span><span class="o">*</span><span class="n">fc_info</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 1. 检查是否可以快速提交 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ext4_fc_can_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">jbd2_complete_transaction</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span><span class="w"> </span><span class="n">tid</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 2. 准备快速提交信息 */</span>
<span class="w">    </span><span class="n">fc_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ext4_fc_prepare</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 3. 写入快速提交日志 */</span>
<span class="w">    </span><span class="n">ext4_fc_write_inode</span><span class="p">(</span><span class="n">fc_info</span><span class="p">);</span>
<span class="w">    </span><span class="n">ext4_fc_write_data</span><span class="p">(</span><span class="n">fc_info</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 4. 提交快速日志 */</span>
<span class="w">    </span><span class="n">ext4_fc_submit</span><span class="p">(</span><span class="n">fc_info</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="627">6.2.7 日志调优参数</h3>
<h4 id="_16">关键参数配置</h4>
<div class="codehilite"><pre><span></span><code><span class="c1"># 调整日志大小（ext4）</span>
tune2fs<span class="w"> </span>-J<span class="w"> </span><span class="nv">size</span><span class="o">=</span><span class="m">256</span><span class="w"> </span>/dev/sda1

<span class="c1"># 调整提交间隔</span>
mount<span class="w"> </span>-o<span class="w"> </span><span class="nv">commit</span><span class="o">=</span><span class="m">5</span><span class="w"> </span>/dev/sda1<span class="w"> </span>/mnt<span class="w">  </span><span class="c1"># 5秒提交一次</span>

<span class="c1"># 禁用屏障（谨慎使用）</span>
mount<span class="w"> </span>-o<span class="w"> </span>nobarrier<span class="w"> </span>/dev/sda1<span class="w"> </span>/mnt

<span class="c1"># 设置日志模式</span>
mount<span class="w"> </span>-o<span class="w"> </span><span class="nv">data</span><span class="o">=</span>writeback<span class="w"> </span>/dev/sda1<span class="w"> </span>/mnt
</code></pre></div>

<h4 id="_17">性能监控</h4>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 通过 /proc/fs/jbd2/ 监控日志性能 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">jbd2_stats_proc_session</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">journal_t</span><span class="w"> </span><span class="o">*</span><span class="n">journal</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">transaction_stats_s</span><span class="w"> </span><span class="o">*</span><span class="n">stats</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w">          </span><span class="cm">/* 统计开始时间 */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">max</span><span class="p">;</span><span class="w">            </span><span class="cm">/* 最大事务数 */</span>
<span class="p">};</span>

<span class="cm">/* 关键指标：</span>

<span class="cm">   - 平均事务大小</span>
<span class="cm">   - 提交延迟</span>
<span class="cm">   - 检查点频率</span>
<span class="cm">   - 日志利用率 */</span>
</code></pre></div>

<h2 id="63-xfsbtrfs">6.3 现代文件系统：XFS、Btrfs</h2>
<p>现代文件系统为了应对大规模存储、高并发访问、数据完整性等挑战，引入了许多创新设计。XFS 代表了高性能和可扩展性的极致追求，而 Btrfs 则展示了功能丰富性和灵活性的方向。理解它们的设计哲学和实现机制，对于架构大规模存储系统至关重要。</p>
<h3 id="631-xfs">6.3.1 XFS：高性能与可扩展性</h3>
<p>XFS 由 SGI 在 1993 年为 IRIX 开发，2001 年移植到 Linux。它的设计目标是处理超大文件和高并发访问。</p>
<h4 id="_18">架构特点</h4>
<p><strong>分配组（Allocation Groups）</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c">XFS 文件系统布局：</span>
<span class="nb">+----------------+----------------+----------------+</span>
<span class="c">|       AG0      |       AG1      |       AG2      | </span><span class="nt">...</span>
<span class="nb">+----------------+----------------+----------------+</span>
<span class="c">每个 AG 包含：</span>

<span class="nb">-</span><span class="c"> 超级块副本</span>
<span class="nb">-</span><span class="c"> 空闲空间 B</span><span class="nb">+</span><span class="c"> 树</span>
<span class="nb">-</span><span class="c"> inode B</span><span class="nb">+</span><span class="c"> 树  </span>
<span class="nb">-</span><span class="c"> 自由 inode 列表</span>
<span class="nb">-</span><span class="c"> AG 内部日志（可选）</span>

<span class="c">优势：</span>

<span class="c">1</span><span class="nt">.</span><span class="c"> 并行操作：不同 AG 可以独立操作</span>
<span class="c">2</span><span class="nt">.</span><span class="c"> 可扩展性：AG 数量可达数千个</span>
<span class="c">3</span><span class="nt">.</span><span class="c"> 局部性：相关数据在同一 AG</span>
</code></pre></div>

<p><strong>B+ 树无处不在</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* XFS 使用 B+ 树管理几乎所有元数据 */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">xfs_btree_block</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__be32</span><span class="w">  </span><span class="n">bb_magic</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 魔数标识 */</span>
<span class="w">    </span><span class="n">__be16</span><span class="w">  </span><span class="n">bb_level</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 树的层级 */</span>
<span class="w">    </span><span class="n">__be16</span><span class="w">  </span><span class="n">bb_numrecs</span><span class="p">;</span><span class="w">     </span><span class="cm">/* 记录数 */</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">__be32</span><span class="w">  </span><span class="n">bb_leftsib</span><span class="p">;</span><span class="w">   </span><span class="cm">/* 左兄弟 */</span>
<span class="w">            </span><span class="n">__be32</span><span class="w">  </span><span class="n">bb_rightsib</span><span class="p">;</span><span class="w">  </span><span class="cm">/* 右兄弟 */</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">__be64</span><span class="w">  </span><span class="n">bb_leftsib</span><span class="p">;</span>
<span class="w">            </span><span class="n">__be64</span><span class="w">  </span><span class="n">bb_rightsib</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">bb_u</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">xfs_btree_block_t</span><span class="p">;</span>

<span class="cm">/* B+ 树类型：</span>

<span class="cm">   1. 空间管理：BNO（按块号）、CNT（按大小）</span>
<span class="cm">   2. inode 管理：INO（inode 分配）、FINO（空闲 inode）</span>
<span class="cm">   3. 目录：DIR2（大目录）</span>
<span class="cm">   4. 扩展属性：ATTR</span>
<span class="cm">   5. 反向映射：RMAP（块到文件映射）</span>
<span class="cm">   6. 引用计数：REFC（共享块）*/</span>
</code></pre></div>

<h4 id="delayed-allocation_1">延迟分配（Delayed Allocation）</h4>
<p>XFS 的延迟分配比 ext4 更激进：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 延迟分配实现 */</span>
<span class="n">STATIC</span><span class="w"> </span><span class="kt">int</span>
<span class="n">xfs_vm_writepage</span><span class="p">(</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">page</span><span class="p">,</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">writeback_control</span><span class="w"> </span><span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">xfs_inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_head</span><span class="w"> </span><span class="o">*</span><span class="n">bh</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">xfs_iomap_t</span><span class="w"> </span><span class="n">iomap</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 1. 检查是否有延迟分配的块 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* 2. 转换延迟分配为真实分配 */</span>
<span class="w">        </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xfs_iomap_write_allocate</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iomap</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* 3. 优化：尝试预分配更多空间 */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iomap</span><span class="p">.</span><span class="n">iomap_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">IOMAP_F_SHARED</span><span class="p">))</span>
<span class="w">            </span><span class="n">xfs_iomap_prealloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* 4. 提交 I/O */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xfs_submit_ioend</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span><span class="w"> </span><span class="n">ioend</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="_19">扩展属性与访问控制列表</h4>
<p>XFS 对扩展属性的支持非常完善：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 扩展属性存储格式 */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">xfs_attr_leaf_entry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__be32</span><span class="w">  </span><span class="n">hashval</span><span class="p">;</span><span class="w">        </span><span class="cm">/* 名称哈希值 */</span>
<span class="w">    </span><span class="n">__be16</span><span class="w">  </span><span class="n">nameidx</span><span class="p">;</span><span class="w">       </span><span class="cm">/* 名称偏移 */</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span><span class="w">          </span><span class="cm">/* 标志 */</span>
<span class="w">    </span><span class="n">__u8</span><span class="w">    </span><span class="n">pad2</span><span class="p">;</span><span class="w">           </span><span class="cm">/* 填充 */</span>
<span class="p">}</span><span class="w"> </span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">;</span>

<span class="cm">/* 属性类型 */</span>
<span class="cp">#define XFS_ATTR_LOCAL  0x01    </span><span class="cm">/* 属性值存储在 inode */</span>
<span class="cp">#define XFS_ATTR_ROOT   0x02    </span><span class="cm">/* 可信属性 */</span>
<span class="cp">#define XFS_ATTR_SECURE 0x08    </span><span class="cm">/* 安全属性 */</span>
<span class="cp">#define XFS_ATTR_PARENT 0x10    </span><span class="cm">/* 父目录指针 */</span>
</code></pre></div>

<h4 id="realtime-subvolume">实时子卷（Realtime Subvolume）</h4>
<p>XFS 独特的实时子卷设计，用于流媒体等场景：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 实时分配 */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">xfs_rtallocate_extent</span><span class="p">(</span>
<span class="w">    </span><span class="n">xfs_trans_t</span><span class="w"> </span><span class="o">*</span><span class="n">tp</span><span class="p">,</span>
<span class="w">    </span><span class="n">xfs_rtblock_t</span><span class="w"> </span><span class="n">bno</span><span class="p">,</span><span class="w">      </span><span class="cm">/* 起始块号 */</span>
<span class="w">    </span><span class="n">xfs_extlen_t</span><span class="w"> </span><span class="n">minlen</span><span class="p">,</span><span class="w">    </span><span class="cm">/* 最小长度 */</span>
<span class="w">    </span><span class="n">xfs_extlen_t</span><span class="w"> </span><span class="n">maxlen</span><span class="p">,</span><span class="w">    </span><span class="cm">/* 最大长度 */</span>
<span class="w">    </span><span class="n">xfs_extlen_t</span><span class="w"> </span><span class="o">*</span><span class="n">len</span><span class="p">,</span><span class="w">      </span><span class="cm">/* 实际分配长度 */</span>
<span class="w">    </span><span class="n">xfs_rtblock_t</span><span class="w"> </span><span class="o">*</span><span class="n">rtblock</span><span class="p">)</span><span class="w"> </span><span class="cm">/* 分配的块号 */</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* 实时子卷特点：</span>

<span class="cm">       1. 固定大小 extent（通常 64KB-1MB）</span>
<span class="cm">       2. 无元数据开销</span>
<span class="cm">       3. 适合大文件顺序 I/O</span>
<span class="cm">       4. 可以使用不同的块设备 */</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="632-btrfs">6.3.2 Btrfs：写时复制与高级特性</h3>
<p>Btrfs（B-tree FS）由 Oracle 的 Chris Mason 在 2007 年开始开发，目标是提供企业级功能同时保持性能。</p>
<h4 id="_20">核心设计理念</h4>
<p><strong>Copy-on-Write (CoW) Everything</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="n">传统文件系统更新</span><span class="err">：</span>
<span class="p">[</span><span class="n">Block</span><span class="w"> </span><span class="n">A</span><span class="p">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">原地修改</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="p">[</span><span class="n">Block</span><span class="w"> </span><span class="n">A</span><span class="err">&#39;</span><span class="p">]</span>

<span class="n">Btrfs</span><span class="w"> </span><span class="n">CoW</span><span class="w"> </span><span class="n">更新</span><span class="err">：</span>
<span class="p">[</span><span class="n">Block</span><span class="w"> </span><span class="n">A</span><span class="p">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">复制</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="p">[</span><span class="n">Block</span><span class="w"> </span><span class="n">A</span><span class="err">&#39;</span><span class="p">]</span>
<span class="w">    </span><span class="err">↓</span><span class="w">                   </span><span class="err">↓</span>
<span class="n">保留旧版本</span><span class="w">          </span><span class="n">新版本</span>

<span class="n">优势</span><span class="err">：</span>

<span class="mf">1.</span><span class="w"> </span><span class="n">原子更新</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">快照零成本</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">数据完整性</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">简化崩溃恢复</span>
</code></pre></div>

<h4 id="b-tree">B-tree 森林架构</h4>
<div class="codehilite"><pre><span></span><code><span class="cm">/* Btrfs 使用多个 B-tree 管理不同类型数据 */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">btrfs_tree_objectid</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BTRFS_ROOT_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">      </span><span class="cm">/* 根树 */</span>
<span class="w">    </span><span class="n">BTRFS_EXTENT_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">    </span><span class="cm">/* extent 树 */</span>
<span class="w">    </span><span class="n">BTRFS_CHUNK_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">     </span><span class="cm">/* chunk 树 */</span>
<span class="w">    </span><span class="n">BTRFS_DEV_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w">       </span><span class="cm">/* 设备树 */</span>
<span class="w">    </span><span class="n">BTRFS_FS_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">        </span><span class="cm">/* 文件系统树 */</span>
<span class="w">    </span><span class="n">BTRFS_CSUM_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w">      </span><span class="cm">/* 校验和树 */</span>
<span class="w">    </span><span class="n">BTRFS_QUOTA_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w">     </span><span class="cm">/* 配额树 */</span>
<span class="w">    </span><span class="n">BTRFS_UUID_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w">      </span><span class="cm">/* UUID 树 */</span>
<span class="w">    </span><span class="n">BTRFS_FREE_SPACE_TREE_OBJECTID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 空闲空间树 */</span>
<span class="p">};</span>

<span class="cm">/* B-tree 节点结构 */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_header</span><span class="w"> </span><span class="n">header</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_key_ptr</span><span class="w"> </span><span class="n">ptrs</span><span class="p">[];</span><span class="w">  </span><span class="cm">/* 子节点指针数组 */</span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="cm">/* 键结构（所有 B-tree 共用） */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_key</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__le64</span><span class="w"> </span><span class="n">objectid</span><span class="p">;</span><span class="w">    </span><span class="cm">/* 对象 ID */</span>
<span class="w">    </span><span class="n">__u8</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w">          </span><span class="cm">/* 类型 */</span>
<span class="w">    </span><span class="n">__le64</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w">      </span><span class="cm">/* 偏移/其他信息 */</span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>
</code></pre></div>

<h4 id="_21">子卷与快照</h4>
<p>Btrfs 的子卷是独立的文件系统树：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 创建快照 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">btrfs_ioctl_snap_create</span><span class="p">(</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">subvol</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_root</span><span class="w"> </span><span class="o">*</span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_trans_handle</span><span class="w"> </span><span class="o">*</span><span class="n">trans</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_root_item</span><span class="w"> </span><span class="o">*</span><span class="n">root_item</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 1. 开始事务 */</span>
<span class="w">    </span><span class="n">trans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 2. 复制根节点（CoW） */</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btrfs_copy_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span>
<span class="w">                         </span><span class="n">objectid</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 3. 创建新的根项 */</span>
<span class="w">    </span><span class="n">root_item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">;</span>
<span class="w">    </span><span class="n">btrfs_set_root_bytenr</span><span class="p">(</span><span class="n">root_item</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
<span class="w">    </span><span class="n">btrfs_set_root_level</span><span class="p">(</span><span class="n">root_item</span><span class="p">,</span><span class="w"> </span><span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
<span class="w">    </span><span class="n">btrfs_set_root_generation</span><span class="p">(</span><span class="n">root_item</span><span class="p">,</span><span class="w"> </span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 4. 插入根树 */</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btrfs_insert_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span><span class="w"> </span><span class="n">tree_root</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">root_item</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 快照创建完成，几乎零成本！ */</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="_22">数据校验和</h4>
<p>每个数据块都有校验和：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 校验和计算 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">btrfs_csum_one_bio</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_io_bio</span><span class="w"> </span><span class="o">*</span><span class="n">io_bio</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bio</span><span class="w"> </span><span class="o">*</span><span class="n">bio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io_bio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_ordered_extent</span><span class="w"> </span><span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">csum</span><span class="p">;</span>

<span class="w">    </span><span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span><span class="w"> </span><span class="n">bio</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_page</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* CRC32C 校验和 */</span>
<span class="w">        </span><span class="n">csum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btrfs_crc32c</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_offset</span><span class="p">,</span><span class="w"> </span>
<span class="w">                           </span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_len</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* 存储到校验和树 */</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btrfs_csum_file_blocks</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span><span class="w"> </span><span class="n">csum_root</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">csum</span><span class="p">);</span>
<span class="w">        </span><span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="raid">RAID 与数据冗余</h4>
<p>Btrfs 内置 RAID 支持：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* RAID 级别 */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">btrfs_raid_types</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BTRFS_RAID_SINGLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_RAID_RAID0</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_RAID_RAID1</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_RAID_DUP</span><span class="p">,</span><span class="w">      </span><span class="cm">/* 单设备双副本 */</span>
<span class="w">    </span><span class="n">BTRFS_RAID_RAID10</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_RAID_RAID5</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_RAID_RAID6</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_RAID_RAID1C3</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 3 副本 */</span>
<span class="w">    </span><span class="n">BTRFS_RAID_RAID1C4</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 4 副本 */</span>
<span class="p">};</span>

<span class="cm">/* 条带化写入 */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">btrfs_map_bio_raid56</span><span class="p">(</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_fs_info</span><span class="w"> </span><span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bio</span><span class="w"> </span><span class="o">*</span><span class="n">bio</span><span class="p">,</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">btrfs_io_context</span><span class="w"> </span><span class="o">*</span><span class="n">bioc</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bioc</span><span class="o">-&gt;</span><span class="n">raid_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* RAID5/6 需要计算校验 */</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raid56_parity_write</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span><span class="w"> </span><span class="n">bio</span><span class="p">,</span><span class="w"> </span><span class="n">bioc</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* RAID0/1/10 直接映射 */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bioc</span><span class="o">-&gt;</span><span class="n">num_stripes</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bioc</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)</span>
<span class="w">                </span><span class="n">submit_stripe_bio</span><span class="p">(</span><span class="n">bioc</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="_23">透明压缩</h4>
<p>Btrfs 支持多种压缩算法：</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* 压缩类型 */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">btrfs_compression_type</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BTRFS_COMPRESS_NONE</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_COMPRESS_ZLIB</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_COMPRESS_LZO</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">BTRFS_COMPRESS_ZSTD</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* 压缩实现 */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">btrfs_compress_pages</span><span class="p">(</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">type_level</span><span class="p">,</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">address_space</span><span class="w"> </span><span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">start</span><span class="p">,</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">**</span><span class="n">pages</span><span class="p">,</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">out_pages</span><span class="p">,</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">total_in</span><span class="p">,</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">total_out</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">workspace</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 获取压缩工作空间 */</span>
<span class="w">    </span><span class="n">workspace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_workspace</span><span class="p">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 执行压缩 */</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compression_funcs</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">compress_pages</span><span class="p">(</span>
<span class="w">        </span><span class="n">workspace</span><span class="p">,</span><span class="w"> </span><span class="n">mapping</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">pages</span><span class="p">,</span>
<span class="w">        </span><span class="n">out_pages</span><span class="p">,</span><span class="w"> </span><span class="n">total_in</span><span class="p">,</span><span class="w"> </span><span class="n">total_out</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* 压缩比检查 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">total_out</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="o">*</span><span class="n">total_in</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* 压缩效果不好，放弃压缩 */</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">put_workspace</span><span class="p">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">workspace</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="633">6.3.3 性能特征对比</h3>
<p>| 特性 | ext4 | XFS | Btrfs |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ext4</th>
<th>XFS</th>
<th>Btrfs</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>最大文件</strong></td>
<td>16 TB</td>
<td>8 EB</td>
<td>16 EB</td>
</tr>
<tr>
<td><strong>最大卷</strong></td>
<td>1 EB</td>
<td>8 EB</td>
<td>16 EB</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>中等</td>
<td>极高</td>
<td>高</td>
</tr>
<tr>
<td><strong>小文件性能</strong></td>
<td>优秀</td>
<td>一般</td>
<td>良好</td>
</tr>
<tr>
<td><strong>大文件性能</strong></td>
<td>良好</td>
<td>极佳</td>
<td>优秀</td>
</tr>
<tr>
<td><strong>碎片整理</strong></td>
<td>在线</td>
<td>在线</td>
<td>在线+自动</td>
</tr>
<tr>
<td><strong>快照</strong></td>
<td>无</td>
<td>无</td>
<td>原生支持</td>
</tr>
<tr>
<td><strong>压缩</strong></td>
<td>无</td>
<td>无</td>
<td>透明压缩</td>
</tr>
<tr>
<td><strong>校验和</strong></td>
<td>仅元数据</td>
<td>仅元数据</td>
<td>全部数据</td>
</tr>
<tr>
<td><strong>RAID</strong></td>
<td>需要 MD/LVM</td>
<td>需要 MD/LVM</td>
<td>内置</td>
</tr>
</tbody>
</table>
<h3 id="634-zfs">6.3.4 ZFS 影响与设计理念</h3>
<p>虽然 ZFS 因许可证问题不在 Linux 主线，但它的设计深刻影响了 Btrfs：</p>
<p><strong>端到端数据完整性</strong>：</p>
<ul>
<li>每个块都有校验和</li>
<li>校验和存储在父块</li>
<li>形成 Merkle 树</li>
</ul>
<p><strong>存储池概念</strong>：</p>
<ul>
<li>不再有固定分区</li>
<li>动态空间分配</li>
<li>多设备管理</li>
</ul>
<p><strong>事务性语义</strong>：</p>
<ul>
<li>所有操作都是事务</li>
<li>永不覆写（除了超级块）</li>
<li>崩溃一致性保证</li>
</ul>
<p><strong>ARC 缓存</strong>：</p>
<ul>
<li>自适应替换缓存</li>
<li>比 LRU 更智能</li>
<li>支持压缩缓存</li>
</ul>
<h3 id="635">6.3.5 文件系统选择决策</h3>
<h4 id="ext4">选择 ext4 的场景</h4>
<ul>
<li>稳定性要求极高</li>
<li>简单可靠的通用存储</li>
<li>小到中等规模部署</li>
<li>与旧系统兼容</li>
</ul>
<h4 id="xfs">选择 XFS 的场景</h4>
<ul>
<li>超大文件（视频、科学计算）</li>
<li>高并发访问</li>
<li>大规模存储（PB 级）</li>
<li>流媒体应用</li>
</ul>
<h4 id="btrfs">选择 Btrfs 的场景</h4>
<ul>
<li>需要快照功能</li>
<li>数据完整性关键</li>
<li>需要在线压缩</li>
<li>容器存储后端</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter5.html" class="nav-link prev">← 第5章：虚拟文件系统（VFS）</a><a href="chapter7.html" class="nav-link next">第7章：块设备层与I/O调度 →</a></nav>
        </main>
    </div>
</body>
</html>