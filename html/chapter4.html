<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第4章：进程间通信机制</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Linux 内核源代码深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：Linux 内核概述与发展史</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：进程管理与任务调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：内存管理架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：进程间通信机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：虚拟文件系统（VFS）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：具体文件系统实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：块设备层与I/O调度</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：设备驱动模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：网络协议栈</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：内核同步机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：并发编程模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：容器与命名空间</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：安全子系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：实时Linux</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：性能分析与调试</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：引导过程与初始化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="4">第4章：进程间通信机制</h1>
<p>进程间通信（IPC）是操作系统的核心功能之一，它使得独立的进程能够交换数据、同步执行和协调资源访问。Linux 内核提供了丰富的 IPC 机制，从经典的 Unix 管道到现代的 futex 和 io_uring，每种机制都有其独特的设计哲学和适用场景。本章将深入剖析 Linux IPC 机制的内核实现，揭示其背后的算法原理、性能特征和演进历程。</p>
<h2 id="_1">学习目标</h2>
<p>完成本章学习后，您将能够：</p>
<ol>
<li><strong>理解传统 IPC 机制</strong>：掌握管道、消息队列、共享内存的内核实现和数据结构</li>
<li><strong>分析信号系统架构</strong>：理解信号的产生、投递、处理全流程，包括实时信号扩展</li>
<li><strong>掌握 futex 原理</strong>：深入理解用户态/内核态混合同步机制，包括 PI-futex 和 robust futex</li>
<li><strong>使用现代 IPC 接口</strong>：熟练运用 eventfd、signalfd、timerfd 构建高效事件驱动程序</li>
<li><strong>优化 IPC 性能</strong>：根据场景选择合适的 IPC 机制，实现零拷贝和 NUMA 优化</li>
<li><strong>理解前沿技术</strong>：掌握 io_uring、RDMA 等新一代高性能通信机制</li>
</ol>
<h2 id="41-ipc">4.1 传统 IPC 机制</h2>
<p>Linux 内核继承并扩展了 Unix 的传统 IPC 机制。这些机制虽然历史悠久，但在现代系统中仍然扮演着重要角色。理解它们的实现原理对于系统编程和性能优化至关重要。</p>
<h3 id="411-pipe">4.1.1 管道（Pipe）机制深度剖析</h3>
<h4 id="_2">匿名管道实现原理</h4>
<p>管道是 Unix 最早的 IPC 机制之一，其优雅的设计体现了 "一切皆文件" 的哲学。在 Linux 内核中，管道通过特殊的文件系统 pipefs 实现。</p>
<p><strong>核心数据结构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// fs/pipe.c</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pipe_inode_info</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mutex</span><span class="w"> </span><span class="n">mutex</span><span class="p">;</span><span class="w">           </span><span class="c1">// 保护管道状态的互斥锁</span>
<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">rd_wait</span><span class="p">;</span><span class="w">    </span><span class="c1">// 读者等待队列</span>
<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">wr_wait</span><span class="p">;</span><span class="w">    </span><span class="c1">// 写者等待队列</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w">            </span><span class="c1">// 环形缓冲区头部</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">            </span><span class="c1">// 环形缓冲区尾部</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">max_usage</span><span class="p">;</span><span class="w">       </span><span class="c1">// 最大缓冲区数量</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ring_size</span><span class="p">;</span><span class="w">       </span><span class="c1">// 环形缓冲区大小（必须是2的幂）</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">readers</span><span class="p">;</span><span class="w">         </span><span class="c1">// 读者计数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">writers</span><span class="p">;</span><span class="w">         </span><span class="c1">// 写者计数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">files</span><span class="p">;</span><span class="w">           </span><span class="c1">// 引用计数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r_counter</span><span class="p">;</span><span class="w">       </span><span class="c1">// 读计数器（用于 poll）</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">w_counter</span><span class="p">;</span><span class="w">       </span><span class="c1">// 写计数器（用于 poll）</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">tmp_page</span><span class="p">;</span><span class="w">        </span><span class="c1">// 临时页面（优化小数据传输）</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fasync_struct</span><span class="w"> </span><span class="o">*</span><span class="n">fasync_readers</span><span class="p">;</span><span class="w">  </span><span class="c1">// 异步通知读者</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fasync_struct</span><span class="w"> </span><span class="o">*</span><span class="n">fasync_writers</span><span class="p">;</span><span class="w">  </span><span class="c1">// 异步通知写者</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">bufs</span><span class="p">;</span><span class="w">     </span><span class="c1">// 环形缓冲区数组</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">user_struct</span><span class="w"> </span><span class="o">*</span><span class="n">user</span><span class="p">;</span><span class="w">     </span><span class="c1">// 创建者用户结构</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">pipe_buffer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">page</span><span class="p">;</span><span class="w">            </span><span class="c1">// 数据页</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w">          </span><span class="c1">// 页内偏移</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w">             </span><span class="c1">// 有效数据长度</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe_buf_operations</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">;</span><span class="w">  </span><span class="c1">// 缓冲区操作函数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w">           </span><span class="c1">// 标志位</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">private</span><span class="p">;</span><span class="w">        </span><span class="c1">// 私有数据</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>管道创建流程</strong></p>
<p>当进程调用 <code>pipe()</code> 或 <code>pipe2()</code> 系统调用时，内核执行以下步骤：</p>
<ol>
<li><strong>分配 pipe_inode_info 结构</strong>：初始化管道的元数据</li>
<li><strong>创建两个 file 结构</strong>：分别用于读端和写端</li>
<li><strong>设置文件操作函数</strong>：读端使用 <code>read_pipe_fops</code>，写端使用 <code>write_pipe_fops</code></li>
<li><strong>分配文件描述符</strong>：将两个 fd 返回给用户空间</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// fs/pipe.c 简化版</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">do_pipe2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">fildes</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">files</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>

<span class="w">    </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__do_pipe_flags</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">files</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 将文件描述符复制到用户空间</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">fildes</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 错误处理</span>
<span class="w">            </span><span class="n">fput</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">            </span><span class="n">fput</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">            </span><span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">            </span><span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">            </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 安装文件描述符</span>
<span class="w">            </span><span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">            </span><span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">files</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>环形缓冲区管理</strong></p>
<p>Linux 管道使用环形缓冲区（circular buffer）管理数据，这种设计有以下优势：</p>
<ol>
<li><strong>空间效率</strong>：避免数据移动，通过调整指针实现循环使用</li>
<li><strong>时间效率</strong>：O(1) 的入队和出队操作</li>
<li><strong>缓存友好</strong>：连续的内存访问模式</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c">环形缓冲区示意图：</span>
<span class="c">        head</span>
<span class="c">          |</span>
<span class="c">          v</span>
<span class="c">    </span><span class="nb">+---+---+---+---+---+---+---+---+</span>
<span class="c">    | D | E |   |   |   | A | B | C |</span>
<span class="c">    </span><span class="nb">+---+---+---+---+---+---+---+---+</span>
<span class="c">              ^               ^</span>
<span class="c">              |               |</span>
<span class="c">           tail         wrapped data</span>
</code></pre></div>

<p><strong>读写操作实现</strong></p>
<p>管道的读写操作涉及复杂的同步机制：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 简化的管道写操作</span>
<span class="k">static</span><span class="w"> </span><span class="kt">ssize_t</span>
<span class="nf">pipe_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">iocb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iov_iter</span><span class="w"> </span><span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe_inode_info</span><span class="w"> </span><span class="o">*</span><span class="n">pipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">max_usage</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">total_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">chars</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">was_empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 检查是否有读者</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">send_sig</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
<span class="w">    </span><span class="n">max_usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span><span class="p">;</span>
<span class="w">    </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">ring_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 计算可用空间</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pipe_full</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">max_usage</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">head_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">head_buf</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// 分配页面并复制数据</span>
<span class="w">        </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_HIGHUSER</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">__GFP_ACCOUNT</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 从用户空间复制数据</span>
<span class="w">        </span><span class="n">chars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy_page_from_iter</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">);</span>
<span class="w">        </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chars</span><span class="p">;</span>

<span class="w">        </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">chars</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 唤醒等待的读者</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">was_empty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">,</span><span class="w"> </span><span class="n">EPOLLIN</span><span class="p">);</span>
<span class="w">            </span><span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">fasync_readers</span><span class="p">,</span><span class="w"> </span><span class="n">SIGIO</span><span class="p">,</span><span class="w"> </span><span class="n">POLL_IN</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="nl">out</span><span class="p">:</span>
<span class="w">    </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="fifo">命名管道（FIFO）</h4>
<p>命名管道通过文件系统提供持久化的 IPC 通道，允许无亲缘关系的进程通信。</p>
<p><strong>FIFO 创建与打开</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// fs/pipe.c</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fifo_open</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe_inode_info</span><span class="w"> </span><span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_pipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_magic</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PIPEFS_MAGIC</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="p">;</span>
<span class="w">        </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="w">        </span><span class="n">pipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_pipe_info</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 另一个进程已经创建了管道</span>
<span class="w">            </span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="w">            </span><span class="n">free_pipe_info</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
<span class="w">            </span><span class="n">pipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe</span><span class="p">;</span>
<span class="w">            </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 根据打开模式更新读者/写者计数</span>
<span class="w">    </span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">FMODE_READ</span><span class="p">)</span>
<span class="w">        </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">readers</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">FMODE_WRITE</span><span class="p">)</span>
<span class="w">        </span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">writers</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="splice-tee">splice 和 tee 系统调用</h4>
<p>splice 和 tee 是 Linux 2.6.17 引入的零拷贝数据传输机制，大幅提升了管道的性能。</p>
<p><strong>splice 原理</strong></p>
<p>splice 通过在内核空间移动页面引用而非复制数据，实现高效的数据传输：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// fs/splice.c 核心逻辑</span>
<span class="n">ASMLINKAGE</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">sys_splice</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd_in</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">off_in</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">int</span><span class="w"> </span><span class="n">fd_out</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">off_out</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fd</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
<span class="w">    </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdget</span><span class="p">(</span><span class="n">fd_in</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdget</span><span class="p">(</span><span class="n">fd_out</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_splice</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">off_in</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">off_out</span><span class="p">,</span>
<span class="w">                            </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">            </span><span class="n">fdput</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">fdput</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>零拷贝数据流</strong></p>
<div class="codehilite"><pre><span></span><code>传统方式（4次拷贝）：
磁盘 → 内核缓冲区 → 用户缓冲区 → 内核缓冲区 → 网络

splice方式（2次拷贝）：
磁盘 → 内核缓冲区 → 网络
         ^
         |
    仅移动页面引用
</code></pre></div>

<h3 id="412-system-v-ipc">4.1.2 System V IPC 机制详解</h3>
<p>System V IPC 是 AT&amp;T 在 System V Release 3 中引入的三种 IPC 机制的统称，包括消息队列、共享内存和信号量。尽管 POSIX 试图提供更现代的替代方案，System V IPC 因其广泛的应用仍然是 Linux 内核的重要组成部分。</p>
<h4 id="_3">通用架构与数据结构</h4>
<p>System V IPC 的三种机制共享相似的架构设计：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// include/linux/ipc.h</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">kern_ipc_perm</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w">      </span><span class="n">lock</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">            </span><span class="n">deleted</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">             </span><span class="n">id</span><span class="p">;</span><span class="w">             </span><span class="c1">// IPC 标识符</span>
<span class="w">    </span><span class="kt">key_t</span><span class="w">           </span><span class="n">key</span><span class="p">;</span><span class="w">            </span><span class="c1">// IPC 键值</span>
<span class="w">    </span><span class="n">kuid_t</span><span class="w">          </span><span class="n">uid</span><span class="p">;</span><span class="w">            </span><span class="c1">// 所有者 UID</span>
<span class="w">    </span><span class="n">kgid_t</span><span class="w">          </span><span class="n">gid</span><span class="p">;</span><span class="w">            </span><span class="c1">// 所有者 GID</span>
<span class="w">    </span><span class="n">kuid_t</span><span class="w">          </span><span class="n">cuid</span><span class="p">;</span><span class="w">           </span><span class="c1">// 创建者 UID</span>
<span class="w">    </span><span class="n">kgid_t</span><span class="w">          </span><span class="n">cgid</span><span class="p">;</span><span class="w">           </span><span class="c1">// 创建者 GID</span>
<span class="w">    </span><span class="n">umode_t</span><span class="w">         </span><span class="n">mode</span><span class="p">;</span><span class="w">           </span><span class="c1">// 访问权限</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">   </span><span class="n">seq</span><span class="p">;</span><span class="w">            </span><span class="c1">// 序列号</span>
<span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="o">*</span><span class="n">security</span><span class="p">;</span><span class="w">      </span><span class="c1">// LSM 安全标签</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rhash_head</span><span class="w"> </span><span class="n">khtnode</span><span class="p">;</span><span class="w">      </span><span class="c1">// 哈希表节点</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rcu_head</span><span class="w"> </span><span class="n">rcu</span><span class="p">;</span><span class="w">            </span><span class="c1">// RCU 头</span>
<span class="w">    </span><span class="n">refcount_t</span><span class="w">      </span><span class="n">refcount</span><span class="p">;</span><span class="w">       </span><span class="c1">// 引用计数</span>
<span class="p">}</span><span class="w"> </span><span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="c1">// IPC 命名空间结构</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ipc_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">refcount_t</span><span class="w">      </span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ipc_ids</span><span class="w">  </span><span class="n">ids</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w">        </span><span class="c1">// 三种 IPC 机制的 ID 表</span>

<span class="w">    </span><span class="kt">int</span><span class="w">             </span><span class="n">sem_ctls</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w">    </span><span class="c1">// 信号量限制参数</span>
<span class="w">    </span><span class="kt">int</span><span class="w">             </span><span class="n">used_sems</span><span class="p">;</span><span class="w">      </span><span class="c1">// 已使用的信号量数</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">msg_ctlmax</span><span class="p">;</span><span class="w">     </span><span class="c1">// 消息最大字节数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">msg_ctlmnb</span><span class="p">;</span><span class="w">     </span><span class="c1">// 队列最大字节数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">msg_ctlmni</span><span class="p">;</span><span class="w">     </span><span class="c1">// 最大队列数</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w">        </span><span class="n">msg_bytes</span><span class="p">;</span><span class="w">      </span><span class="c1">// 当前消息字节总数</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w">        </span><span class="n">msg_hdrs</span><span class="p">;</span><span class="w">       </span><span class="c1">// 当前消息头总数</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w">          </span><span class="n">shm_ctlmax</span><span class="p">;</span><span class="w">     </span><span class="c1">// 共享内存段最大大小</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w">          </span><span class="n">shm_ctlall</span><span class="p">;</span><span class="w">     </span><span class="c1">// 共享内存总大小限制</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">   </span><span class="n">shm_tot</span><span class="p">;</span><span class="w">        </span><span class="c1">// 当前共享内存页数</span>
<span class="w">    </span><span class="kt">int</span><span class="w">             </span><span class="n">shm_ctlmni</span><span class="p">;</span><span class="w">     </span><span class="c1">// 最大共享内存段数</span>
<span class="w">    </span><span class="kt">int</span><span class="w">             </span><span class="n">shm_rmid_forced</span><span class="p">;</span><span class="c1">// 强制删除标志</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">notifier_block</span><span class="w"> </span><span class="n">ipcns_nb</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">vfsmount</span><span class="w"> </span><span class="o">*</span><span class="n">mq_mnt</span><span class="p">;</span><span class="w">        </span><span class="c1">// POSIX 消息队列挂载点</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">mq_queues_count</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">mq_queues_max</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">mq_msg_max</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">mq_msgsize_max</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">mq_msg_default</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">    </span><span class="n">mq_msgsize_default</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="n">user_ns</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ucounts</span><span class="w">  </span><span class="o">*</span><span class="n">ucounts</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">llist_node</span><span class="w"> </span><span class="n">async_free_work</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="n">free_work</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div>

<h4 id="message-queue">消息队列（Message Queue）</h4>
<p>消息队列提供了一种进程间传递格式化数据的机制，每个消息都有类型标识，接收者可以选择性地接收特定类型的消息。</p>
<p><strong>核心数据结构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ipc/msg.c</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">msg_queue</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kern_ipc_perm</span><span class="w"> </span><span class="n">q_perm</span><span class="p">;</span>
<span class="w">    </span><span class="n">time64_t</span><span class="w"> </span><span class="n">q_stime</span><span class="p">;</span><span class="w">           </span><span class="c1">// 最后发送时间</span>
<span class="w">    </span><span class="n">time64_t</span><span class="w"> </span><span class="n">q_rtime</span><span class="p">;</span><span class="w">           </span><span class="c1">// 最后接收时间</span>
<span class="w">    </span><span class="n">time64_t</span><span class="w"> </span><span class="n">q_ctime</span><span class="p">;</span><span class="w">           </span><span class="c1">// 最后修改时间</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">q_cbytes</span><span class="p">;</span><span class="w">     </span><span class="c1">// 队列中当前字节数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">q_qnum</span><span class="p">;</span><span class="w">       </span><span class="c1">// 队列中消息数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">q_qbytes</span><span class="p">;</span><span class="w">     </span><span class="c1">// 队列最大字节数</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pid</span><span class="w"> </span><span class="o">*</span><span class="n">q_lspid</span><span class="p">;</span><span class="w">        </span><span class="c1">// 最后发送者 PID</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pid</span><span class="w"> </span><span class="o">*</span><span class="n">q_lrpid</span><span class="p">;</span><span class="w">        </span><span class="c1">// 最后接收者 PID</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">q_messages</span><span class="p">;</span><span class="w">    </span><span class="c1">// 消息链表</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">q_receivers</span><span class="p">;</span><span class="w">   </span><span class="c1">// 接收者等待队列</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">q_senders</span><span class="p">;</span><span class="w">     </span><span class="c1">// 发送者等待队列</span>
<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">msg_msg</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">m_list</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">m_type</span><span class="p">;</span><span class="w">                </span><span class="c1">// 消息类型</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">m_ts</span><span class="p">;</span><span class="w">                </span><span class="c1">// 消息大小</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">msg_msgseg</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">    </span><span class="c1">// 大消息的下一段</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">security</span><span class="p">;</span><span class="w">             </span><span class="c1">// 安全标签</span>
<span class="w">    </span><span class="c1">// 消息数据紧随其后</span>
<span class="p">};</span>

<span class="c1">// 大消息分段结构</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">msg_msgseg</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">msg_msgseg</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 分段数据紧随其后</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>消息发送流程</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 简化的 msgsnd 实现</span>
<span class="k">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">do_msgsnd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">msqid</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">mtype</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">mtext</span><span class="p">,</span>
<span class="w">                     </span><span class="kt">size_t</span><span class="w"> </span><span class="n">msgsz</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">msgflg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">msg_queue</span><span class="w"> </span><span class="o">*</span><span class="n">msq</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">msg_msg</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 分配消息结构</span>
<span class="w">    </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_msg</span><span class="p">(</span><span class="n">mtext</span><span class="p">,</span><span class="w"> </span><span class="n">msgsz</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

<span class="w">    </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mtype</span><span class="p">;</span>
<span class="w">    </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msgsz</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 查找消息队列</span>
<span class="w">    </span><span class="n">msq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msq_obtain_object_check</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span><span class="w"> </span><span class="n">msqid</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msq</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msq</span><span class="p">);</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out_free</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ipc_lock_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 检查权限</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ipcperms</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">,</span><span class="w"> </span><span class="n">S_IWUGO</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out_unlock</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 检查队列空间</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">msgsz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_cbytes</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_qbytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">msgflg</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">IPC_NOWAIT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out_unlock</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// 阻塞等待空间</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 将消息加入队列</span>
<span class="w">    </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_list</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_messages</span><span class="p">);</span>
<span class="w">    </span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_cbytes</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">msgsz</span><span class="p">;</span>
<span class="w">    </span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_qnum</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_add</span><span class="p">(</span><span class="n">msgsz</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">msg_bytes</span><span class="p">);</span>
<span class="w">    </span><span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">msg_hdrs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 唤醒等待的接收者</span>
<span class="w">    </span><span class="n">ss_wakeup</span><span class="p">(</span><span class="n">msq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wake_q</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="n">ipc_unlock_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msq</span><span class="o">-&gt;</span><span class="n">q_perm</span><span class="p">);</span>
<span class="w">    </span><span class="n">wake_up_q</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wake_q</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>消息队列的 $O(1)$ 查找优化</strong></p>
<p>Linux 使用基数树（radix tree）实现 IPC ID 到对象的快速映射：</p>
<div class="codehilite"><pre><span></span><code>IPC ID 结构：
+--------+--------+--------+
| seq(16)| idx(15)| use(1) |
+--------+--------+--------+

基数树查找：
     root
    /    \
   /      \
node1    node2
  |        |
 obj1     obj2
</code></pre></div>

<h4 id="shared-memory">共享内存（Shared Memory）</h4>
<p>共享内存是最快的 IPC 机制，因为进程直接访问同一块物理内存，避免了数据复制。</p>
<p><strong>核心实现</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ipc/shm.c</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">shmid_kernel</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kern_ipc_perm</span><span class="w"> </span><span class="n">shm_perm</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">shm_file</span><span class="p">;</span><span class="w">      </span><span class="c1">// 关联的文件对象</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">shm_nattch</span><span class="p">;</span><span class="w">    </span><span class="c1">// 当前附加数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">shm_segsz</span><span class="p">;</span><span class="w">     </span><span class="c1">// 段大小</span>
<span class="w">    </span><span class="n">time64_t</span><span class="w"> </span><span class="n">shm_atim</span><span class="p">;</span><span class="w">          </span><span class="c1">// 最后附加时间</span>
<span class="w">    </span><span class="n">time64_t</span><span class="w"> </span><span class="n">shm_dtim</span><span class="p">;</span><span class="w">          </span><span class="c1">// 最后分离时间</span>
<span class="w">    </span><span class="n">time64_t</span><span class="w"> </span><span class="n">shm_ctim</span><span class="p">;</span><span class="w">          </span><span class="c1">// 最后修改时间</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pid</span><span class="w"> </span><span class="o">*</span><span class="n">shm_cprid</span><span class="p">;</span><span class="w">       </span><span class="c1">// 创建者 PID</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pid</span><span class="w"> </span><span class="o">*</span><span class="n">shm_lprid</span><span class="p">;</span><span class="w">       </span><span class="c1">// 最后操作者 PID</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ucounts</span><span class="w"> </span><span class="o">*</span><span class="n">mlock_ucounts</span><span class="p">;</span><span class="w">  </span><span class="c1">// mlock 计数</span>

<span class="w">    </span><span class="c1">// 任务列表，用于 task-&gt;sysvshm.shm_clist</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">shm_clist</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ipc_namespace</span><span class="w"> </span><span class="o">*</span><span class="n">ns</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div>

<p><strong>共享内存映射过程</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// shmat 系统调用的核心逻辑</span>
<span class="kt">long</span><span class="w"> </span><span class="nf">do_shmat</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">shmid</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shmflg</span><span class="p">,</span>
<span class="w">             </span><span class="n">ulong</span><span class="w"> </span><span class="o">*</span><span class="n">raddr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">shmlba</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmid_kernel</span><span class="w"> </span><span class="o">*</span><span class="n">shp</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">shmaddr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">    </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAP_SHARED</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">prot</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">acc_mode</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ipc_namespace</span><span class="w"> </span><span class="o">*</span><span class="n">ns</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shm_file_data</span><span class="w"> </span><span class="o">*</span><span class="n">sfd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">f_flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">populate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 获取共享内存对象</span>
<span class="w">    </span><span class="n">shp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shm_obtain_object_check</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span><span class="w"> </span><span class="n">shmid</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">shp</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">shp</span><span class="p">);</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 权限检查</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ipcperms</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_perm</span><span class="p">,</span><span class="w"> </span><span class="n">acc_mode</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out_unlock</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 获取关联的文件</span>
<span class="w">    </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_file</span><span class="p">(</span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_file</span><span class="p">);</span>
<span class="w">    </span><span class="n">shp</span><span class="o">-&gt;</span><span class="n">shm_nattch</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i_size_read</span><span class="p">(</span><span class="n">file_inode</span><span class="p">(</span><span class="n">base</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// 创建 shm_file_data 结构</span>
<span class="w">    </span><span class="n">sfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sfd</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sfd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out_put</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_file_clone</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">f_flags</span><span class="p">,</span>
<span class="w">                           </span><span class="n">is_file_hugepages</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="w"> </span><span class="o">?</span>
<span class="w">                           </span><span class="o">&amp;</span><span class="n">shm_file_operations_huge</span><span class="w"> </span><span class="o">:</span>
<span class="w">                           </span><span class="o">&amp;</span><span class="n">shm_file_operations</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 使用 do_mmap 映射到进程地址空间</span>
<span class="w">    </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                  </span><span class="o">&amp;</span><span class="n">populate</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="o">*</span><span class="n">raddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">populate</span><span class="p">)</span>
<span class="w">        </span><span class="n">mm_populate</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">populate</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="semaphore">信号量（Semaphore）</h4>
<p>System V 信号量支持信号量集合和原子操作序列，比 POSIX 信号量功能更强大但也更复杂。</p>
<p><strong>信号量数据结构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ipc/sem.c</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sem_array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kern_ipc_perm</span><span class="w"> </span><span class="n">sem_perm</span><span class="p">;</span><span class="w">  </span><span class="c1">// IPC 权限</span>
<span class="w">    </span><span class="n">time64_t</span><span class="w">         </span><span class="n">sem_ctime</span><span class="p">;</span><span class="w">     </span><span class="c1">// 最后修改时间</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">pending_alter</span><span class="p">;</span><span class="w">  </span><span class="c1">// 待处理的修改操作</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">pending_const</span><span class="p">;</span><span class="w">  </span><span class="c1">// 待处理的常量操作</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">list_id</span><span class="p">;</span><span class="w">       </span><span class="c1">// undo 列表</span>
<span class="w">    </span><span class="kt">int</span><span class="w">              </span><span class="n">sem_nsems</span><span class="p">;</span><span class="w">     </span><span class="c1">// 信号量数量</span>
<span class="w">    </span><span class="kt">int</span><span class="w">              </span><span class="n">complex_count</span><span class="p">;</span><span class="w"> </span><span class="c1">// 复杂操作计数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">     </span><span class="n">use_global_lock</span><span class="p">;</span><span class="c1">// 全局锁标志</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sem</span><span class="w">       </span><span class="n">sems</span><span class="p">[];</span><span class="w">        </span><span class="c1">// 信号量数组</span>
<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">semval</span><span class="p">;</span><span class="w">                     </span><span class="c1">// 当前值</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pid</span><span class="w"> </span><span class="o">*</span><span class="n">sempid</span><span class="p">;</span><span class="w">             </span><span class="c1">// 最后操作的 PID</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w">                </span><span class="c1">// 每个信号量的锁</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">pending_alter</span><span class="p">;</span><span class="w"> </span><span class="c1">// 等待值改变的操作</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">pending_const</span><span class="p">;</span><span class="w"> </span><span class="c1">// 等待值不变的操作</span>
<span class="w">    </span><span class="n">time64_t</span><span class="w"> </span><span class="n">sem_otime</span><span class="p">;</span><span class="w">             </span><span class="c1">// 最后操作时间</span>
<span class="p">}</span><span class="w"> </span><span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
</code></pre></div>

<p><strong>信号量操作的原子性保证</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// semop 系统调用处理多个信号量操作</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">perform_atomic_semop</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sem_array</span><span class="w"> </span><span class="o">*</span><span class="n">sma</span><span class="p">,</span>
<span class="w">                               </span><span class="k">struct</span><span class="w"> </span><span class="nc">sem_queue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sembuf</span><span class="w"> </span><span class="o">*</span><span class="n">sop</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sem</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nsops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">nsops</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">semval</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 第一遍：检查所有操作是否可以执行</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nsops</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sems</span><span class="p">[</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">];</span>
<span class="w">        </span><span class="n">semval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">semval</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_op</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">semval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 操作会导致信号量值为负，不能执行</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 需要等待</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 第二遍：执行所有操作</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nsops</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sems</span><span class="p">[</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">];</span>

<span class="w">        </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">semval</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_op</span><span class="p">;</span>
<span class="w">        </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sempid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 成功执行</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="413-posix-ipc">4.1.3 POSIX IPC</h3>
<p>POSIX IPC 是 IEEE 1003.1b-1993 标准定义的进程间通信机制，旨在提供比 System V IPC 更清洁、更一致的接口。POSIX IPC 的设计充分吸取了 System V IPC 的经验教训，提供了基于文件描述符的操作模型，更好地集成到 Unix 的 "一切皆文件" 哲学中。</p>
<h4 id="posix">POSIX 消息队列</h4>
<p>POSIX 消息队列克服了 System V 消息队列的诸多限制，提供了消息优先级、异步通知等高级特性。</p>
<p><strong>核心数据结构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ipc/mqueue.c</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">mqueue_inode_info</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="n">vfs_inode</span><span class="p">;</span><span class="w">     </span><span class="c1">// VFS inode</span>
<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">wait_q</span><span class="p">;</span><span class="w">   </span><span class="c1">// 等待队列</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_root</span><span class="w"> </span><span class="n">msg_tree</span><span class="p">;</span><span class="w">    </span><span class="c1">// 消息红黑树（按优先级排序）</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_node</span><span class="w"> </span><span class="o">*</span><span class="n">msg_tree_rightmost</span><span class="p">;</span><span class="w">  </span><span class="c1">// 最右节点缓存</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">posix_msg_tree_node</span><span class="w"> </span><span class="o">*</span><span class="n">node_cache</span><span class="p">;</span><span class="w">  </span><span class="c1">// 节点缓存</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mq_attr</span><span class="w"> </span><span class="n">attr</span><span class="p">;</span><span class="w">        </span><span class="c1">// 队列属性</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigevent</span><span class="w"> </span><span class="n">notify</span><span class="p">;</span><span class="w">     </span><span class="c1">// 异步通知配置</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pid</span><span class="w"> </span><span class="o">*</span><span class="n">notify_owner</span><span class="p">;</span><span class="w">   </span><span class="c1">// 通知接收进程</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="n">notify_user_ns</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ucounts</span><span class="w"> </span><span class="o">*</span><span class="n">ucounts</span><span class="p">;</span><span class="w">    </span><span class="c1">// 用户计数</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">qsize</span><span class="p">;</span><span class="w">        </span><span class="c1">// 队列当前大小（字节）</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">mq_attr</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">mq_flags</span><span class="p">;</span><span class="w">      </span><span class="c1">// 队列标志（O_NONBLOCK）</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">mq_maxmsg</span><span class="p">;</span><span class="w">     </span><span class="c1">// 最大消息数</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">mq_msgsize</span><span class="p">;</span><span class="w">    </span><span class="c1">// 最大消息大小</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">mq_curmsgs</span><span class="p">;</span><span class="w">    </span><span class="c1">// 当前消息数</span>
<span class="p">};</span>

<span class="c1">// 消息节点结构</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">msg_msg</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_node</span><span class="w"> </span><span class="n">m_rb_node</span><span class="p">;</span><span class="w">   </span><span class="c1">// 红黑树节点</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">m_list</span><span class="p">;</span><span class="w">    </span><span class="c1">// 同优先级消息链表</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">m_type</span><span class="p">;</span><span class="w">                </span><span class="c1">// 消息优先级</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">m_ts</span><span class="p">;</span><span class="w">                </span><span class="c1">// 消息大小</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">msg_msgseg</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">    </span><span class="c1">// 大消息的下一段</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">security</span><span class="p">;</span><span class="w">             </span><span class="c1">// 安全标签</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>优先级队列实现</strong></p>
<p>POSIX 消息队列使用红黑树实现 $O(\log n)$ 的优先级队列：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 消息插入（按优先级）</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">msg_insert</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">msg_msg</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span>
<span class="w">                     </span><span class="k">struct</span><span class="w"> </span><span class="nc">mqueue_inode_info</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_node</span><span class="w"> </span><span class="o">**</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">posix_msg_tree_node</span><span class="w"> </span><span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">;</span><span class="w">  </span><span class="c1">// 优先级作为键</span>

<span class="w">    </span><span class="c1">// 查找插入位置</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="n">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">posix_msg_tree_node</span><span class="p">,</span><span class="w"> </span><span class="n">rb_node</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 相同优先级，加入链表尾部（FIFO）</span>
<span class="w">            </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_list</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 创建新的优先级节点</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">;</span>
<span class="w">        </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">leaf</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">leaf</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">);</span>
<span class="w">    </span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">    </span><span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">    </span><span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 更新最右节点缓存（最低优先级）</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree_rightmost</span><span class="p">)</span>
<span class="w">        </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree_rightmost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>

<span class="w">    </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_list</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>异步通知机制</strong></p>
<p>POSIX 消息队列支持三种通知方式：</p>
<ol>
<li><strong>信号通知</strong>：向指定进程发送信号</li>
<li><strong>线程通知</strong>：创建新线程执行通知函数</li>
<li><strong>信号值通知</strong>：发送带值的实时信号</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// mq_notify 实现</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">mq_notify</span><span class="p">,</span><span class="w"> </span><span class="n">mqd_t</span><span class="p">,</span><span class="w"> </span><span class="n">mqdes</span><span class="p">,</span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigevent</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">u_notification</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fd</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mqueue_inode_info</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigevent</span><span class="w"> </span><span class="n">notification</span><span class="p">;</span>

<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdget</span><span class="p">(</span><span class="n">mqdes</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

<span class="w">    </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">file_inode</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="p">));</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">u_notification</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notification</span><span class="p">,</span><span class="w"> </span><span class="n">u_notification</span><span class="p">,</span>
<span class="w">                          </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sigevent</span><span class="p">)))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">SIGEV_NONE</span><span class="p">:</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">SIGEV_SIGNAL</span><span class="p">:</span>
<span class="w">            </span><span class="c1">// 设置信号通知</span>
<span class="w">            </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">;</span>
<span class="w">            </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">;</span>
<span class="w">            </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_pid</span><span class="p">(</span><span class="n">task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">SIGEV_THREAD</span><span class="p">:</span>
<span class="w">            </span><span class="c1">// 线程通知需要用户空间库支持</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 取消通知</span>
<span class="w">        </span><span class="n">put_pid</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="p">);</span>
<span class="w">        </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fdput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="posix_1">POSIX 共享内存</h4>
<p>POSIX 共享内存通过 tmpfs 文件系统实现，提供了更灵活的内存映射机制。</p>
<p><strong>实现架构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// POSIX 共享内存基于 tmpfs</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_system_type</span><span class="w"> </span><span class="n">shmem_fs_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">owner</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;tmpfs&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_fs_context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shmem_init_fs_context</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">kill_sb</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">kill_litter_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// shm_open 实际上是在 /dev/shm 下创建文件</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">shm_open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">oflag</span><span class="p">,</span><span class="w"> </span><span class="kt">mode_t</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">pathname</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 构造路径 /dev/shm/name</span>
<span class="w">    </span><span class="n">snprintf</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span><span class="w"> </span><span class="n">PATH_MAX</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;/dev/shm/%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 使用 open 系统调用</span>
<span class="w">    </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span><span class="w"> </span><span class="n">oflag</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>与 System V 共享内存的对比</strong></p>
<p>| 特性 | System V | POSIX |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>System V</th>
<th>POSIX</th>
</tr>
</thead>
<tbody>
<tr>
<td>命名空间</td>
<td>IPC 键值</td>
<td>文件系统路径</td>
</tr>
<tr>
<td>持久性</td>
<td>直到显式删除</td>
<td>可选持久化</td>
</tr>
<tr>
<td>大小调整</td>
<td>创建时固定</td>
<td>ftruncate 动态调整</td>
</tr>
<tr>
<td>权限管理</td>
<td>IPC 权限位</td>
<td>文件系统权限</td>
</tr>
<tr>
<td>同步机制</td>
<td>需要信号量</td>
<td>可用文件锁</td>
</tr>
</tbody>
</table>
<p><strong>内存映射优化</strong></p>
<p>POSIX 共享内存支持大页（Huge Pages）映射：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用大页的共享内存</span>
<span class="kt">int</span><span class="w"> </span><span class="n">shm_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shm_open</span><span class="p">(</span><span class="s">&quot;/hugepage_shm&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_CREAT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">,</span><span class="w"> </span><span class="mo">0666</span><span class="p">);</span>

<span class="c1">// 设置大页标志</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">statfs</span><span class="w"> </span><span class="n">fs_stats</span><span class="p">;</span>
<span class="n">fstatfs</span><span class="p">(</span><span class="n">shm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fs_stats</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fs_stats</span><span class="p">.</span><span class="n">f_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">HUGETLBFS_MAGIC</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 自动使用大页</span>
<span class="p">}</span>

<span class="c1">// 映射时指定 MAP_HUGETLB</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span>
<span class="w">                 </span><span class="n">MAP_SHARED</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MAP_HUGETLB</span><span class="p">,</span><span class="w"> </span><span class="n">shm_fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>

<h4 id="posix_2">POSIX 信号量</h4>
<p>POSIX 信号量提供了两种类型：命名信号量和未命名信号量，相比 System V 信号量更加简洁。</p>
<p><strong>信号量实现</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// kernel/locking/semaphore.c</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">raw_spinlock_t</span><span class="w">      </span><span class="n">lock</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">        </span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w">    </span><span class="n">wait_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// POSIX 信号量的用户空间表示</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">__size</span><span class="p">[</span><span class="n">__SIZEOF_SEM_T</span><span class="p">];</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__align</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">sem_t</span><span class="p">;</span>

<span class="c1">// 内核中的 POSIX 信号量操作</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">posix_sem_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">wait</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">timedwait</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">sem</span><span class="p">,</span><span class="w"> </span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">timespec</span><span class="w"> </span><span class="o">*</span><span class="n">abs_timeout</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">trywait</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">post</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getvalue</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">sem</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">sval</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>未命名信号量的共享内存实现</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 进程间共享的未命名信号量</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">shared_sem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="n">sem</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pshared</span><span class="p">;</span><span class="w">            </span><span class="c1">// PTHREAD_PROCESS_SHARED</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">refcount</span><span class="p">;</span><span class="w">      </span><span class="c1">// 引用计数</span>
<span class="p">};</span>

<span class="c1">// sem_init 实现</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span><span class="w"> </span><span class="o">*</span><span class="n">sem</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pshared</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shared_sem</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pshared</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PTHREAD_PROCESS_SHARED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 分配共享内存段</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span><span class="w"> </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span>
<span class="w">                </span><span class="n">MAP_SHARED</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 进程私有信号量</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pshared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pshared</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">shared_sem</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="n">sem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>自适应等待优化</strong></p>
<p>POSIX 信号量实现了自适应等待策略，在轻度竞争时自旋，重度竞争时睡眠：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 自适应等待实现</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">adaptive_sem_wait</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">spin_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_SPINS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 快速路径：尝试获取</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">raw_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
<span class="w">            </span><span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 自适应自旋</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">spin_count</span><span class="o">++</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_SPINS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">raw_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
<span class="w">                    </span><span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">cpu_relax</span><span class="p">();</span><span class="w">  </span><span class="c1">// 处理器特定的自旋等待</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 慢速路径：睡眠等待</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__sem_wait_slowpath</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="system-v-ipc">与 System V IPC 对比</h4>
<p><strong>架构差异</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nv">System</span><span class="w"> </span><span class="nv">V</span><span class="w"> </span><span class="nv">IPC</span><span class="w"> </span>架构：
<span class="w">    </span>用户空间
<span class="w">        </span><span class="o">|</span>
<span class="w">    </span>系统调用接口<span class="w"> </span><span class="ss">(</span><span class="nv">msgget</span>,<span class="w"> </span><span class="nv">shmat</span>,<span class="w"> </span><span class="nv">semget</span><span class="ss">)</span>
<span class="w">        </span><span class="o">|</span>
<span class="w">    </span><span class="nv">IPC</span><span class="w"> </span>命名空间
<span class="w">        </span><span class="o">|</span>
<span class="w">    </span><span class="nv">IPC</span><span class="w"> </span>对象管理器
<span class="w">        </span><span class="o">|</span>
<span class="w">    </span>内核数据结构

<span class="nv">POSIX</span><span class="w"> </span><span class="nv">IPC</span><span class="w"> </span>架构：
<span class="w">    </span>用户空间
<span class="w">        </span><span class="o">|</span>
<span class="w">    </span>文件系统接口<span class="w"> </span><span class="ss">(</span><span class="nv">open</span>,<span class="w"> </span><span class="nv">mmap</span>,<span class="w"> </span><span class="k">unlink</span><span class="ss">)</span>
<span class="w">        </span><span class="o">|</span>
<span class="w">    </span><span class="nv">VFS</span><span class="w"> </span>层
<span class="w">        </span><span class="o">|</span>
<span class="w">    </span>特殊文件系统<span class="w"> </span><span class="ss">(</span><span class="nv">mqueue</span>,<span class="w"> </span><span class="nv">tmpfs</span><span class="ss">)</span>
<span class="w">        </span><span class="o">|</span>
<span class="w">    </span>内核数据结构
</code></pre></div>

<p><strong>性能对比</strong></p>
<p>| 操作 | System V | POSIX | 性能差异原因 |</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>System V</th>
<th>POSIX</th>
<th>性能差异原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建开销</td>
<td>中等</td>
<td>较低</td>
<td>POSIX 利用文件系统缓存</td>
</tr>
<tr>
<td>查找速度</td>
<td>O(1)</td>
<td>O(log n)</td>
<td>System V 使用哈希表</td>
</tr>
<tr>
<td>内存占用</td>
<td>较高</td>
<td>较低</td>
<td>POSIX 共享 VFS 结构</td>
</tr>
<tr>
<td>并发性能</td>
<td>一般</td>
<td>较好</td>
<td>POSIX 细粒度锁</td>
</tr>
<tr>
<td>持久化</td>
<td>自动</td>
<td>可选</td>
<td>System V 默认持久</td>
</tr>
</tbody>
</table>
<p><strong>选择建议</strong></p>
<ol>
<li>
<p><strong>使用 POSIX IPC 的场景</strong>：
   - 新开发的应用程序
   - 需要与文件系统集成
   - 需要精确的超时控制
   - 跨平台可移植性要求高</p>
</li>
<li>
<p><strong>使用 System V IPC 的场景</strong>：
   - 维护遗留系统
   - 需要信号量集合的原子操作
   - 需要消息类型过滤
   - 已有大量 System V IPC 代码</p>
</li>
</ol>
<h2 id="43">4.3 信号机制实现</h2>
<p>信号是 Unix 系统最古老的进程间通信机制之一，也是异步事件通知的核心机制。Linux 内核不仅完整实现了 POSIX.1 标准信号，还扩展了实时信号支持，提供了更丰富的信号信息传递能力。理解信号机制的内核实现对于编写健壮的系统程序至关重要。</p>
<h3 id="431">4.3.1 信号基础架构</h3>
<p>Linux 信号机制建立在精巧的数据结构和算法之上，实现了高效的信号产生、投递和处理流程。</p>
<h4 id="_4">信号的产生与投递</h4>
<p><strong>核心数据结构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// include/linux/sched/signal.h</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">signal_struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">refcount_t</span><span class="w">      </span><span class="n">sigcnt</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w">        </span><span class="n">live</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">             </span><span class="n">nr_threads</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">thread_head</span><span class="p">;</span>

<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">wait_chldexit</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 当前进程组信号处理器</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_sigaction</span><span class="w"> </span><span class="n">action</span><span class="p">[</span><span class="n">_NSIG</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// 共享的挂起信号</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigpending</span><span class="w"> </span><span class="n">shared_pending</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// POSIX 定时器列表</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">posix_timers</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 实时定时器</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hrtimer</span><span class="w"> </span><span class="n">real_timer</span><span class="p">;</span>
<span class="w">    </span><span class="n">ktime_t</span><span class="w"> </span><span class="n">real_timer_offset</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// CPU 时间限制</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_cputime</span><span class="w"> </span><span class="n">cputime_expires</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">cpu_timers</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// 进程组信息</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pid</span><span class="w"> </span><span class="o">*</span><span class="n">pgrp</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pid</span><span class="w"> </span><span class="o">*</span><span class="n">tty_old_pgrp</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 会话领导者</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">leader</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tty_struct</span><span class="w"> </span><span class="o">*</span><span class="n">tty</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 累积的资源使用统计</span>
<span class="w">    </span><span class="n">seqlock_t</span><span class="w"> </span><span class="n">stats_lock</span><span class="p">;</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">utime</span><span class="p">,</span><span class="w"> </span><span class="n">stime</span><span class="p">,</span><span class="w"> </span><span class="n">cutime</span><span class="p">,</span><span class="w"> </span><span class="n">cstime</span><span class="p">;</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">gtime</span><span class="p">,</span><span class="w"> </span><span class="n">cgtime</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">prev_cputime</span><span class="w"> </span><span class="n">prev_cputime</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nvcsw</span><span class="p">,</span><span class="w"> </span><span class="n">nivcsw</span><span class="p">,</span><span class="w"> </span><span class="n">cnvcsw</span><span class="p">,</span><span class="w"> </span><span class="n">cnivcsw</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">min_flt</span><span class="p">,</span><span class="w"> </span><span class="n">maj_flt</span><span class="p">,</span><span class="w"> </span><span class="n">cmin_flt</span><span class="p">,</span><span class="w"> </span><span class="n">cmaj_flt</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">inblock</span><span class="p">,</span><span class="w"> </span><span class="n">oublock</span><span class="p">,</span><span class="w"> </span><span class="n">cinblock</span><span class="p">,</span><span class="w"> </span><span class="n">coublock</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">maxrss</span><span class="p">,</span><span class="w"> </span><span class="n">cmaxrss</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_io_accounting</span><span class="w"> </span><span class="n">ioac</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 审计上下文</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">sum_sched_runtime</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rlimit</span><span class="w"> </span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIM_NLIMITS</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// 进程组是否为孤儿</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">is_child_subreaper</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">has_child_subreaper</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 每个线程的信号信息</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sighand_struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w">      </span><span class="n">siglock</span><span class="p">;</span>
<span class="w">    </span><span class="n">refcount_t</span><span class="w">      </span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">signalfd_wqh</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_sigaction</span><span class="w"> </span><span class="n">action</span><span class="p">[</span><span class="n">_NSIG</span><span class="p">];</span><span class="w">  </span><span class="c1">// 信号处理器数组</span>
<span class="p">};</span>

<span class="c1">// 挂起信号队列</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sigpending</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w">     </span><span class="c1">// 信号队列链表</span>
<span class="w">    </span><span class="kt">sigset_t</span><span class="w"> </span><span class="n">signal</span><span class="p">;</span><span class="w">           </span><span class="c1">// 挂起信号位图</span>
<span class="p">};</span>

<span class="c1">// 信号队列项</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sigqueue</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">list</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">kernel_siginfo_t</span><span class="w"> </span><span class="n">info</span><span class="p">;</span><span class="w">     </span><span class="c1">// 信号信息</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ucounts</span><span class="w"> </span><span class="o">*</span><span class="n">ucounts</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>信号产生流程</strong></p>
<p>信号可以通过多种方式产生：</p>
<ol>
<li><strong>硬件异常</strong>：如除零错误、段错误</li>
<li><strong>软件条件</strong>：如 alarm 定时器到期</li>
<li><strong>终端输入</strong>：如 Ctrl+C 产生 SIGINT</li>
<li><strong>系统调用</strong>：如 kill()、raise()</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// kernel/signal.c - kill 系统调用实现</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">kill</span><span class="p">,</span><span class="w"> </span><span class="kt">pid_t</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kernel_siginfo</span><span class="w"> </span><span class="n">info</span><span class="p">;</span>

<span class="w">    </span><span class="n">prepare_kill_siginfo</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">kill_something_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kill_something_info</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kernel_siginfo</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 发送给指定进程</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kill_pid_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">find_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 发送给进程组</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kill_pgrp_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">task_pgrp</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 发送给所有进程（除了 init）</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kill_all_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 发送给指定进程组</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kill_pgrp_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">find_vpid</span><span class="p">(</span><span class="o">-</span><span class="n">pid</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>信号投递算法</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 信号投递的核心函数</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">__send_signal</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kernel_siginfo</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="w">                        </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">pid_type</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigpending</span><span class="w"> </span><span class="o">*</span><span class="n">pending</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigqueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">override_rlimit</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 检查信号是否被忽略</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRACE_SIGNAL_IGNORED</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">prepare_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">force</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 选择挂起信号队列（线程私有或进程共享）</span>
<span class="w">    </span><span class="n">pending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">PIDTYPE_PID</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 检查是否为传统信号且已在队列中</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">legacy_queue</span><span class="p">(</span><span class="n">pending</span><span class="p">,</span><span class="w"> </span><span class="n">sig</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 分配信号队列项</span>
<span class="w">    </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__sigqueue_alloc</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_ATOMIC</span><span class="p">,</span><span class="w"> </span><span class="n">override_rlimit</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="no">unsigned</span><span class="w"> </span><span class="no">long</span><span class="p">)</span><span class="w"> </span><span class="no">SEND_SIG_NOINFO</span><span class="p">:</span>
<span class="w">            </span><span class="n">clear_siginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sig</span><span class="p">;</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SI_USER</span><span class="p">;</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_tgid_nr_ns</span><span class="p">(</span><span class="n">current</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">task_active_pid_ns</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_uid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span>
<span class="w">                                             </span><span class="n">current_uid</span><span class="p">());</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="no">unsigned</span><span class="w"> </span><span class="no">long</span><span class="p">)</span><span class="w"> </span><span class="no">SEND_SIG_PRIV</span><span class="p">:</span>
<span class="w">            </span><span class="n">clear_siginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sig</span><span class="p">;</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SI_KERNEL</span><span class="p">;</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_uid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span>
<span class="w">            </span><span class="n">copy_siginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_si_special</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">               </span><span class="n">sig</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">SIGRTMIN</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SI_USER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 实时信号必须排队，如果内存不足则失败</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 设置信号位图</span>
<span class="w">    </span><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span><span class="w"> </span><span class="n">sig</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 唤醒目标进程</span>
<span class="w">    </span><span class="n">complete_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">);</span>

<span class="nl">ret</span><span class="p">:</span>
<span class="w">    </span><span class="n">trace_signal_generate</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">PIDTYPE_PID</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="_5">信号处理器注册</h4>
<p><strong>sigaction 系统调用</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// kernel/signal.c</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">rt_sigaction</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">sig</span><span class="p">,</span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigaction</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">act</span><span class="p">,</span>
<span class="w">               </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigaction</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">oact</span><span class="p">,</span>
<span class="w">               </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_sigaction</span><span class="w"> </span><span class="n">new_sa</span><span class="p">,</span><span class="w"> </span><span class="n">old_sa</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 检查信号号码有效性</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">sig</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">act</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sig_kernel_only</span><span class="p">(</span><span class="n">sig</span><span class="p">)))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">act</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="n">act</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">)))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="n">act</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_sa</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">oact</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">&amp;</span><span class="n">old_sa</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">oact</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">oact</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">old_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">old_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">)))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">do_sigaction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_sigaction</span><span class="w"> </span><span class="o">*</span><span class="n">act</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_sigaction</span><span class="w"> </span><span class="o">*</span><span class="n">oact</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">t</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_sigaction</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
<span class="w">    </span><span class="kt">sigset_t</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">sig</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">act</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sig_kernel_only</span><span class="p">(</span><span class="n">sig</span><span class="p">)))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">sig</span><span class="mi">-1</span><span class="p">];</span>

<span class="w">    </span><span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">oact</span><span class="p">)</span>
<span class="w">        </span><span class="o">*</span><span class="n">oact</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">act</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>
<span class="w">        </span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">act</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 如果设置为 SIG_IGN，清除挂起的信号</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sig_handler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">sig</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SIG_IGN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
<span class="w">            </span><span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">sig</span><span class="p">);</span>
<span class="w">            </span><span class="n">flush_sigqueue_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">);</span>
<span class="w">            </span><span class="n">for_each_thread</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">                </span><span class="n">flush_sigqueue_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="pending">信号掩码与 Pending 信号</h4>
<p><strong>信号掩码操作</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 信号掩码的原子操作</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sigaddset</span><span class="p">(</span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">_sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_sig</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">1UL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sig</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="n">sig</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">_NSIG_BPW</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">1UL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">sig</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">_NSIG_BPW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sigdelset</span><span class="p">(</span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">_sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_sig</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">1UL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sig</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="n">sig</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">_NSIG_BPW</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">1UL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">sig</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">_NSIG_BPW</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">sigismember</span><span class="p">(</span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">_sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_sig</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1UL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sig</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="n">sig</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">_NSIG_BPW</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1UL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">sig</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">_NSIG_BPW</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>信号的阻塞与解除</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// sigprocmask 系统调用</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">rt_sigprocmask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">how</span><span class="p">,</span><span class="w"> </span><span class="kt">sigset_t</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">nset</span><span class="p">,</span>
<span class="w">               </span><span class="kt">sigset_t</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">oset</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">sigset_t</span><span class="w"> </span><span class="n">old_set</span><span class="p">,</span><span class="w"> </span><span class="n">new_set</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 保存旧的信号掩码</span>
<span class="w">    </span><span class="n">old_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_set</span><span class="p">,</span><span class="w"> </span><span class="n">nset</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">sigset_t</span><span class="p">)))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">        </span><span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_set</span><span class="p">,</span><span class="w"> </span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>

<span class="w">        </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">how</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_set</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">oset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">oset</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">old_set</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">sigset_t</span><span class="p">)))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 设置信号掩码</span>
<span class="kt">int</span><span class="w"> </span><span class="n">sigprocmask</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">how</span><span class="p">,</span><span class="w"> </span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="kt">sigset_t</span><span class="w"> </span><span class="o">*</span><span class="n">oldset</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">tsk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="kt">sigset_t</span><span class="w"> </span><span class="n">newset</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 根据操作类型计算新掩码</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">how</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SIG_BLOCK</span><span class="p">:</span>
<span class="w">        </span><span class="n">sigorsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span><span class="w"> </span><span class="n">set</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SIG_UNBLOCK</span><span class="p">:</span>
<span class="w">        </span><span class="n">sigandnsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span><span class="w"> </span><span class="n">set</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SIG_SETMASK</span><span class="p">:</span>
<span class="w">        </span><span class="n">newset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">set</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">__set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="432">4.3.2 实时信号扩展</h3>
<p>Linux 支持 POSIX.1b 实时信号扩展，提供了更可靠的信号机制。</p>
<h4 id="vs">标准信号 vs 实时信号</h4>
<p><strong>信号分类</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// include/uapi/asm-generic/signal.h</span>
<span class="cp">#define SIGHUP       1  </span><span class="c1">// 终端挂起</span>
<span class="cp">#define SIGINT       2  </span><span class="c1">// 终端中断（Ctrl+C）</span>
<span class="cp">#define SIGQUIT      3  </span><span class="c1">// 终端退出（Ctrl+\）</span>
<span class="cp">#define SIGILL       4  </span><span class="c1">// 非法指令</span>
<span class="cp">#define SIGTRAP      5  </span><span class="c1">// 跟踪/断点陷阱</span>
<span class="cp">#define SIGABRT      6  </span><span class="c1">// abort() 调用</span>
<span class="cp">#define SIGBUS       7  </span><span class="c1">// 总线错误</span>
<span class="cp">#define SIGFPE       8  </span><span class="c1">// 浮点异常</span>
<span class="cp">#define SIGKILL      9  </span><span class="c1">// 强制终止（不可捕获）</span>
<span class="cp">#define SIGUSR1     10  </span><span class="c1">// 用户定义信号 1</span>
<span class="cp">#define SIGSEGV     11  </span><span class="c1">// 段错误</span>
<span class="cp">#define SIGUSR2     12  </span><span class="c1">// 用户定义信号 2</span>
<span class="cp">#define SIGPIPE     13  </span><span class="c1">// 管道破裂</span>
<span class="cp">#define SIGALRM     14  </span><span class="c1">// alarm() 定时器</span>
<span class="cp">#define SIGTERM     15  </span><span class="c1">// 终止请求</span>
<span class="cp">#define SIGSTKFLT   16  </span><span class="c1">// 协处理器栈错误</span>
<span class="cp">#define SIGCHLD     17  </span><span class="c1">// 子进程状态改变</span>
<span class="cp">#define SIGCONT     18  </span><span class="c1">// 继续执行</span>
<span class="cp">#define SIGSTOP     19  </span><span class="c1">// 停止执行（不可捕获）</span>
<span class="cp">#define SIGTSTP     20  </span><span class="c1">// 终端停止（Ctrl+Z）</span>
<span class="cp">#define SIGTTIN     21  </span><span class="c1">// 后台进程读终端</span>
<span class="cp">#define SIGTTOU     22  </span><span class="c1">// 后台进程写终端</span>
<span class="cp">#define SIGURG      23  </span><span class="c1">// 紧急数据到达</span>
<span class="cp">#define SIGXCPU     24  </span><span class="c1">// CPU 时间限制超出</span>
<span class="cp">#define SIGXFSZ     25  </span><span class="c1">// 文件大小限制超出</span>
<span class="cp">#define SIGVTALRM   26  </span><span class="c1">// 虚拟定时器</span>
<span class="cp">#define SIGPROF     27  </span><span class="c1">// 性能分析定时器</span>
<span class="cp">#define SIGWINCH    28  </span><span class="c1">// 终端窗口大小改变</span>
<span class="cp">#define SIGIO       29  </span><span class="c1">// I/O 就绪</span>
<span class="cp">#define SIGPWR      30  </span><span class="c1">// 电源故障</span>
<span class="cp">#define SIGSYS      31  </span><span class="c1">// 系统调用参数错误</span>

<span class="c1">// 实时信号范围</span>
<span class="cp">#define SIGRTMIN    32</span>
<span class="cp">#define SIGRTMAX    64</span>
</code></pre></div>

<p><strong>关键差异</strong></p>
<p>| 特性 | 标准信号（1-31） | 实时信号（32-64） |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>标准信号（1-31）</th>
<th>实时信号（32-64）</th>
</tr>
</thead>
<tbody>
<tr>
<td>排队</td>
<td>不排队，多个相同信号合并</td>
<td>可靠排队，不丢失</td>
</tr>
<tr>
<td>优先级</td>
<td>信号编号越小优先级越高</td>
<td>可自定义优先级</td>
</tr>
<tr>
<td>信息传递</td>
<td>仅信号编号</td>
<td>可携带额外数据</td>
</tr>
<tr>
<td>顺序保证</td>
<td>无保证</td>
<td>FIFO 顺序保证</td>
</tr>
<tr>
<td>用途</td>
<td>系统定义的特定事件</td>
<td>应用程序自定义</td>
</tr>
</tbody>
</table>
<h4 id="_6">信号队列机制</h4>
<p><strong>实时信号的可靠排队</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 实时信号队列管理</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sigqueue_cache</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigqueue</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigqueue</span><span class="w"> </span><span class="o">*</span><span class="n">__sigqueue_alloc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">t</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">gfp_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">override_rlimit</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigqueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ucounts</span><span class="w"> </span><span class="o">*</span><span class="n">ucounts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">sigpending</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 实时信号必须排队</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">sig</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">SIGRTMIN</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>
<span class="w">        </span><span class="p">(</span><span class="n">sigpending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inc_rlimit_ucounts</span><span class="p">(</span><span class="n">ucounts</span><span class="p">,</span><span class="w"> </span><span class="n">UCOUNT_RLIMIT_SIGPENDING</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">dec_rlimit_ucounts</span><span class="p">(</span><span class="n">ucounts</span><span class="p">,</span><span class="w"> </span><span class="n">UCOUNT_RLIMIT_SIGPENDING</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 从缓存或 slab 分配</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sigqueue_cache</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sigqueue_cache</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="w">        </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sigqueue_cache</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sigqueue_cache</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">sigqueue_cachep</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_flags</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ucounts</span><span class="p">)</span>
<span class="w">            </span><span class="n">dec_rlimit_ucounts</span><span class="p">(</span><span class="n">ucounts</span><span class="p">,</span><span class="w"> </span><span class="n">UCOUNT_RLIMIT_SIGPENDING</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="w">        </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ucounts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ucounts</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="siginfo_t">siginfo_t 结构详解</h4>
<p><strong>信号信息结构</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// include/uapi/asm-generic/siginfo.h</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kernel_siginfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">si_signo</span><span class="p">;</span><span class="w">    </span><span class="c1">// 信号编号</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">si_errno</span><span class="p">;</span><span class="w">    </span><span class="c1">// errno 值</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">si_code</span><span class="p">;</span><span class="w">     </span><span class="c1">// 信号来源代码</span>

<span class="w">        </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">_pad</span><span class="p">[</span><span class="n">SI_PAD_SIZE</span><span class="p">];</span>

<span class="w">            </span><span class="c1">// SIGKILL</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">__kernel_pid_t</span><span class="w"> </span><span class="n">_pid</span><span class="p">;</span><span class="w">    </span><span class="c1">// 发送进程 PID</span>
<span class="w">                </span><span class="n">__kernel_uid32_t</span><span class="w"> </span><span class="n">_uid</span><span class="p">;</span><span class="w">  </span><span class="c1">// 发送进程 UID</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">_kill</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// POSIX.1b 定时器</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">__kernel_timer_t</span><span class="w"> </span><span class="n">_tid</span><span class="p">;</span><span class="w">  </span><span class="c1">// 定时器 ID</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">_overrun</span><span class="p">;</span><span class="w">           </span><span class="c1">// 溢出计数</span>
<span class="w">                </span><span class="kt">sigval_t</span><span class="w"> </span><span class="n">_sigval</span><span class="p">;</span><span class="w">       </span><span class="c1">// 信号值</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">_sys_private</span><span class="p">;</span><span class="w">       </span><span class="c1">// 系统私有数据</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">_timer</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// POSIX.1b 信号</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">__kernel_pid_t</span><span class="w"> </span><span class="n">_pid</span><span class="p">;</span><span class="w">    </span><span class="c1">// 发送进程 PID</span>
<span class="w">                </span><span class="n">__kernel_uid32_t</span><span class="w"> </span><span class="n">_uid</span><span class="p">;</span><span class="w">  </span><span class="c1">// 发送进程 UID</span>
<span class="w">                </span><span class="kt">sigval_t</span><span class="w"> </span><span class="n">_sigval</span><span class="p">;</span><span class="w">       </span><span class="c1">// 信号值</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">_rt</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// SIGCHLD</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">__kernel_pid_t</span><span class="w"> </span><span class="n">_pid</span><span class="p">;</span><span class="w">    </span><span class="c1">// 子进程 PID</span>
<span class="w">                </span><span class="n">__kernel_uid32_t</span><span class="w"> </span><span class="n">_uid</span><span class="p">;</span><span class="w">  </span><span class="c1">// 子进程 UID</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">_status</span><span class="p">;</span><span class="w">            </span><span class="c1">// 退出状态</span>
<span class="w">                </span><span class="n">__kernel_clock_t</span><span class="w"> </span><span class="n">_utime</span><span class="p">;</span>
<span class="w">                </span><span class="n">__kernel_clock_t</span><span class="w"> </span><span class="n">_stime</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">_sigchld</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// SIGILL, SIGFPE, SIGSEGV, SIGBUS, SIGTRAP</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">_addr</span><span class="p">;</span><span class="w">     </span><span class="c1">// 故障地址</span>

<span class="w">                </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">// BUS_MCEERR_AR, BUS_MCEERR_AO</span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">_trapno</span><span class="p">;</span><span class="w">        </span><span class="c1">// TRAP 编号</span>

<span class="w">                    </span><span class="c1">// BUS_MCEERR_AR, BUS_MCEERR_AO</span>
<span class="w">                    </span><span class="kt">short</span><span class="w"> </span><span class="n">_addr_lsb</span><span class="p">;</span><span class="w">    </span><span class="c1">// 地址 LSB</span>

<span class="w">                    </span><span class="c1">// SEGV_BNDERR</span>
<span class="w">                    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">_lower</span><span class="p">;</span>
<span class="w">                        </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">_upper</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="n">_addr_bnd</span><span class="p">;</span>

<span class="w">                    </span><span class="c1">// SEGV_PKUERR</span>
<span class="w">                    </span><span class="n">__u32</span><span class="w"> </span><span class="n">_pkey</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">_sigfault</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// SIGPOLL</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kt">long</span><span class="w"> </span><span class="n">_band</span><span class="p">;</span><span class="w">     </span><span class="c1">// POLL_IN, POLL_OUT, POLL_MSG</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">_fd</span><span class="p">;</span><span class="w">        </span><span class="c1">// 文件描述符</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">_sigpoll</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// SIGSYS</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">_call_addr</span><span class="p">;</span><span class="w">    </span><span class="c1">// 调用地址</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">_syscall</span><span class="p">;</span><span class="w">                </span><span class="c1">// 系统调用号</span>
<span class="w">                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">_arch</span><span class="p">;</span><span class="w">          </span><span class="c1">// 架构</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">_sigsys</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">_sifields</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="n">kernel_siginfo_t</span><span class="p">;</span>
</code></pre></div>

<p><strong>信号代码定义</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 信号来源代码（si_code）</span>
<span class="cp">#define SI_USER      0      </span><span class="c1">// kill(), raise()</span>
<span class="cp">#define SI_KERNEL    0x80   </span><span class="c1">// 内核产生</span>
<span class="cp">#define SI_QUEUE    -1      </span><span class="c1">// sigqueue()</span>
<span class="cp">#define SI_TIMER    -2      </span><span class="c1">// POSIX.1b 定时器</span>
<span class="cp">#define SI_MESGQ    -3      </span><span class="c1">// POSIX.1b 消息队列</span>
<span class="cp">#define SI_ASYNCIO  -4      </span><span class="c1">// AIO 完成</span>
<span class="cp">#define SI_SIGIO    -5      </span><span class="c1">// SIGIO 排队</span>
<span class="cp">#define SI_TKILL    -6      </span><span class="c1">// tkill(), tgkill()</span>
<span class="cp">#define SI_DETHREAD -7      </span><span class="c1">// SIGCHLD from execve</span>

<span class="c1">// SIGILL 的 si_code</span>
<span class="cp">#define ILL_ILLOPC  1       </span><span class="c1">// 非法操作码</span>
<span class="cp">#define ILL_ILLOPN  2       </span><span class="c1">// 非法操作数</span>
<span class="cp">#define ILL_ILLADR  3       </span><span class="c1">// 非法寻址模式</span>
<span class="cp">#define ILL_ILLTRP  4       </span><span class="c1">// 非法陷阱</span>
<span class="cp">#define ILL_PRVOPC  5       </span><span class="c1">// 特权操作码</span>
<span class="cp">#define ILL_PRVREG  6       </span><span class="c1">// 特权寄存器</span>
<span class="cp">#define ILL_COPROC  7       </span><span class="c1">// 协处理器错误</span>
<span class="cp">#define ILL_BADSTK  8       </span><span class="c1">// 内部栈错误</span>

<span class="c1">// SIGSEGV 的 si_code</span>
<span class="cp">#define SEGV_MAPERR 1       </span><span class="c1">// 地址未映射</span>
<span class="cp">#define SEGV_ACCERR 2       </span><span class="c1">// 权限错误</span>
<span class="cp">#define SEGV_BNDERR 3       </span><span class="c1">// 边界检查失败</span>
<span class="cp">#define SEGV_PKUERR 4       </span><span class="c1">// 保护键错误</span>
</code></pre></div>

<h3 id="44-futex">4.4 futex 与用户态同步</h3>
<h4 id="441-futex">4.4.1 futex 设计原理</h4>
<ul>
<li>用户态快速路径</li>
<li>内核态慢速路径</li>
<li>futex 哈希表组织</li>
</ul>
<h4 id="442-futex">4.4.2 futex 操作详解</h4>
<ul>
<li>FUTEX_WAIT 与 FUTEX_WAKE</li>
<li>Priority Inheritance (PI) futex</li>
<li>Robust futex 机制</li>
</ul>
<h3 id="45-ipc">4.5 现代 IPC 机制</h3>
<h4 id="451-eventfd">4.5.1 eventfd</h4>
<ul>
<li>eventfd 实现原理</li>
<li>与 epoll 集成</li>
<li>eventfd 在虚拟化中的应用</li>
</ul>
<h4 id="452-signalfd-timerfd">4.5.2 signalfd 与 timerfd</h4>
<ul>
<li>信号的文件描述符抽象</li>
<li>定时器的文件描述符抽象</li>
<li>统一的事件处理模型</li>
</ul>
<h3 id="46">4.6 性能分析与优化</h3>
<ul>
<li>IPC 机制性能对比</li>
<li>零拷贝优化技术</li>
<li>NUMA 架构下的 IPC 优化</li>
</ul>
<h3 id="47">4.7 历史故事</h3>
<ul>
<li>Ulrich Drepper 与 futex 的诞生</li>
<li>System V IPC 到 POSIX IPC 的标准之争</li>
<li>Android Binder 的设计哲学</li>
</ul>
<h3 id="48">4.8 高级话题</h3>
<ul>
<li>io_uring 的异步通信模型</li>
<li>RDMA 在内核中的支持</li>
<li>用户态旁路技术（DPDK）</li>
</ul>
<h3 id="49">4.9 本章小结</h3>
<h3 id="410">4.10 练习题</h3>
<h3 id="411">4.11 常见陷阱与错误</h3>
<h3 id="412">4.12 最佳实践检查清单</h3>
            </article>
            
            <nav class="page-nav"><a href="chapter3.html" class="nav-link prev">← 第3章：内存管理架构</a><a href="chapter5.html" class="nav-link next">第5章：虚拟文件系统（VFS） →</a></nav>
        </main>
    </div>
</body>
</html>